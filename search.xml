<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[推荐系统小记]]></title>
      <url>/2017/08/04/recommand/</url>
      <content type="html"><![CDATA[<p><strong>本文是基于<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html" target="_blank" rel="external">探索推荐引擎内部的秘密</a>系列文章的笔记</strong><br><a id="more"></a></p>
<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>背景<br>人们需要从海量数据中快速获取目标信息</li>
<li>搜索引擎 vs. 推荐系统<br>主要区别在于用户对于自己的需求是否明确以及该需求能否用简单的关键字概括</li>
<li><p>工作原理</p>
<blockquote>
<p>推荐引擎利用特殊的信息过滤技术，将不同的物品或内容推荐给可能对它们感兴趣的用户。</p>
</blockquote>
</li>
<li><p>基本流程：数据源–&gt;推荐系统–&gt;用户<br><img src="/materials/img/recommand/recommand.jpg" alt="Recommand"></p>
</li>
<li>数据源<ul>
<li>要推荐的物品/内容的元数据：关键字、基因描述等</li>
<li>用户的基本信息</li>
<li>用户对物品/信息的偏好<ul>
<li>显式的用户反馈：评分、评论等</li>
<li>隐式的用户反馈：交互记录如购买、浏览等<br><em>Notes:显式的用户反馈 vs. 隐式的用户反馈</em></li>
</ul>
</li>
</ul>
</li>
<li>显式的用户反馈能较为准确地反映用户对商品的真实喜好，但是需要用户付出额外的代价(个人理解是获取这部分数据的难度相对较大)</li>
<li>隐式的用户反馈经分析和处理也能反映用户喜好，但是相对不够精确，存在噪音，而且在不同应用中需要构建不同的行为特征</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="按用户群体划分"><a href="#按用户群体划分" class="headerlink" title="按用户群体划分"></a>按用户群体划分</h4><ul>
<li>基于大众行为的推荐引擎：对每个用户给出同样的推荐，一般由系统管理员人为设定或者基于所有用户反馈统计得出：比如当下流行商品</li>
<li>个性化推荐引擎：对不同用户根据其偏好给出个性化的精准推荐</li>
</ul>
<h4 id="按数据源划分"><a href="#按数据源划分" class="headerlink" title="按数据源划分"></a>按数据源划分</h4><p>如何发现数据的相关性</p>
<ul>
<li>基于人口统计学的推荐：根据系统<strong>用户的基本信息</strong>发现用户的相关程度</li>
<li>基于内容的推荐：根据所推荐<strong>物品或内容的元数据</strong></li>
<li>基于协同过滤的推荐：根据<strong>用户对物品、信息的偏好</strong>发现物品或内容本身的相关性、或发现用户的相关性</li>
</ul>
<h4 id="按推荐模型的建立方式划分"><a href="#按推荐模型的建立方式划分" class="headerlink" title="按推荐模型的建立方式划分"></a>按推荐模型的建立方式划分</h4><ul>
<li>基于物品和用户本身的，这种推荐引擎将每个用户和每个物品都当作独立的实体，预测每个用户对于每个物品的喜好程度，这些信息往往是用一个二维矩阵描述的。由于用户感兴趣的物品远远小于总物品的数目，这样的模型导致大量的数据空置，即我们得到的二维矩阵往往是一个很大的<strong>稀疏矩阵</strong>。同时为了减小计算量，我们可以对物品和用户进行<strong>聚类</strong>，然后记录和计算一类用户对一类物品的喜好程度，但这样的模型又会在推荐的<strong>准确性</strong>上有损失。</li>
<li>基于关联规则的推荐（Rule-based Recommendation）：<strong>关联规则</strong>的挖掘已经是数据挖掘中的一个经典的问题，主要是挖掘一些<strong>数据的依赖关系</strong>，典型的场景就是“购物篮问题”，通过关联规则的挖掘，我们可以找到哪些物品经常被同时购买，或者用户购买了一些物品后通常会购买哪些其他的物品，当我们挖掘出这些关联规则之后，我们可以基于这些规则给用户进行推荐。</li>
<li>基于模型的推荐（Model-based Recommendation）：这是一个典型的<strong>机器学习</strong>的问题，可以将已有的用户喜好信息作为训练样本，训练出一个预测用户喜好的<strong>模型</strong>，这样以后用户在进入系统，可以基于此模型计算推荐。这种方法的问题在于如何将用户<strong>实时</strong>或者<strong>近期</strong>的喜好信息反馈给训练好的模型，从而提高推荐的准确度。</li>
</ul>
<p><em>Notes:在现在的推荐系统中，很少有只使用了一个推荐策略的推荐引擎，一般都是在不同的场景下使用不同的推荐策略从而达到最好的推荐效果</em></p>
<h3 id="推荐机制"><a href="#推荐机制" class="headerlink" title="推荐机制"></a>推荐机制</h3><p><em>各个推荐机制的工作原理、优缺点和应用场景</em><br>承接上面按照数据源划分的分类方式</p>
<ul>
<li>基于人口统计学的推荐</li>
<li>基于内容的推荐</li>
<li>基于协同过滤的推荐：根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，然后再基于这些关联性进行推荐。<ul>
<li>基于用户的协同过滤推荐</li>
<li>基于项目的协同过滤推荐</li>
<li>基于模型的协同过滤推荐</li>
</ul>
</li>
<li>混合的推荐机制<ul>
<li>加权混合</li>
<li>切换的混合</li>
<li>分区的混合</li>
<li>分层的混合</li>
</ul>
</li>
</ul>
<p><img src="/materials/img/recommand/conclude.png" alt="conclude"></p>
<p>对于混合推荐机制</p>
<ul>
<li>加权的混合（Weighted Hybridization）: 用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最好的推荐效果。</li>
<li>切换的混合（Switching Hybridization）：前面也讲到，其实对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，那么切换的混合方式，就是允许在不同的情况下，选择最为合适的推荐机制计算推荐。</li>
<li>分区的混合（Mixed Hybridization）：采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户。其实，Amazon，当当网等很多电子商务网站都是采用这样的方式，用户可以得到很全面的推荐，也更容易找到他们想要的东西。</li>
<li>分层的混合（Meta-Level Hybridization）: 采用多种推荐机制，并将一个推荐机制的结果作为另一个的输入，从而综合各个推荐机制的优缺点，得到更加准确的推荐。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>国内外的两个案例</p>
<ul>
<li>电子商务–亚马逊<ul>
<li>核心是通过数据挖掘算法和比较用户的消费偏好于其他用户进行对比，借以预测用户可能感兴趣的商品。</li>
<li>分区的混合的机制：将不同的推荐结果分不同的区显示给用户<ul>
<li>今日推荐 (Today’s Recommendation For You): 通常是根据用户的近期的历史购买或者查看记录，并结合时下流行的物品给出一个折中的推荐。</li>
<li>新产品的推荐 (New For You): 采用了基于内容的推荐机制 (Content-based Recommendation)，将一些新到物品推荐给用户。在方法选择上由于新物品没有大量的用户喜好信息，所以基于内容的推荐能很好的解决这个“冷启动”的问题。</li>
<li>捆绑销售 (Frequently Bought Together): 采用数据挖掘技术对用户的购买行为进行分析，找到经常被一起或同一个人购买的物品集，进行捆绑销售，这是一种典型的基于项目的协同过滤推荐机制。</li>
<li>别人购买 / 浏览的商品 (Customers Who Bought/See This Item Also Bought/See): 这也是一个典型的基于项目的协同过滤推荐的应用，通过社会化机制用户能更快更方便的找到自己感兴趣的物品。</li>
</ul>
</li>
<li>设计和用户体验<ul>
<li>基于社会化的推荐，Amazon 会给你事实的数据，让用户信服，例如：购买此物品的用户百分之多少也购买了那个物品；</li>
<li>基于物品本身的推荐，Amazon 也会列出推荐的理由，例如：因为你的购物框中有 <strong><em>，或者因为你购买过 </em></strong>，所以给你推荐类似的 <em>*</em>。</li>
<li>基于用户的 profile，包括：用户的行为、评分、收藏夹、购物车等，并提供了让用户自主管理自己 profile 的功能，通过这种方式用户可以更明确的告诉推荐引擎他的品味和意图是什么。</li>
</ul>
</li>
</ul>
</li>
<li>社交网络–豆瓣<ul>
<li>“豆瓣猜”：基于社会化的协同过滤的推荐，这样用户越多，用户的反馈越多，那么推荐的效果会越来越准确。</li>
<li>“看过”和“想看”：相较于亚马逊，模型相对简单，更加专注于用户的品味</li>
<li>“喜欢这个电影的人也喜欢的电影”：基于协同过滤</li>
</ul>
</li>
</ul>
<h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p>针对<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html?ca=drs-" target="_blank" rel="external">深入推荐引擎相关算法 - 协同过滤</a>的笔记</p>
<h3 id="集体智慧"><a href="#集体智慧" class="headerlink" title="集体智慧"></a>集体智慧</h3><blockquote>
<p>集体智慧是指在大量的人群的行为和数据中收集答案，帮助你对整个人群得到统计意义上的结论，这些结论是我们在单个个体上无法得到的，它往往是某种趋势或者人群中共性的部分。</p>
</blockquote>
<p>典型应用</p>
<ul>
<li>Wikipedia</li>
<li>Google–PageRank</li>
</ul>
<h3 id="协同过滤核心-Collaborative-Filtering"><a href="#协同过滤核心-Collaborative-Filtering" class="headerlink" title="协同过滤核心(Collaborative Filtering)"></a>协同过滤核心(Collaborative Filtering)</h3><blockquote>
<p>协同过滤一般是在海量的用户中发掘出一小部分和你<strong>品位比较类似</strong>的，在协同过滤中，这些用户成为<strong>邻居</strong>，然后根据他们喜欢的其他东西组织成一个<strong>排序</strong>的目录作为推荐给你。</p>
</blockquote>
<p>核心问题</p>
<ul>
<li>如何确定一个用户是不是和你有相似的品位？</li>
<li>如何将邻居们的喜好组织成一个排序的目录？<blockquote>
<p>协同过滤相对于集体智慧而言，它从一定程度上保留了个体的特征，就是你的品位偏好，所以它更多可以作为个性化推荐的算法思想。</p>
</blockquote>
</li>
</ul>
<h3 id="收集用户偏好"><a href="#收集用户偏好" class="headerlink" title="收集用户偏好"></a>收集用户偏好</h3><p>从用户的行为和偏好中发现规律，并基于此给予推荐</p>
<h4 id="用户行为所反映的用户偏好"><a href="#用户行为所反映的用户偏好" class="headerlink" title="用户行为所反映的用户偏好"></a>用户行为所反映的用户偏好</h4><ul>
<li>显式<ul>
<li>评分</li>
<li>投票</li>
<li>转发</li>
<li>保存书签</li>
<li>标记标签</li>
<li>评论</li>
</ul>
</li>
<li>隐式<ul>
<li>点击</li>
<li>页面停留时间</li>
<li>购买</li>
</ul>
</li>
</ul>
<h4 id="如何组合不同的用户行为"><a href="#如何组合不同的用户行为" class="headerlink" title="如何组合不同的用户行为"></a>如何组合不同的用户行为</h4><ul>
<li>将不同的行为<strong>分组</strong>：一般可以分为“查看”和“购买”等等，然后基于不同的行为，计算不同的用户/物品相似度。类似于当当网或者 Amazon 给出的“购买了该图书的人还购买了…”，“查看了图书的人还查看了…”</li>
<li>根据不同行为反映用户喜好的程度将它们进行<strong>加权</strong>，得到用户对于物品的总体喜好。一般来说，显式的用户反馈比隐式的权值大，但比较稀疏，毕竟进行显示反馈的用户是少数；同时相对于“查看”，“购买”行为反映用户喜好的程度更大，但这也因应用而异。</li>
</ul>
<h4 id="数据与处理"><a href="#数据与处理" class="headerlink" title="数据与处理"></a>数据与处理</h4><ul>
<li>减噪</li>
<li>归一化</li>
</ul>
<h3 id="寻找相似用户-物品"><a href="#寻找相似用户-物品" class="headerlink" title="寻找相似用户/物品"></a>寻找相似用户/物品</h3><p>根据用户喜好(用户偏好的二维矩阵)计算相似用户和物品，然后基于相似用户或者物品进行推荐</p>
<h4 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h4><p>基于向量（Vector），计算两个向量的距离，距离越近相似度越大。在推荐的场景中，在用户-物品偏好的二维矩阵中，我们可以将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，或者将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度。</p>
<p>常用相似度计算方法</p>
<ul>
<li>欧几里得距离<br>假设 x，y 是 n 维空间的两个点，它们之间的欧几里德距离是：$$d(x,y)=sqrt{(\sum(x_i-y_i)^2)}$$,对应的相似度计算表示为$$sim(x,y)=\frac{1}{1+d(x,y)}$$</li>
<li>皮尔逊相关系数<br>皮尔逊相关系数一般用于计算两个定距变量间联系的紧密程度，它的取值在[-1，+1]之间。<br>$$p(x,y)=\frac{\sumx_iy_i-n\overline{xy}}{(n-1)s_xs_y}$$,其中$s_xs_y$是$x$和$y$的样品标准偏差</li>
<li>Cosine相似度<br>Cosine相似度被广泛应用于计算文档数据的相似度<br>$$T(x,y)=\frac{x\cdot y}{||x||^2 \times ||y||^2}=\frac{\sumx_iy_i}{\sqrt{\sumx_i^2}\sqrt{\sumy_i^2}}$$</li>
<li>Tanimoto 系数（Tanimoto Coefficient）<br>Tanimoto系数也称为Jaccard系数，是Cosine相似度的扩展，也多用于计算文档数据的相似度：<br>$$T(x,y)=\frac{x\cdot y}{||x||^2+||y||^2-x\cdot y}=\frac{\sumx_iy_i}{\sqrt{\sumx_i^2}+\sqrt{\sumy_i^2}-\sumx_iy_i}$$</li>
</ul>
<h4 id="相似邻居计算"><a href="#相似邻居计算" class="headerlink" title="相似邻居计算"></a>相似邻居计算</h4><p>根据相似度找到用户-物品的邻居</p>
<p>常用的挑选邻居的原则</p>
<ul>
<li>固定数量的邻居：K-neighborhoods 或者 Fix-size neighborhoods:不论邻居的“远近”，只取最近的K个,这种方法对于孤立点的计算效果不好，因为要取固定个数的邻居，当它附近没有足够多比较相似的点，就被迫取一些不太相似的点作为邻居，这样就影响了邻居相似的程度</li>
<li>基于相似度门槛的邻居：Threshold-based neighborhoods:与计算固定数量的邻居的原则不同，基于相似度门槛的邻居计算是对邻居的远近进行最大值的限制，落在以当前点为中心，距离为K的区域中的所有点都作为当前点的邻居，这种方法计算得到的邻居个数不确定，但相似度不会出现较大的误差。这种方法计算出的邻居的相似度程度比前一种优，尤其是对孤立点的处理。<br><img src="/materials/img/recommand/neighbor.gif" alt="neighbor"></li>
</ul>
<h3 id="计算推荐"><a href="#计算推荐" class="headerlink" title="计算推荐"></a>计算推荐</h3><p>在得到了相邻用户和相邻物品后，可以基于这些信息为用户进行推荐</p>
<h4 id="基于用户的CF"><a href="#基于用户的CF" class="headerlink" title="基于用户的CF"></a>基于用户的CF</h4><p>基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到K邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。<br><img src="/materials/img/recommand/cf_user.gif" alt="cf_user"></p>
<h4 id="基于物品的CF"><a href="#基于物品的CF" class="headerlink" title="基于物品的CF"></a>基于物品的CF</h4><p>基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他。从计算的角度看，就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。<br><img src="/materials/img/recommand/cf_item.gif" alt="cf_item"></p>
<h4 id="User-CF-vs-Item-CF"><a href="#User-CF-vs-Item-CF" class="headerlink" title="User CF vs. Item CF"></a>User CF vs. Item CF</h4><ul>
<li>计算复杂度：两个算法在不同的系统中各有优势<ul>
<li>电子商务网站：Item CF 从性能和复杂度上比 User CF 更优，其中的一个主要原因就是对于一个在线网站，用户的数量往往大大超过物品的数量，同时物品的数据相对稳定，因此计算物品的相似度不但计算量较小，同时也不必频繁更新。</li>
<li>新闻，博客或者微内容的推荐系统，情况往往是相反的，物品的数量是海量的，同时也是更新频繁的，因而效率角度而言User CF 更优</li>
</ul>
</li>
<li>适用场景<ul>
<li>Item CF更适宜非社交网络，在非社交网络的网站中，内容内在的联系是很重要的推荐原则，同时 Item CF 便于为推荐做出解释</li>
<li>User CF更适宜社交网络，User CF 加上社会网络信息，可以增加用户对推荐解释的信服程度。</li>
</ul>
</li>
<li>推荐多样性与精度<ul>
<li>推荐多样性的度量方法<ul>
<li>从单个用户的角度度量，就是说给定一个用户，查看系统给出的推荐列表是否多样，也就是要比较推荐列表中的物品之间两两的相似度，不难想到，对这种度量方法，Item CF的多样性显然不如User CF的好，因为Item CF的推荐就是和以前看的东西最相似的。</li>
<li>考虑系统的多样性，也被称为<strong>覆盖率 (Coverage)</strong>，它是指一个推荐系统是否能够提供给所有用户丰富的选择。在这种指标下，Item CF的多样性要远远好于User CF, 因为 User CF总是倾向于推荐<strong>热门</strong>的，从另一个侧面看，也就是说，Item CF的推荐有很好的<strong>新颖性</strong>，很擅长推荐<strong>长尾</strong>里的物品。所以，尽管大多数情况，Item CF的精度略小于User CF，如果考虑多样性，Item CF却比 User CF好很多</li>
</ul>
</li>
<li>两种算法具有很好的互补性：结合的基本原则就是当采用 Item CF 导致系统对个人推荐的<strong>多样性</strong>不足时，我们通过加入 User CF 增加个人推荐的多样性，从而提高精度，而当因为采用 User CF 而使系统的整体多样性不足时，我们可以通过加入 Item CF 增加整体的多样性，同样同样可以提高推荐的精度。</li>
<li>例子：假设每个用户兴趣爱好都是广泛的，喜欢好几个领域的东西，不过每个用户肯定也有一个主要的领域，对这个领域会比其他领域更加关心。给定一个用户，假设他喜欢 3 个领域 A,B,C，A 是他喜欢的主要领域，这个时候我们来看User CF和Item CF倾向于做出什么推荐：如果用User CF,它会将A,B,C三个领域中比较热门的东西推荐给用户；而如果用ItemCF，它会基本上只推荐 A领域的东西给用户。所以我们看到因为User CF只推荐热门的，所以它在推荐长尾里项目方面的能力不足；而Item CF只推荐A领域给用户，这样他有限的推荐列表中就可能包含了一定数量的不热门的长尾物品，同时Item CF的推荐对这个用户而言，显然多样性不足。但是对整个系统而言，因为不同的用户的主要兴趣点不同，所以系统的覆盖率会比较好。</li>
</ul>
</li>
<li>用户对推荐算法的适应度<ul>
<li>对于 User CF，推荐的原则是假设用户会喜欢那些和他有相同喜好的用户喜欢的东西，但如果一个用户没有相同喜好的朋友，那 User CF 的算法的效果就会很差，所以一个用户对的 CF 算法的适应度是和他有多少<strong>共同喜好用户</strong>成正比的。</li>
<li>Item CF 算法也有一个基本假设，就是用户会喜欢和他以前喜欢的东西相似的东西，那么我们可以计算一个用户喜欢的物品的<strong>自相似度</strong>。一个用户喜欢物品的自相似度大，就说明他喜欢的东西都是比较相似的，也就是说他比较符合 Item CF 方法的基本假设，那么他对 Item CF 的适应度自然比较好；反之，如果自相似度小，就说明这个用户的喜好习惯并不满足 Item CF 方法的基本假设，那么对于这种用户，用 Item CF 方法做出好的推荐的可能性非常低。</li>
</ul>
</li>
</ul>
<h3 id="基于Apache-Mahout实现高效的协同过滤推荐"><a href="#基于Apache-Mahout实现高效的协同过滤推荐" class="headerlink" title="基于Apache Mahout实现高效的协同过滤推荐"></a>基于Apache Mahout实现高效的协同过滤推荐</h3><blockquote>
<p>Apache Mahout中提供的一个协同过滤算法的高效实现，它是一个基于Java实现的可扩展的，高效的推荐引擎。</p>
</blockquote>
<p><img src="/materials/img/recommand/mahout.gif" alt="mahout"><br>原作者简要介绍了使用<code>Apache Mahout</code>搭建推荐系统的输入数据格式，构建的数据对象、数据结构以及分别从User CF、Item CF、Slope One这三种协同过滤的推荐算法介绍了下如何调用</p>
<ul>
<li>User CF<ul>
<li>通过输入数据构建数据模型</li>
<li>计算用户相似度(各种相似度计算方法)</li>
<li>计算用户的近邻(两种计算方法：数量/阈值)</li>
<li>构建推荐系统</li>
</ul>
</li>
<li>Item CF<ul>
<li>通过输入数据构建数据模型</li>
<li>计算物品相似度(各种相似度计算方法)    </li>
<li>构建推荐系统</li>
</ul>
</li>
<li>Slope One<br>主要是针对大数据量提供的一种基于评分的轻量级的协同过滤算法，基本思想是将用户的评分之间的关系看作简单的线性关系<ul>
<li>根据Data Model创建数据之间线性关系的模型DiffStorage。</li>
<li>基于Data Model和DiffStorage创建SlopeOneRecommender，实现Slope One推荐策略。</li>
</ul>
</li>
</ul>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><blockquote>
<p>聚类 (Clustering) 就是将数据对象分组成为多个类或者簇 (Cluster)，它的目标是：在同一个簇中的对象之间具有较高的相似度，而不同簇中的对象差别较大。所以，在很多应用中，一个簇中的数据对象可以被作为一个整体来对待，从而减少计算量或者提高计算质量。</p>
</blockquote>
<h3 id="聚类问题分类"><a href="#聚类问题分类" class="headerlink" title="聚类问题分类"></a>聚类问题分类</h3><ul>
<li>聚类结果是排他的还是可重叠的:对于一个元素，他是否可以属于聚类结果中的多个簇中，如果是，则是一个可重叠的聚类问题，如果否，那么是一个排他的聚类问题。</li>
<li>基于层次还是基于划分<ul>
<li>基于划分：拿到一组对象，按照一定的原则将它们分成不同的组。</li>
<li>基于层次：将这些对象分等级，在顶层将对象进行大致的分组，随后每一组再被进一步的细分，也许所有路径最终都要到达一个单独实例，这是一种“自顶向下”的层次聚类解决方法，对应的，也有“自底向上”的。</li>
</ul>
</li>
<li>簇数目固定的还是无限制的聚类：聚类问题是在执行聚类算法前已经确定聚类的结果应该得到多少簇，还是根据数据本身的特征，由聚类算法选择合适的簇的数目。</li>
<li>基于距离还是基于概率分布模型<ul>
<li>基于距离的聚类问题：就是将距离近的相似的对象聚在一起。</li>
<li>基于概率分布模型的聚类问题：在一组对象中，找到能符合特定分布模型的点的集合，他们不一定是距离最近的或者最相似的，而是能完美的呈现出概率分布模型所描述的模型。<br><img src="/materials/img/recommand/distance_model.gif" alt="distance_model"></li>
</ul>
</li>
</ul>
<h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><h4 id="基于距离的聚类算法"><a href="#基于距离的聚类算法" class="headerlink" title="基于距离的聚类算法"></a>基于距离的聚类算法</h4><h5 id="K均值聚类算法"><a href="#K均值聚类算法" class="headerlink" title="K均值聚类算法"></a>K均值聚类算法</h5><p>基于距离的排他的划分方法</p>
<ul>
<li>基本原理<ul>
<li>首先创建一个初始划分，随机地选择k个对象，每个对象初始地代表了一个簇中心。对于其他的对象，根据其与各个簇中心的距离，将它们赋给最近的簇。</li>
<li>然后采用一种迭代的重定位技术，尝试通过对象在划分间移动来改进划分。所谓重定位技术，就是当有新的对象加入簇或者已有对象离开簇的时候，重新计算簇的平均值，然后对对象进行重新分配。这个过程不断重复，直到没有簇中对象的变化。</li>
</ul>
</li>
<li>优点：<ul>
<li>当结果簇是密集的，而且簇和簇之间的区别比较明显时，K均值的效果比较好。</li>
<li>对于处理大数据集，这个算法是相对可伸缩的和高效的，它的复杂度是 O(nkt)，n是对象的个数，k是簇的数目，t是迭代的次数</li>
<li>原理简单，实现起来也相对简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须事先给出k的个数，k的选择一般都基于一些经验值和多次实验结果，对于不同的数据集，k的取值没有可借鉴性。</li>
<li>K均值对“噪音”和孤立点数据是敏感的，少量这类的数据就能对平均值造成极大的影响。</li>
</ul>
</li>
</ul>
<h5 id="Canopy聚类算法"><a href="#Canopy聚类算法" class="headerlink" title="Canopy聚类算法"></a>Canopy聚类算法</h5><p>基本原理：首先应用成本低的近似的距离计算方法高效的将数据分为多个组，这里称为一个 Canopy，Canopy之间可以有重叠的部分；然后采用严格的距离计算方式准确的计算在同一Canopy中的点，将他们分配与最合适的簇中。Canopy聚类算法经常用于K均值聚类算法的预处理，用来找合适的k值和簇中心。</p>
<h5 id="模糊K均值聚类算法"><a href="#模糊K均值聚类算法" class="headerlink" title="模糊K均值聚类算法"></a>模糊K均值聚类算法</h5><p>基本原理：和K均值一样，只是它的聚类结果允许存在对象属于多个簇，也就是说它属于可重叠聚类算法，与K均值聚类原理类似，模糊K均值也是在待聚类对象向量集合上循环，但是它并不是将向量分配给距离最近的簇，而是计算向量与各个簇的相关性（Association）。</p>
<h4 id="基于概率分布模型的聚类算法"><a href="#基于概率分布模型的聚类算法" class="headerlink" title="基于概率分布模型的聚类算法"></a>基于概率分布模型的聚类算法</h4><h5 id="狄利克雷聚类算法"><a href="#狄利克雷聚类算法" class="headerlink" title="狄利克雷聚类算法"></a>狄利克雷聚类算法</h5><p>基本原理：首先需要定义一个分布模型，简单的例如：圆形，三角形等，复杂的例如正则分布，泊松分布等；然后按照模型对数据进行分类，将不同的对象加入一个模型，模型会增长或者收缩；每一轮过后需要对模型的各个参数进行重新计算，同时估计对象属于这个模型的概率。</p>
<p>参考资料</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html" target="_blank" rel="external">探索推荐引擎内部的秘密</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> Recommand System </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随机森林]]></title>
      <url>/2017/08/03/rf/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p><strong>bagging+decision tree+randomness</strong><br>简言之，随机森林是将多棵决策树模型以bagging的集成方式组合在一起并引入随机性的一种集成模型</p>
<ul>
<li>bagging从bias-variance分解的角度来看倾向于减少模型的方差<ul>
<li>随机森林的偏差值往往趋向于所有基学习器的偏差的期望值，也就意味着随机森林的偏差难以进一步提高，所以只有从方差的角度来改善模型性能</li>
<li>随机森林改善模型的方差的方法主要是减小基学习器之间的相关性，通过特征扰动来实现</li>
<li>关于随机森林中随机选取的特征子集空间大小的取值，直观而言，值越小则基学习器之间的相关性越小(因为特征重合度越低)，所以方差越小</li>
<li>并非所有的模型都适合作为bagging的基学习器，一般高度非线性模型特别是树模型比较合适</li>
</ul>
</li>
<li>决策树模型往往方差较大(特别对于完全生长的决策树)</li>
<li>随机森林中的基分类器$g_t$就是决策树模型，最终以bagging的方式组合在一起(voting/averaging)</li>
</ul>
<a id="more"></a>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img src="/materials/img/RF/alg.png" alt="alg"><br><em>图片来源于“机器学习技法”课件</em></p>
<ul>
<li>由于每棵树可以独立训练，所以随机森林模型的训练过程是一个并行的过程，相对高效</li>
<li>随机森林模型继承了决策树的优点并克服了完全生长的决策树的缺点</li>
</ul>
<h3 id="特征随机性"><a href="#特征随机性" class="headerlink" title="特征随机性"></a>特征随机性</h3><p>随机森林的随机性除了使用bagging中的bootstrap方法采样训练出不同决策树以外，进一步地针对每棵决策树是随机的选择部分特征作为一个子特征集合来让该决策树进行学习，从而增强各个决策树的多样性</p>
<ul>
<li>一般随机抽取的特征子集是极小于原始特征空间的，这样训练模型的效率更高</li>
<li>特征扰动的方式增强了基分类器之间的多样性，从而使得在最终bagging集成时使用voting或者averaging方法时更易于减小模型本身的方差</li>
<li>可以看作是一个将原始特征空间随机投影到不同的低维特征空间上进行模型训练，对于每棵树中的分支而言类似于一个感知机分类的过程(原始输入样本按照某一个随机选取的特征空间映射后根据某个阈值进行分类)</li>
</ul>
<h2 id="out-of-bag-example"><a href="#out-of-bag-example" class="headerlink" title="out of bag example"></a>out of bag example</h2><p>与bagging的过程相关<br><img src="/materials/img/RF/oob.png" alt="oob"><br><em>图片来源于“机器学习技法”课件</em><br>由图可知，经过N次bootstrap采样后，某一样本不被选中的概率为$(1-\frac{1}{N})^N$，当$N$足够大时，取极限则该概率近似为$\frac{1}{e}$，换句话说最后大约有$\frac{1}{e}$的样本是没有被使用过的，于是我们可以利用这些样本进行模型的性能评估</p>
<p>对比设置验证集，out of bag(OOB)有以下特点</p>
<ul>
<li>对于每一个基分类器我们都有部分样本是没有被选中的，所以我们可以是用这些样本来衡量基分类器的表现，但是实际中一般不这么做，因为我们往往不是很关心基分类器的表现，而只在乎最终集成模型的表现</li>
<li>对于最终的集成模型而言我们也可以使用OOB的方法进行模型评估，不过需要注意不要误选了被用于训练的样本来进行验证，具体做法可以选取某些未使用特定样本的模型组合起来的模型来对该部分样本进行验证评分，如此选取多次取平均表现即可作为最终集成模型的一个评估</li>
<li>因此随机森林可以不需要额外设置验证集来进行验证，我们训练好模型后就可以根据OOB的得分来得到对最终模型的一个评估，也就不必像使用验证集那样再次使用所有训练集重新训练模型，实际应用中，OOB往往能准确的评价最终模型</li>
</ul>
<h2 id="feature-selection"><a href="#feature-selection" class="headerlink" title="feature selection"></a>feature selection</h2><h3 id="需要筛选的特征"><a href="#需要筛选的特征" class="headerlink" title="需要筛选的特征"></a>需要筛选的特征</h3><ul>
<li>冗余特征</li>
<li>不相关特征</li>
</ul>
<h3 id="特征筛选的优劣"><a href="#特征筛选的优劣" class="headerlink" title="特征筛选的优劣"></a>特征筛选的优劣</h3><ul>
<li>优点<ul>
<li>高效：减少了大量不必要的特征可以减少模型训练和预测的时间</li>
<li>泛化能力好：一般特征适当少的情况下，模型不易过拟合</li>
<li>可解释性：较少的特征便于结合业务场景进行解读</li>
</ul>
</li>
<li>缺点<ul>
<li>特征选择的计算量大，就其本身而言，是一个排列组合的数学问题，原始特征越多，可能性越多，直接穷举的话计算量很大</li>
<li>可能会过拟合：可能选取的特征恰好是使模型过拟合的特征</li>
<li>解释性不一定合理：承接上一条，若选取的是过拟合的特征，那么得出的结论本身是有问题的</li>
</ul>
</li>
</ul>
<h3 id="特征选择的方法"><a href="#特征选择的方法" class="headerlink" title="特征选择的方法"></a>特征选择的方法</h3><ul>
<li>线性模型<br>可以根据线性模型中的权重值大小来判定一个特征的值</li>
<li>非线性模型<br>本身非线性模型要想评价一个特征是否重要是比较困难的，因为各个特征之间可能存在未知的交叉关系，所以我们一般将问题简化为考虑各个特征各自的重要性，也就是对特征独自的重要性进行一个排序，取较重要的若干特征，一种对特征重要性进行打分的方式是</li>
</ul>
<p>random test<br>考虑到测试一个特征是否重要可以通过在原始样本中加入噪声数据进行扰动的方法，来对比前后模型表现的差异，如果差异较大，证明该特征是重要的，具体而言，有三种常用方法</p>
<ul>
<li>修改样本特征值的分布状况，比如修改为正态分布</li>
<li>使用bootstrap对原始特征值进行采样来进行扰动</li>
<li>最常用的一种方法是permutation test，即将原始特征值重新排列，举例来说比如在特征i下两个样本$x_{1,i},x_{2,i}$原始特征值分别为0,1,现在将两个样本的该特征值进行交换，然后重新投入训练并对模型进行打分，比较前后模型性能就可以判断该特征的重要性；<ul>
<li>针对permutation test的模型评估，可以不必修改训练样本的特征值，而是重新排列验证集的特征值，这样就避免了重新训练模型的时间消耗，而且效果是类似的</li>
</ul>
</li>
</ul>
<h2 id="random-forest-vs-decision-tree"><a href="#random-forest-vs-decision-tree" class="headerlink" title="random forest vs. decision tree"></a>random forest vs. decision tree</h2><p>相比较于单棵决策树而言，随机森林往往具有如下优势</p>
<ul>
<li>分类后的正反例之间的间隔较大，如图所示(对比第一(决策树)和第三幅(随机森林))<br><img src="/materials/img/RF/dt_rf.png" alt="dt_rf"><br><em>图片来源于“机器学习技法”课件</em></li>
<li>随机森林的分割边界更平滑</li>
<li>随机森林更加稳定，相较之下对于噪声点不太敏感，如图(左为决策树，右为随机森林)<br><img src="/materials/img/RF/stable.png" alt="stable"></li>
</ul>
<p><em>Notes:实际应用中随机森林的一个缺点是，在模型未达到一个较为稳定的状态时，模型对于随机性较为敏感，比如略微增减树的数目可能会影响模型的性能，这个时候比较建议适当增加树的数目</em></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> Random Forest </tag>
            
            <tag> 机器学习技法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模型比较小记]]></title>
      <url>/2017/08/02/model-cmp/</url>
      <content type="html"><![CDATA[<h2 id="RandomForest-vs-GBDT-vs-AdaBoost"><a href="#RandomForest-vs-GBDT-vs-AdaBoost" class="headerlink" title="RandomForest vs. GBDT vs. AdaBoost"></a>RandomForest vs. GBDT vs. AdaBoost</h2>]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人错题难题仓库]]></title>
      <url>/2017/07/30/error/</url>
      <content type="html"><![CDATA[<p><em>记录个人的一些疑难杂症</em></p>
<a id="more"></a>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><h3 id="计算排列组合数"><a href="#计算排列组合数" class="headerlink" title="计算排列组合数"></a>计算排列组合数</h3><p>根据相应的排列组合公式计算</p>
<ul>
<li>排列<br>$$A_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1)=\frac{n!}{(n-m)!}$$</li>
<li>组合<br>$$C_n^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}$$<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 计算阶乘数，即n! = n * (n-1) * ... * 2 * 1 </div><div class="line"> * <span class="doctag">@param</span> n </div><div class="line"> * <span class="doctag">@return</span> </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (n &gt; <span class="number">1</span>) ? n * factorial(n - <span class="number">1</span>) : <span class="number">1</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * 计算排列数，即A(n, m) = n!/(n-m)! </div><div class="line"> * <span class="doctag">@param</span> n </div><div class="line"> * <span class="doctag">@param</span> m </div><div class="line"> * <span class="doctag">@return</span> </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">arrangement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (n &gt;= m) ? factorial(n) / factorial(n - m) : <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * 计算组合数，即C(n, m) = n!/((n-m)! * m!) </div><div class="line"> * <span class="doctag">@param</span> n </div><div class="line"> * <span class="doctag">@param</span> m </div><div class="line"> * <span class="doctag">@return</span> </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (n &gt;= m) ? factorial(n) / factorial(n - m) / factorial(m) : <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://cgs1999.iteye.com/blog/2327664" target="_blank" rel="external">计算排列组合</a></p>
<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>来源于<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=2" target="_blank" rel="external">牛客网</a></p>
<blockquote>
<p>27、字符串的排列</p>
<ul>
<li>输入一个字符串,按字典序打印出该字符串中字符的所有排列。</li>
<li>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</li>
</ul>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>基本思路：递归的思想，将问题分解成小问题，假设我们现在写的一个函数的功能是返回传入的字符串的所有排列情况，而对于一个字符串而言，若固定第一个字符，则后续字符的所有排列情况就是当前以该字符为首的字符串的所有排列状况，而接下来一面是递归的求解余下字符串的排列状况，另一面则是将首字符与后续不等字符交换来重复上述求排列的过程，递归的终止条件是需要排列的子串只有一个元素时，则直接返回该情形下的字符串，而此题需要用<code>ArrayList</code>来收集字符串，所以还需要一个额外的<code>ArrayList</code>来传递并收集字符串,但是注意这种写法无法处理一种重复元素的情形，对于只是判断首元素与后续元素是否相同可以处理，但是对于不同字符多次出现的状况不能处理，比如<strong>aabb</strong>,此外一般要求是按顺序输出，所以综合这两点要求，将<code>ArrayList</code>改为<code>TreeSet</code>最为合适</p>
</blockquote>
<h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.TreeSet;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String s=<span class="string">"abc"</span>;</div><div class="line">		System.out.println(Permutation(s));</div><div class="line">		String s2=<span class="string">"aa"</span>;</div><div class="line">		System.out.println(Permutation(s2));</div><div class="line">		String s3=<span class="string">"aabb"</span>;</div><div class="line">		System.out.println(Permutation(s3));</div><div class="line">	&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    	ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    	<span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)&#123;</div><div class="line">    		<span class="keyword">return</span> list;</div><div class="line">    	&#125;</div><div class="line">        <span class="keyword">char</span>[] chr=str.toCharArray();</div><div class="line">        TreeSet&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">        permutation(chr,<span class="number">0</span>,set);</div><div class="line">        list.addAll(set);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] chr, <span class="keyword">int</span> index, TreeSet&lt;String&gt; set)</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(index&gt;chr.length-<span class="number">1</span>)&#123;</div><div class="line">    		<span class="keyword">return</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="comment">//当指针移到最后一个元素时即排列只有当前一种情形，为终止条件</span></div><div class="line">    	<span class="keyword">if</span>(index==chr.length-<span class="number">1</span>)&#123;</div><div class="line">    		set.add(String.valueOf(chr));</div><div class="line">    	&#125;</div><div class="line">    	permutation(chr,index+<span class="number">1</span>,set);</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i&lt;chr.length;i++)&#123;</div><div class="line">    		<span class="keyword">if</span>(chr[i]!=chr[index])&#123;</div><div class="line">    			exchange(chr,i,index);</div><div class="line">    			permutation(chr,index+<span class="number">1</span>,set);</div><div class="line">    			exchange(chr,i,index);</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">char</span>[] chr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span> temp=chr[i];</div><div class="line">		chr[i]=chr[j];</div><div class="line">		chr[j]=temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/zmazon/article/details/8351611" target="_blank" rel="external">排列</a></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>来源于<a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="external">leetcode</a></p>
<blockquote>
<p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.<br>For example,<br>If n = 4 and k = 2, a solution is:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>思路，仍然是想利用递归的方法来做，假设我们现有一个方法的功能是返回n个数中取k个值的组合，那么，若当前固定了第一个数剩下要做的就是从剩余n-1个数中取出k-1个数的组合即为当前首位的组合情形，所以同样的接下来要做两件事，其一递归的在后续子数序列中取得k-1个数的组合，另外就是更改首位值的的处理，与排列类似却不同的是，这里不是替换首位值，而是让指向首位的指针后移一位得到不同的值并再次计算以该值固定时从n个数中取k个数的组合的情况终止条件是当k为0时,递推关系可表示为C(n,k)=C(n-1,k-1)+C(n-1,k)，这里n对应的用下表的移动来进行变换</p>
</blockquote>
<h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combination</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(combine(<span class="number">5</span>,<span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; totalList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || k&lt;=<span class="number">0</span> || n&lt;k)&#123;</div><div class="line">            <span class="keyword">return</span> totalList;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Set&lt;List&lt;Integer&gt;&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        combine(n,k,<span class="number">1</span>,set,list);</div><div class="line">        totalList.addAll(set);</div><div class="line">        <span class="keyword">return</span> totalList;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, Set&lt;List&lt;Integer&gt;&gt; set, List&lt;Integer&gt; list)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</div><div class="line">            set.add(<span class="keyword">new</span> ArrayList(list));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        list.add(index);</div><div class="line">        combine(n,k-<span class="number">1</span>,index+<span class="number">1</span>,set,list);</div><div class="line">        <span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</div><div class="line">            list.remove(list.size()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;n-k+<span class="number">1</span>;i++)&#123;</div><div class="line">            combine(n,k,i+<span class="number">1</span>,set,list);</div><div class="line">        &#125;       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Notes:似乎与回溯法、DFS有关</em></p>
<p>参考资料</p>
<ul>
<li><a href="http://shukuiyan.iteye.com/blog/1095637" target="_blank" rel="external">http://shukuiyan.iteye.com/blog/1095637</a></li>
<li><a href="http://www.cnblogs.com/lifegoesonitself/p/3225803.html" target="_blank" rel="external">http://www.cnblogs.com/lifegoesonitself/p/3225803.html</a></li>
</ul>
<h2 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h2><p>来源：<a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="external">牛客</a></p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>从1到n的整数中1出现的次数，例如：求出1~13的整数中1出现的次数，其中包含1的数字有1、10、11、12、13因此共出现6次（11表示两次）</p>
</blockquote>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>阅读了一些书籍和博客的解析，感觉比较繁琐，反而是<a href="https://leetcode.com/discuss/44281/4-lines-o-log-n-c-java-python" target="_blank" rel="external">leetcode的高票答案</a>简洁明了的解释了，现转述如下:</p>
<ul>
<li>本题的暴力解法是对每一个数逐一遍历数位统计1的个数，然后又注意统计1~n的每个数的1的个数并最后加和</li>
<li>高效率解法<blockquote>
<p>第i位为1的可能情形由第i位前后的数值范围共同决定</p>
</blockquote>
</li>
</ul>
<p>首先这道题若是从数值大小的方向找规律的话比较繁琐，虽然也有方法，但个人觉得不是很好用，比较好的一种方法是通过数位的角度来看数，因为本身这道题就是统计所有1出现的数目，像11这种数就表示1出现了两次，若执迷于按照数值大小统计很容易陷入数值范围与数位范围的混沌；下面就通过逐个数位的统计来说明，首先我们定义几个变量</p>
<ul>
<li>原始传入数据n</li>
<li>m用来统计当前的数位，从每次以10倍倍增，也就是说$m=1,10,100,…$</li>
<li>当前数位划分的高位数据a=n/m,以及对应的剩余数据b=n%m</li>
</ul>
<p>接下来对每一数位i，我们将该数位的可能取值范围0~9划分为3种情况并分a,b两部分统计该位为1时的a,b变化范围即对应的1的数目</p>
<ul>
<li>i&gt;1时，因为此时i可以取1，所以a,b都能在自己的取值范围任意取值，举个例子，比如12345，假设我们现在统计百位上为1的情形即m=100</li>
<li>对应的a=123,b=45;假设置百位为1则简化表示为a1b，而对于a而言它的取值范围是0~12共有13种可能，而由于我们此刻是在统计百位为1的情形，所以一共就有13<em>100种可能，细化下来分别为100~199,1100~1199,2100~2199,…,12100~12199,用一个一般性的式子表示就是$$(a/10+1)</em>m$$</li>
<li>i=1时，当a取最大值时,对于b而言，有一部分值是取不到的，仍然举个例子比如12145，仍然统计百位，于是a=121,b=45,对于而对于a而言它的取值范围是0~12共有13种可能，但是这里需要注意当a=12时会受到b的允许取值的影响，具体说来对于121b而言，此时b的取值范围为0~45也就是12100~12145，对于12146~12199就超出了原始值n的范围了，而对于a其他取值依然是能够满足的，细化为100~199,1100~1199,2100~2199,…,11100~11199,12100~12145,用一个式子表示就是$$(a/10)*m+b+1$$;</li>
<li>i=0时，这个时候a就不能取最大值了，其余情形都可以取得，比如12045，a=120,b=45,此时a的取值范围是0~11，而对于a的任一取值，b的取值不受限制，细化为100~199,1100~1199,2100~2199,…,11100~11199，用式子表示就是$$(a/10)*m$$</li>
<li>最后只需要逐位统计该数位为1时的取值范围情况就能保证每个数位的1不被漏掉，因为我们是按照数位独立统计1的数目，所以也不会出现重复的情形，比如对于111而言，我们在统计个位时，是不考虑前面数位是否为1的，只考虑前面数位的取值范围，因为只要个位为1我们才会对前面的有效值进行1次记录，比如说111我们分别在个位、十位、百位都会对这个数进行统计，但是每次统计只是记录该数位的情况，所以对于这个数而言虽然是重复出现了，但是对于1的统计而言没有重复统计；</li>
</ul>
<h3 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=n;m*=<span class="number">10</span>)&#123;</div><div class="line">        <span class="keyword">int</span> a=n/m,b=n%m;</div><div class="line">        <span class="keyword">int</span> i=a%<span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</div><div class="line">            sum+=(a/<span class="number">10</span>*m);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</div><div class="line">            sum+=(a/<span class="number">10</span>*m+b+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            sum+=((a/<span class="number">10</span>+<span class="number">1</span>)*m);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> Note </tag>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java_concepts]]></title>
      <url>/2017/07/29/java-concepts/</url>
      <content type="html"><![CDATA[<p><em>记录一些容易出现错误、混淆的点</em></p>
<a id="more"></a>
<h2 id="Java函数间的参数传递问题"><a href="#Java函数间的参数传递问题" class="headerlink" title="Java函数间的参数传递问题"></a>Java函数间的参数传递问题</h2><p>踩过的坑<br>剑指offer的一道题</p>
<blockquote>
<p>二叉搜索树与双向链表:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<ul>
<li>调用部分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">Convert2</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	TreeNode[] curLast=<span class="keyword">new</span> TreeNode[<span class="number">1</span>];</div><div class="line">	lastOrder(pRootOfTree,curLast);</div><div class="line">	<span class="comment">//由于是当前最后一位，所以需要向左寻找到首位</span></div><div class="line">	TreeNode head=curLast[<span class="number">0</span>];</div><div class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span> &amp;&amp; head.left!=<span class="keyword">null</span>)&#123;</div><div class="line">		head=head.left;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>错误代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastOrder</span><span class="params">(TreeNode pRootOfTree, TreeNode curLast)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	TreeNode cur=pRootOfTree;</div><div class="line">	<span class="comment">//获得左子树的最后一位(最大值)</span></div><div class="line">	<span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</div><div class="line">		lastOrder(cur.left,curLast);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//修改当前节点的左指针</span></div><div class="line">	cur.left=curLast;</div><div class="line">	<span class="keyword">if</span>(curLast!=<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="comment">//修改左子树最后一位的右指针</span></div><div class="line">		curLast.right=cur;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//更新当前最后一位指针</span></div><div class="line">	curLast=cur;	<span class="comment">//无效，因为相当于在递归函数中创建的了一个局部变量指向了curLast，</span></div><div class="line">					<span class="comment">//所以这里修改也只是将局部变量的引用替换为一个新的地址，而原始的值并未改变，所以返回上一层并没有用</span></div><div class="line">					<span class="comment">//一种替代的方法是使用一个大小为1的数组来传参</span></div><div class="line">	<span class="comment">//继续处理右子树</span></div><div class="line">	<span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</div><div class="line">		lastOrder(cur.right,curLast);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改方案</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastOrder</span><span class="params">(TreeNode pRootOfTree, TreeNode[] curLast)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	TreeNode cur=pRootOfTree;</div><div class="line">	<span class="comment">//获得左子树的最后一位(最大值)</span></div><div class="line">	<span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</div><div class="line">		lastOrder(cur.left,curLast);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//修改当前节点的左指针</span></div><div class="line">	cur.left=curLast[<span class="number">0</span>];</div><div class="line">	<span class="keyword">if</span>(curLast[<span class="number">0</span>]!=<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="comment">//修改左子树最后一位的右指针</span></div><div class="line">		curLast[<span class="number">0</span>].right=cur;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//更新当前最后一位指针</span></div><div class="line">	curLast[<span class="number">0</span>]=cur;	</div><div class="line">	<span class="comment">//继续处理右子树</span></div><div class="line">	<span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</div><div class="line">		lastOrder(cur.right,curLast);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_4b622a8e0100c1bo.html" target="_blank" rel="external">Java参数传递(超经典)</a></li>
<li><a href="https://zhihu.com/question/31203609/answer/50992895" target="_blank" rel="external">知乎</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Note </tag>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[懒死骆驼的代码小黑本]]></title>
      <url>/2017/07/27/tricks/</url>
      <content type="html"><![CDATA[<p><em>记录一些容易忽略问题以及奇技淫巧</em><br><a id="more"></a></p>
<h2 id="浮点数类型的精度问题"><a href="#浮点数类型的精度问题" class="headerlink" title="浮点数类型的精度问题"></a>浮点数类型的精度问题</h2><ul>
<li>精度问题及控制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> result = <span class="number">1.0</span> - <span class="number">0.9</span>;<span class="comment">//坏代码  </span></div><div class="line"><span class="comment">// 方法一  </span></div><div class="line"><span class="keyword">double</span> result = <span class="number">1.0</span> - <span class="number">0.9</span>;  </div><div class="line">NumberFormat nf = NumberFormat.getInstance();<span class="comment">// 根据自己的需求格式化  </span></div><div class="line">String resultStr = nf.format(result);  </div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">int</span> resultInt = <span class="number">10</span> - <span class="number">9</span>;  </div><div class="line"><span class="keyword">double</span> result = (<span class="keyword">double</span>) resultInt / <span class="number">100</span>;<span class="comment">//最终时候自己控制小数点 </span></div><div class="line"><span class="comment">//方法三</span></div><div class="line">String result = <span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>)) .toString();</div></pre></td></tr></table></figure>
<ul>
<li>浮点类型的比较，不可直接用<code>==</code>来判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> d1 = <span class="number">0.1</span>, d2 = <span class="number">0.1</span>;  </div><div class="line"><span class="keyword">if</span> (d1 == d2) &#123;&#125;<span class="comment">// 坏代码  </span></div><div class="line"><span class="keyword">if</span> (Double.compare(d1, d2) == <span class="number">0</span>) &#123;&#125;<span class="comment">// 好代码  </span></div><div class="line"><span class="keyword">if</span> (Double.doubleToLongBits(d1) == Double.doubleToLongBits(d2)) &#123;&#125;<span class="comment">// 好代码  </span></div><div class="line"><span class="keyword">if</span> (Double.valueOf(d1).equals(d2)) &#123;&#125;<span class="comment">// 好代码，1.5以上</span></div></pre></td></tr></table></figure>
<p>此外，如果是考虑在一定精度范围内，一般也可以判断两数差值绝对值是否在某一范围内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">bool <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>((num1-num2&gt;-<span class="number">0.0000001</span>) &amp;&amp; (num1-num2&lt;<span class="number">0.0000001</span>))&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Notes:普通的计算最好使用BigDecimal类，这个类可以非常精确的计算出结果，而且你可以完全控制精度，不用额外其他操作，而且与基本类型转换都非常方便。</em></p>
<p>参考</p>
<ul>
<li><a href="http://161650095-163-com.iteye.com/blog/1521130" target="_blank" rel="external">double类型的精度问题</a></li>
<li>《剑指offer》P151</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Note </tag>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈与队列小记]]></title>
      <url>/2017/07/22/stack-queue/</url>
      <content type="html"><![CDATA[<p>主要记录一些关于栈、队列的变体和特殊操作的算法题<br><a id="more"></a></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>Queue</p>
<blockquote>
<p>队列允许重复元素，因为队列的基本特征是保持元素的插入顺序，重复的元素在队列中被认为是不同的元素，任意两个元素的顺序是不一样的。</p>
</blockquote>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>包</th>
<th>实现</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Deque</td>
<td>java.util</td>
<td>LinkedList</td>
<td>double ended queue，允许两端增删元素</td>
</tr>
<tr>
<td>BlockingDeque</td>
<td>java.util.concurrent</td>
<td>-</td>
<td>同BlockingQueue</td>
</tr>
<tr>
<td>BlockingQueue</td>
<td>java.util.concurrent</td>
<td>-</td>
<td>BlockingQueue只有在队列不空时才查找元素，只有在队列有空余空间时才插入元素、此外还支持延时插入删除操作</td>
</tr>
<tr>
<td>TransferQueue</td>
<td>java.util.concurrent</td>
<td>-</td>
<td>特殊的BlockingQueue，会等候其他的线程在队列中查询元素</td>
</tr>
</tbody>
</table>
<p><a href="http://www.codejava.net/java-core/collections/java-queue-collection-tutorial-and-examples" target="_blank" rel="external">参考</a></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul>
<li>继承了Collection的核心操作比如<code>add(), contains(), remove(), clear(), isEmpty()</code></li>
<li>对于队列而言，在头部的操作更快比如<code>offer()</code>和<code>remove()</code>而对中间元素的操作就相对较慢比如：<code>contains(e)</code>和<code>remove(e)</code></li>
<li>单元素操作: add(e),contains(e), iterator(), clear(), isEmpty(), size() 和 toArray().</li>
<li>批量操作: addAll(), containsAll(), removeAll() 和 retainAll().</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>尾部添加元素</li>
<li>头部删除元素</li>
<li>从头部取元素（但不删除）</li>
</ul>
<p>按操作失败时输出划分<br><img src="/materials/img/queue_stack/queue_oper.png" alt="queue operation"></p>
<ul>
<li>其中插入操作，针对限制容量的一些实现会有所不同，包括ArrayBlockingQueue, LinkedBlockingQueue 和 LinkedBlockingDeque classes</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>常规<ul>
<li>LinkedList:List+Deque，适用于需要快速增删两端的元素，以及通过下标访问元素</li>
<li>PriorityQueue::通过自然顺序或者根据Comparator的规则对元素排序，适用于需要对元素自然排序以及快速在尾端插入元素或在头部删除元素</li>
<li>ArrayDeque:Deque的简单实现，当只需要双端队列的特性而不需要列表的特性时</li>
</ul>
</li>
</ul>
<p><em>Notes:</em><br>对上述实现，如果想使用同步，则使用如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;&gt;());</div></pre></td></tr></table></figure></p>
<ul>
<li>多线程<ul>
<li>ArrayBlockingQueue:用数组实现的blocking queue,容量有限的简单的blocking queue实现</li>
<li>PriorityBlockingQueue:PriorityQueue+BlockingQueue</li>
<li>DelayQueue:基于时间调度的blocking queue,需要实现Delayed接口，意味着只有当一个元素的delay到期了才能被从队列头部删除</li>
</ul>
</li>
</ul>
<h2 id="栈与队列的转换"><a href="#栈与队列的转换" class="headerlink" title="栈与队列的转换"></a>栈与队列的转换</h2><h3 id="用两个栈实现队列的基本操作"><a href="#用两个栈实现队列的基本操作" class="headerlink" title="用两个栈实现队列的基本操作"></a>用两个栈实现队列的基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>&#123;</div><div class="line">	Stack&lt;Integer&gt; in=<span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	Stack&lt;Integer&gt; out=<span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</div><div class="line">		in.push(e);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(!out.isEmpty())&#123;</div><div class="line">			<span class="keyword">return</span> out.pop();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">if</span>(in.isEmpty())&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">while</span>(!in.isEmpty())&#123;</div><div class="line">				out.push(in.pop());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> out.pop();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> in.isEmpty()&amp;&amp;out.isEmpty();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>附：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">练习链接</a></p>
<h2 id="特殊的栈"><a href="#特殊的栈" class="headerlink" title="特殊的栈"></a>特殊的栈</h2><h3 id="O-1-时间取得最大-最小值的栈"><a href="#O-1-时间取得最大-最小值的栈" class="headerlink" title="O(1)时间取得最大/最小值的栈"></a>O(1)时间取得最大/最小值的栈</h3><p>以最小值为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</div><div class="line">	Stack&lt;Integer&gt; stack1=<span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//实现栈的常规功能</span></div><div class="line">	Stack&lt;Integer&gt; stack2=<span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//辅助栈，栈顶保存当前最小元素</span></div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        stack1.push(node);</div><div class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;        	</div><div class="line">        	stack2.push((min()&lt;=node?min():node));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">        	stack2.push(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1.pop();</div><div class="line">        stack2.pop();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stack1.peek();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>附：<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="external">练习链接</a></p>
<h4 id="拓展应用"><a href="#拓展应用" class="headerlink" title="拓展应用"></a>拓展应用</h4><p>股票的最大利润<br>附：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description" target="_blank" rel="external">练习链接</a><br>一种解法是，先用一个能快速获取最大值能力的栈倒着获取一遍所有的当前元素的最大元素，然后顺序遍历，不断的加入元素到一个TreeSet并从栈中弹出元素，这样一来，set里保留的就是前面部分的最小值，而stack保留剩余部分的最大值，所以，两相作差，我们可以从中取出最大的差值即最大利润，当然针对这个问题这个方法并不好，时间上对于大型数组会超时，而且还用了额外空间；比较好的方法应该使用动态规划</p>
<ul>
<li><p>使用特殊栈与TreeSet的解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">import</span> java.util.TreeSet;</div><div class="line"></div><div class="line"><span class="comment">/**剑指offer第二版面试题63：股票的最大利润*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxStock</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] prices=&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</div><div class="line">		System.out.println(maxProfit(prices));</div><div class="line">		<span class="keyword">int</span>[] prices2=&#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">14</span>&#125;;</div><div class="line">		System.out.println(maxProfit(prices2));</div><div class="line">		<span class="keyword">int</span>[] prices3=&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</div><div class="line">		System.out.println(maxProfit(prices3));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//基本思路：用两个特殊的数据结构，先用一个能快速得到最大值的栈逆序遍历数据得到各序列当前最大值，然后逐个遍历数组，</span></div><div class="line">	<span class="comment">//左侧添加到一个TreeSet中保留当前最小值，右侧则不停的出栈，表示剩余的最大值，两项做差表示当前的利润，用一个max变量比较保存最大利润</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    	<span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)&#123;</div><div class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="comment">//use stack with max to reverse collect the current max prices </span></div><div class="line">        MaxStack stack=<span class="keyword">new</span> MaxStack();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=prices.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</div><div class="line">        	stack.push(prices[i]);</div><div class="line">        &#125;</div><div class="line">        TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</div><div class="line">        	set.add(prices[i]);</div><div class="line">        	<span class="keyword">int</span> maxLeft=stack.max();</div><div class="line">        	stack.pop();</div><div class="line">        	<span class="keyword">int</span> diff=maxLeft-set.first();</div><div class="line">        	maxProfit=maxProfit&gt;diff?maxProfit:diff;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span></span>&#123;</div><div class="line">	Stack&lt;Integer&gt; stack1=<span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//实现栈的常规功能</span></div><div class="line">	Stack&lt;Integer&gt; stack2=<span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//辅助栈，栈顶保存当前最小元素</span></div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        stack1.push(node);</div><div class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;        	</div><div class="line">        	stack2.push((max()&gt;=node?max():node));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">        	stack2.push(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        stack1.pop();</div><div class="line">        stack2.pop();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stack1.peek();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stack2.peek();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用动态规划的解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(prices.length&lt;=<span class="number">0</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> soFarMin=prices[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> maxDiff=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(prices[i]&gt;soFarMin)&#123;</div><div class="line">			maxDiff=maxDiff&gt;(prices[i]-soFarMin)?maxDiff:(prices[i]-soFarMin);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			soFarMin=prices[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> maxDiff;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="特殊的队列"><a href="#特殊的队列" class="headerlink" title="特殊的队列"></a>特殊的队列</h2>]]></content>
      
        
        <tags>
            
            <tag> Note </tag>
            
            <tag> algorithm </tag>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[方差、偏差、噪声和期望泛化误差小记]]></title>
      <url>/2017/07/20/bias-variance/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h2 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h2><p>一般我们希望最小化的模型的期望泛化误差可以分解为偏差、方差、噪声的加和，比较宽泛的表示为$$期望泛化误差=偏差+方差+噪声$$，引用《数据挖掘导论》上的一幅比较形象的类比为迫击炮的图来看看<br><a id="more"></a><br><img src="/materials/img/bias_variance/gunpowder.png" alt="gunpowder"></p>
<table>
<thead>
<tr>
<th>名词</th>
<th>定义</th>
<th>理解</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏差</td>
<td>算法的期望预测与真实结果的偏离程度</td>
<td>学习算法本身的拟合能力</td>
<td>炮弹落地点的平均位置距离到目标点的距离，受到迫击炮的角度影响</td>
</tr>
<tr>
<td>方差</td>
<td>同样大小的训练集的变动所导致的学习性能的变化</td>
<td>数据扰动所造成的影响</td>
<td>任意一次炮击落地点与炮弹落地点的平均位置之间的差距，受到每次对迫击炮的施加的力度影响</td>
</tr>
<tr>
<td>噪声</td>
<td>（给定）样本数据的标记与真实结果的差别（自身的错误）</td>
<td>学习问题本身的难度（期望泛化误差的下界）</td>
<td>目标本身的不稳定性，比如在一定范围内活动的目标</td>
</tr>
</tbody>
</table>
<p>再附一张经典的打靶图<br><img src="/materials/img/bias_variance/bias-and-variance.jpg" alt="bias-and-variance"></p>
<blockquote>
<p>一般而言，噪声不可避免，属于数据集以及所需解决问题本身的限制；所以我们只能从偏差和方差的角度来尽可能的减小期望泛化误差的值，而偏差和方差本身存在冲突，表现为：给定一个学习任务，假定我们能控制学习算法的训练程度，则在训练不足时，学习器的拟和能力不强，<strong>训练数据的扰动不足以使学习器产生显著变化，此时偏差主导了泛化错误率</strong>；而随着训练程度的加深，学习器的拟合能力也逐渐加强，训练数据发生的扰动渐渐能被学习器学到，方差逐渐主导了泛化错误率，在训练程度充足后，学习器的拟合能力已经非常强了，<strong>训练数据发生的轻微扰动都会导致学习器发生显著变化，若训练数据自身的、非全局的特性被学习器学到，则将发生过拟合</strong></p>
</blockquote>
<h2 id="训练过程的方差-偏差矛盾"><a href="#训练过程的方差-偏差矛盾" class="headerlink" title="训练过程的方差-偏差矛盾"></a>训练过程的方差-偏差矛盾</h2><p><img src="/materials/img/bias_variance/curve.png" alt="curve"><br>对此理解bagging、boosting;对于bagging而言，通过不同训练子集来训练基分类器，这样首先就有较大的数据扰动，然后由于针对每一个基分类器都是“尽力地”去拟合各子训练集的（比如随机森林不剪枝生成完整的决策树的做法），所以对每一个子训练集而言，对应学得的基分类器拟合程度相当高，甚至可以认为对子训练集都是过拟合了的，所以针对bagging而言它的起点就是一个偏差小、方差大的集成，而他接下来的目的就是为了降低方差，减小由数据扰动带来的影响；而反观boosting，他的每一个基分类器是比较简单的弱分类器，而数据集其实一直都是整个样本全集，只是每一轮迭代修改了部分样本的权重（使整体的样本分布变化），所以初始的基分类器的拟合效果自然不好，也就是起始的时候偏差大、方差相对小，而接下来每一个学习器都是针对前一个学习器的错误进行修正，也就是修正预测结果与真实结果的偏离，所以目的是在减小偏差；</p>
<h2 id="交叉验证与偏差、方差"><a href="#交叉验证与偏差、方差" class="headerlink" title="交叉验证与偏差、方差"></a>交叉验证与偏差、方差</h2><p>对应到交叉验证上来分析的话，首先我们知道每组用于训练的样本大小为$N\frac{k-1}{k}$,而对应的每组测试集大小为$\frac{N}{k}$如果我们选的k值比较小，比如极端情况下令$k=2$，此时共进行两次测试，每次都是取一半样本进行训练模型，一半样本用来测试，这样一来的话可以看到用于训练的样本数相对就比较少了，可能造成的结果是模型并不能学到所有样本的真实规律，也就是产生了欠拟和的问题，此时偏差应该主导了主要的期望泛化误差；另一面假设另一个极端我们令$k=N$，此时每一次验证的训练样本数为$\frac{N-1}{N}$，而测试集大小为$\frac{1}{N}$,此时用来训练的样本是足够了，而且基本接近于用所有样本来训练，所以模型的拟合效果应该是过犹不及的，所以此时偏差应该是比较小的，但是可能每一组训练出来的模型反而学到了样本中的一些噪声数据，也就是过拟合了该组样本，而测试集却又太少，所以测试集上的结果可能不够稳定准确，因此方差就比较大了；但是回过头来看我觉得cv里的偏差、方差和k值的选择似乎不能单纯的说大、小导致两者的就绝对的好或者差，譬如知乎那里<a href="https://zhihu.com/question/27068705/answer/99541217" target="_blank" rel="external">大象的解答</a>首先把问题分开来还讲的挺好的，包括cv里的那个式子，但是在cv部分的偏差和方差我感觉还是有点疑惑</p>
<p>再次阅读大象的解答，似乎有点收获，主要观点在于cv中的偏差和方差与bias-variance分解中的偏差方差是不同的两种概念；<br>首先强调下两者的差异：</p>
<ul>
<li>bias-variance分解主要针对预测值与真实值之间的误差，EPE（期望预测误差）是由随机误差，预测模型与真实模型的偏差以及预测模型本身的变异三部分组成的。(而这部分是不涉及模型选择的，因为是已经得到模型以后来计算模型与真实结果之间的差异的)</li>
<li>Cross Validation是为了得到预测误差的估计值，bias是CV统计量的期望与预测误差的距离，variance是CV统计量自己的方差。</li>
</ul>
<p><em>Notes:对比一下上述叙述可以发现两个概念里的偏差和方差针对的对象是完全不一样的，而且目的也不一样</em></p>
<ul>
<li>cv的作用是用来进行模型选择的，因为我们不能直接拿测试集来选择模型，所以需要用其它的方法来作为测试误差的估计值，用来做这种式的方法有很多，比如基于Optimism的Cp, AIC,基于贝叶斯方法的BIC，还有Vapnik-Chervonenkis维度, 验证误差等，验证误差是其中的一种方法，因为受到数据量的限制，所以我们采用cv来进行预估</li>
<li>因此我们使用Cross Validation的目的是获得预测误差的无偏估计量CV，从而可以用来选择一个最优的\theta^*,使得CV最小,而k折交叉验证中的k值又是与cv中的偏差、方差相关联的，一般而言，当K较大时，m较小，模型建立在较大的N-m上，因此CV与Testing Error的差距较小，所以说CV对Testing Error估计的Bias较小。同时每个Subsets重合的部分较大，相关性较高，如果在大量不同样本中进行模拟，CV统计量本身的变异较大，所以说Variance高。反之亦然。</li>
<li>用岭回归模型举个例子，如果K=2，K=10，K=N最终都选择了相同的参数$\lambda$，那么训练出来的模型也都一样，那么模型的实际testing error，bias，variance也全都一样了。然而在模型选择时，不同K所对应的CV统计量的期望和方差是存在变化关系的。</li>
</ul>
<p>参考</p>
<ul>
<li>周志华《机器学习》2.2以及2.5</li>
<li>《数据挖掘导论》5.6.3</li>
<li><a href="https://zhihu.com/question/27068705/answer/99541217" target="_blank" rel="external">知乎问答</a></li>
<li>图片来自上述图书或者网络</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> 方差 </tag>
            
            <tag> 偏差 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(七) —— 支持向量机]]></title>
      <url>/2017/07/12/svm/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>支持向量机是一种二类分类模型</li>
<li>基本模型：定义在特征空间上的间隔最大的线性分类器</li>
<li>+核函数$\to$ 非线性分类器<!-- more -->
<h3 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h3>间隔最大化：最大化实例点到分类超平面的最小距离，或者说最大化数据集到分离超平面的距离</li>
<li>对偶问题：求解凸二次规划问题</li>
<li>等价损失函数：正则化的合页(hinge)损失函数的最小化问题</li>
</ul>
<h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><p>求解凸二次规划的最优化算法：常用SMO(序列最小最优化问题)</p>
<h3 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h3><table>
<thead>
<tr>
<th>训练数据</th>
<th>通过</th>
<th>学习</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性可分</td>
<td>软间隔最大化</td>
<td>线性可分支持向量机(硬间隔支持向量机)</td>
</tr>
<tr>
<td>近似线性可分</td>
<td>软间隔最大化</td>
<td>线性支持向量机(软间隔支持向量机)</td>
</tr>
<tr>
<td>线性不可分</td>
<td>软间隔最大化+核技巧</td>
<td>非线性支持向量机</td>
</tr>
</tbody>
</table>
<h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>输入都由输入空间转换到特征空间，支持向量机的学习是在特征空间进行的，而学习的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类</li>
<li>当训练数据集线性可分时，感知机利用误分类最小的策略，求得无穷多的分离超平面；而线性可分支持向量机利用间隔最大化求最优分离超平面，此时，解是唯一的<blockquote>
<p>定义：给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为:$$w^*\cdot x+b^*=0$$，以及相应的分类决策函数$$f(x)=sign(w^*\cdot x+b^*)$$，称为线性可分支持向量机。</p>
</blockquote>
</li>
</ul>
<h3 id="函数间隔-amp-几何间隔"><a href="#函数间隔-amp-几何间隔" class="headerlink" title="函数间隔&amp;几何间隔"></a>函数间隔&amp;几何间隔</h3><p>假设给定一个特征空间上的训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace, x_i\in R^n,y_i \in \lbrace -1,+1 \rbrace$</p>
<ul>
<li>函数间隔<ul>
<li>超平面$(w,b)$关于训练数据集$T$的<strong>样本点$(x_i,y_i)$</strong>的函数间隔：$$\widehat{\gamma_i}=y_i(w\cdot x_i+b)$$</li>
<li>表示分类预测的：<ul>
<li>确信程度$\to |w\cdot x+b|$:一个点距离分离超平面的远近</li>
<li>正确性$\to w\cdot x+b$的符号与类标记$y$的符号是否一致</li>
</ul>
</li>
<li>超平面$(w,b)$关于<strong>训练数据集$T$</strong>的函数间隔为：$$\widehat{\gamma}=min_{i=1,…,N}\widehat{\gamma_i}$$,但是选择分离超平面时，仅有函数间隔是不够的，因为$w,b$可以成比例变化使得函数间隔为无穷大而不具备可比性，所以需要对$w$加约束，如规范化，令$||w||=1$，于是得到几何间隔</li>
</ul>
</li>
<li>几何间隔<ul>
<li>超平面$(w,b)$关于训练数据集$T$的<strong>样本点$(x_i,y_i)$</strong>的几何间隔：$$\gamma_i=y_i(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||})$$</li>
<li>超平面$(w,b)$关于<strong>训练数据集$T$</strong>的几何间隔为：$$\gamma=min_{i=1,…,N}\gamma_i$$，超平面$(w,b)$关于样本点$(x_i,y_i)$的几何间隔一般是实例点到超平面的带符号的距离。</li>
</ul>
</li>
</ul>
<h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><ul>
<li>基本想法：求解能够正确划分训练数据集并且几何间隔最大的分离超平面，即以充分大的确信度对训练数据进行分类</li>
</ul>
<p><em>Notes:原始问题：求一个几何间隔最大的分离超平面。</em></p>
<ul>
<li>数学表达为一个约束最优化问题<br>$$max_{w,b}  \gamma$$<br>$$ s.t. 　y_i(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||}) \geq \gamma 　i=1,2,…,N$$，其中$\gamma$即表示超平面关于数据集的几何间隔，是超平面关于数据集中的样本点的几何间隔$\gamma_i$的最小值，因此有上述约束条件，而我们的目的是得到一个使该值最大的超平面</li>
<li>由几何间隔与函数间隔之间的转化关系$\gamma_i = \frac{\widehat{\gamma_i}}{||w||},  \gamma = \frac{\widehat{\gamma}}{||w||}$，上述问题可以进一步转化为<br>$$max_{w,b}  \frac{\widehat{\gamma_i}}{||w||}$$<br>$$ s.t. 　y_i(w\cdot x_i+b) \geq \gamma 　i=1,2,…,N$$</li>
<li>由于函数间隔$\widehat{\gamma}$并不影响最优化问题的解（将$w,b$按比例改变，函数间隔也随之等比变化），取$\widehat{\gamma}=1$,此外由于在该最优化问题中，最大化$\frac{1}{||w||}$和最小化$\frac{1}{2}||w||^2$等价，所以上述问题进一步转化为<br>$$min_{w,b}  \frac{1}{2}{||w||^2}$$<br>$$ s.t. 　y_i(w\cdot x_i+b) - 1\geq 0 　i=1,2,…,N$$</li>
</ul>
<p><em>Notes:</em></p>
<ul>
<li>原始问题到这里就结束了，直接使用凸二次规划求解出$w,b$的值就可以得到分离超平面和最终的决策函数，这就是<strong>最大间隔法</strong></li>
<li>书中例题7.1的凸二次优化的Python解法，参照<a href="https://wizardforcel.gitbooks.io/python-quant-uqer/content/192.html" target="_blank" rel="external">凸优化 · 如何在 Python 中利用 CVXOPT 求解二次规划问题</a>,针对该题可见<a href="https://github.com/LancelotHolmes/MLinAction/blob/master/Convex%20Quadratic.ipynb" target="_blank" rel="external">我的github</a><br><img src="/materials/img/svm/convex.jpg" alt="convex"></li>
</ul>
<h3 id="算法-最大间隔法-线性可分支持向量机学习算法"><a href="#算法-最大间隔法-线性可分支持向量机学习算法" class="headerlink" title="算法-最大间隔法(线性可分支持向量机学习算法)"></a>算法-最大间隔法(线性可分支持向量机学习算法)</h3><blockquote>
<p>输入：线性可分训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace, x_i\in R^n,y_i \in \lbrace -1,+1 \rbrace, i=1,2,…,N$<br>输出：最大间隔分离超平面和分类决策函数</p>
<ul>
<li>(1)构造并求解约束最优化问题<br>$$min_{w,b}  \frac{1}{2}{||w||^2}$$<br>$$ s.t. 　y_i(w\cdot x_i+b) - 1\geq 0 　i=1,2,…,N$$，求得最优解$w^*,b^*$</li>
<li>(2)由此可得分离超平面$$w^*\cdot x+b^*=0$$,以及对应的分类决策函数$$f(x)=sign(w^*\cdot x+b^*)$$</li>
</ul>
</blockquote>
<p><em>Notes:线性可分训练数据集的最大间隔分离超平面是存在且唯一的</em></p>
<h3 id="支持向量与间隔边界"><a href="#支持向量与间隔边界" class="headerlink" title="支持向量与间隔边界"></a>支持向量与间隔边界</h3><p>在线性可分情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量(使$y_i(w\cdot x_i+b)-1=0$成立的点)<br><img src="/materials/img/svm/sv.jpg" alt="sv"><br>如图所示，超平面$H_1,H_2$上的点即为支持向量，$H_1$与$H_2$之间的距离即为间隔，依赖于分离超平面的法向量$w=\frac{2}{||w||}$，$H_1,H_2$称为间隔边界；<br><em>Notes:在决定分离超平面时只有支持向量起作用，其他实例点并不起作用</em></p>
<h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>承接前面的原始问题，引入<strong>拉格朗日对偶性</strong></p>
<ul>
<li>对偶问题往往更容易求解</li>
<li>自然引入核函数$\to$推广到非线性分类问题</li>
</ul>
<h4 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h4><ul>
<li>对原问题引入拉格朗日乘子$\alpha_i \geq 0$,构建拉格朗日函数，得到<br>$$L(w,b,\alpha)=\frac{1}{2}{||w||^2} - \sum_{i=1}^{N}\alpha_iy_i(w\cdot x_i+b)+ \sum_{i=1}^{N}\alpha_i$$<br><em>Notes:个人理解是将原始的约束条件中的不等式、等式以某种形式添加到目标函数中从而转化为新的目标函数求解</em></li>
<li>这样原始问题就是$$min_{w,b} max_{\alpha_i \geq 0}L(w, b, \alpha)$$,根据拉格朗日对偶性可以转换为广义的拉格朗日的极大极小问题$$max_{\alpha_i \geq 0} min_{w,b}L(w, b, \alpha)$$</li>
<li>求解$min_{w,b}L(w, b, \alpha)$,即分别对$w,b$求导并令其值为0，得到<br>$$w = \sum_{i=1}^{N}\alpha_iy_ix_i$$<br>$$\sum_{i=1}^N \alpha_iy_i=0$$</li>
<li>代入原式得$$min_{w,b}L(w,b,\alpha)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+ \sum_{i=1}^{N}\alpha_i$$,所以求该式对$\alpha$的极大，即求约束最优化问题<br>$$max_{\alpha}  -\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+ \sum_{i=1}^{N}\alpha_i$$<br>$$s.t.  \sum_{i=1}^N \alpha_iy_i=0, \alpha_i \geq 0, i=1,2,…,N$$</li>
<li>对偶问题即为<br>$$min_{\alpha}  \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)- \sum_{i=1}^{N}\alpha_i$$<br>$$s.t.  \sum_{i=1}^N \alpha_iy_i=0, \alpha_i \geq 0, i=1,2,…,N$$</li>
<li>使用SMO算法可以求得最优的$\alpha_j^*&gt;0 \to w^*=\sum_{i=1}^{N}\alpha_i^*y_ix_i \to b^*=y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_i\cdot x_j) \to$分离超平面<br>$$w^*\cdot x+b^*=0$$,对应的决策函数为<br>$$f(x)=sign(w^*\cdot x+b^*)=sign(\sum_{i=1}^{N}\alpha_i^*y_i(x\cdot x_i)+b^*)$$</li>
</ul>
<p><em>Notes:</em></p>
<ul>
<li>分类决策函数只依赖于输入$x$与训练样本输入的内积</li>
<li>至此为线性可分支持向量机的<strong>对偶学习算法</strong></li>
<li>上述结果体现出支持向量机的一个重要性质：训练完成后，大部分训练样本都不需要保留，最终模型仅与支持向量有关</li>
<li>SMO算法：分解为子问题求解<ul>
<li>求解两个变量二次规划的解析方法</li>
<li>选择变量的启发式方法</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/03/13/1982684.html" target="_blank" rel="external">为什么说对偶算法更易求解？效率更高</a><blockquote>
<p>以前新来的要分类的样本首先根据$w$和$b$做一次线性运算，然后看求的结果是大于0还是小于0,来判断正例还是负例。现在有了$\alpha_i$，我们不需要求出$w$，只需将新来的样本和训练数据中的所有样本做内积和即可。那有人会说，与前面所有的样本都做运算是不是太耗时了？其实不然，我们从KKT条件中得到，只有支持向量的$\alpha_i&gt;0$，其他情况$\alpha_i=0$。因此，我们只需求新来的样本和支持向量的内积，然后运算即可。这种写法为下面要提到的核函数（kernel）做了很好的铺垫。</p>
</blockquote>
</li>
</ul>
<h4 id="算法——对偶学习算法"><a href="#算法——对偶学习算法" class="headerlink" title="算法——对偶学习算法"></a>算法——对偶学习算法</h4><blockquote>
<p>输入：线性可分训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace, x_i\in R^n,y_i \in \lbrace -1,+1 \rbrace, i=1,2,…,N$<br>输出：分离超平面和分类决策函数</p>
<ul>
<li>(1)构造并求解约束最优化问题<br>$$min_{\alpha}  \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)- \sum_{i=1}^{N}\alpha_i$$<br>$$s.t.  \sum_{i=1}^{N}\alpha_iy_i = 0　\alpha_i \geq 0, i=1,2,…,N$$求得最优解$\alpha^* = (\alpha_1^* … \alpha_n^*)^T$</li>
<li>(2)计算$$w^* = \sum_{i=1}^{N}\alpha_i^*y_ix_i$$,并选择$\alpha^*$的一个正分量$\alpha_j^*&gt;0$,计算<br>$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_i\cdot x_j)$$</li>
<li>(3)求得分离超平面$$w^*\cdot x+b^*=0$$,对应的决策函数为<br>$$f(x)=sign(w^*\cdot x+b^*)=sign(\sum_{i=1}^{N}\alpha_i^*y_i(x_i\cdot x_j)+b^*)$$</li>
</ul>
</blockquote>
<p><em>Notes:</em>$w^*,b^*$只依赖于训练数据中对应于$\alpha_i^*&gt;0$的样本点$(x_i,y_i)$，这些实例点$x_i$即为支持向量</p>
<h2 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>训练样本线性不可分时的线性支持向量机，此处的线性不可分指的是近似线性可分，即训练数据集有一些特异点，去除掉这些特异点后剩下大部分样本点组成的集合是线性可分的</p>
<h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p>软间隔最大化问题：在硬间隔最大化的目标函数中添加<strong>松弛变量</strong>和<strong>惩罚参数</strong>，在约束条件中添加<strong>松弛变量</strong>，即<br>$$min_{w,b,\xi}  \frac{1}{2}{||w||^2}+C\sum_{i=1}^{N}\xi_i$$<br>$$ s.t. 　y_i(w\cdot x_i+b) \geq 1 - \xi_i;　　\xi_i \geq 0 　i=1,2,…,N$$</p>
<p><em>Notes:</em></p>
<ul>
<li>使间隔尽量大$\to \frac{1}{2}||w||^2$尽量小</li>
<li>误分类点个数尽量少，即松弛变量$\xi_i$尽量小,$C$为调和两者的系数</li>
</ul>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>类似线性可分支持向量机中做法，引入拉格朗日乘子并构建拉格朗日函数，利用拉格朗日对偶性，问题转化为求解对偶问题<br>$$min_{\alpha}  \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)- \sum_{i=1}^{N}\alpha_i$$<br>$$s.t.  \sum_{i=1}^{N}\alpha_iy_i = 0;　 0 \leq \alpha_i \leq C, i=1,2,…,N$$</p>
<p>_Notes:可以对比线性可分支持向量机，主要区别在于约束条件$\alpha_i$多了上界$C$_</p>
<h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><p>软间隔/线性支持向量机的原始问题可以等价于添加了正则化项的合页损失函数，即最小化以下目标函数<br>$$min_{w,b}  \sum_{i=1}^{N}[1-y_i(w\cdot x_i+b)]_++\lambda ||w||^2$$</p>
<ul>
<li>第一项为合页损失函数$L(y(w\cdot x+b))=[1-y_i(w\cdot x_i+b)]_+$,一般对于函数$[z]_+$有：<br>$$[z]_+=z  if z&gt;0$$<br>$$[z]_+=0  if z\leq 0$$<br>所以原始表明当样本点$x_i,y_i$被正确分类且<strong>函数间隔(确信度)</strong>$y_i(w\cdot x_i+b)$大于1时损失为0，否则损失是$1-y_i(w\cdot x_i+b)$</li>
<li>第二项为正则化项，是系数为$\lambda$的$w$的$L_2$范数</li>
</ul>
<p><strong>线性支持向量机的原始最优化问题与上述目标函数的最优化问题是等价的</strong></p>
<p><em>那么为什么要使用合页损失函数？</em><br><img src="/materials/img/svm/loss.png" alt="loss function"><br>如图所示为常用的一些损失函数，可以看到，各个图中损失函数的曲线基本位于0-1损失函数的上方，所以可以作为0-1损失函数的上界；</p>
<ul>
<li>由于0-1损失函数不是连续可导的，直接优化由其构成的目标损失函数比较困难，所以对于svm而言，可以认为是在优化由0-1损失函数的上界(合页损失函数)构成的目标函数，又称为<strong>代理损失函数</strong></li>
<li>合页损失函数对学习有更高的要求</li>
<li>附：常用替代损失函数，通常具有较好的数学性质，比如凸的连续函数且是0/1损失函数的上界<ul>
<li>hinge损失$$l_{hinge}(z)=max(0,1-z)$$</li>
<li>指数损失$$l_{exp}(z)=exp(-z)$$</li>
<li>对率损失$$l_{log}(z)=log(1+exp(-z))$$</li>
</ul>
</li>
<li>合页损失函数这里也看得到与前面所述的一些模型的讲解方式的差异，前面大部分模型的策略部分的目标函数是在做一个损失函数的最小化问题求解，而SVM一开始就假设特征空间线性可分，所以这种前提下是不存在损失的，因此目标是找到一个超平面使得将正反例最大区分度的分割开来，于是目标函数就成了求解最大间隔的问题，包括引入和函数也使得本身可能线性并不可分的样本能够在高位空间被划分开来，但是这样存在一点问题就是构成的模型对于噪声点比较敏感，因为理论上而言在无穷维度一定能将样本划分开来，所以假设样本本身存在一些噪声点，这个时候的模型就会出现过拟合的问题，于是就引入了松弛变量和软间隔理论（这里也可以从经验风险-结构风险的角度来理解）；这也是另一种讲解顺序，在周志华的《机器学习》一书以及博客<a href="https://www.cnblogs.com/jerrylead/archive/2011/03/13/1982639.html" target="_blank" rel="external">jerrylead</a>里都是按这种顺序来讲解的</li>
</ul>
<h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><h3 id="非线性分类问题"><a href="#非线性分类问题" class="headerlink" title="非线性分类问题"></a>非线性分类问题</h3><ul>
<li>非线性分类问题是指通过利用非线性模型才能很好的进行分类的问题</li>
<li>用线性分类方法求解非线性分类问题分为两步：<ul>
<li>首先使用一个变换将原空间的数据映射到新空间；</li>
<li>在新空间里用现行分类学习方法从训练数据中学习分类模型；核技巧就属于这样的方法<h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><blockquote>
<ul>
<li>核技巧应用到支持向量机，其基本想法是通过一个非线性变换将输入空间（欧式空间或离散集合）对应于一个特征空间（希尔伯特空间），使得在输入空间中的超曲面模型对应于特征空间中的超平面模型(支持向量机)；这样分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成了</li>
<li>核技巧：在核函数给定的条件下，可利用解线性分类问题的方法求解非线性分类问题的支持向量机；学习是隐式地在特征空间进行的，不需要显式地定义特征空间和映射函数</li>
<li>实际应用中，常依赖于领域知识直接选择核函数，其有效性通过实验验证</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><em>Notes:若原始空间是有限维的（属性数有限），则一定存在一个高维特征空间使样本可分</em></p>
<h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><ul>
<li>正定核<br>通常所述的核函数就是正定核函数，证明一个函数为正定核函数的充要条件为证明该函数对应的Gram矩阵为半正定矩阵</li>
<li>常用核函数<ul>
<li>多项式核函数–p次多项式分类器</li>
<li>高斯核函数–高斯径向基函数分类器</li>
<li>字符串核函数–定义在离散数据的集合上(字符串集合)–余弦相似度</li>
</ul>
</li>
</ul>
<p><img src="/materials/img/svm/kernel.png" alt="kernel"><br><a href="http://blog.csdn.net/fjssharpsword/article/details/56481358" target="_blank" rel="external">图片来源</a></p>
<h3 id="求解问题"><a href="#求解问题" class="headerlink" title="求解问题"></a>求解问题</h3><ul>
<li>选取适当的核函数$K(x,z)$和适当的参数$C$,构造并求解最优化问题：<br>$$min_{\alpha}  \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)- \sum_{i=1}^{N}\alpha_i$$<br>$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$<br>$$0 \leq \alpha_i \leq C 　i=1,2,…,N$$</li>
<li>构造决策函数<br>$$f(x)=sign(\sum_{i=1}^{N}\alpha_i^*y_iK(x\cdot x_i)+b^*)$$</li>
</ul>
<p><em>Notes:可以对比软间隔最大化的对偶学习问题，区别在于用核函数$K(x,z)$代替了原始目标函数中的内积</em></p>
<h2 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h2><blockquote>
<p>SMO算法是支持向量机学习的一种快速算法，其特点是不断的将原二次规划问题分解为只有两个变量的二次规划问题，并对子问题进行解析求解，直到所有变量满足KKT条件为止，这样通过启发式的方法得到原二次规划问题的最优解，<strong>因为子问题有解析解，所以每次计算子问题都很快，虽然计算子问题次数很多，但在总体上还是高效的</strong></p>
</blockquote>
<ul>
<li>选取$\alpha_i,\alpha_j$的方法：<ul>
<li>先选取违背KKT条件程度最大的变量作为第一个变量，然后启发式的选择与第一个变量对应样本间间隔最大的变量作为第二个变量</li>
</ul>
</li>
</ul>
<h2 id="SVM-vs-Logistic-Regression"><a href="#SVM-vs-Logistic-Regression" class="headerlink" title="SVM vs.Logistic Regression"></a>SVM vs.Logistic Regression</h2><ul>
<li>同：优化目标相近，通常情形下性能也相当</li>
<li>异：<ul>
<li>LR的优势在于其输出具有自然的概率意义，给出预测标记的同时也给出了概率，而SVM要想得到概率输出需特殊处理</li>
<li>LR能直接用于多分类任务，而SVM则需要进行推广</li>
<li>SVM的解具有稀疏性（仅依赖于支持向量），LR对应的对率损失则是光滑的单调递减函数，因此LR的解依赖于更多的训练样本，其预测开销更大<br>参考《机器学习》</li>
</ul>
</li>
</ul>
<h2 id="支持向量回归"><a href="#支持向量回归" class="headerlink" title="支持向量回归"></a>支持向量回归</h2><p><em>TODO</em></p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p>关于SVM的讲解有不少优秀资料，小结如下</p>
<ul>
<li><a href="https://www.cnblogs.com/jerrylead/archive/2011/03/13/1982639.html" target="_blank" rel="external">从LR过渡到SVM的讲解方式</a></li>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/03/13/1982684.html" target="_blank" rel="external">串讲拉格朗日对偶性与SVM对偶算法的推导</a></li>
<li>周志华《机器学习》</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> SVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最优化算法小记]]></title>
      <url>/2017/07/11/optimization/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>最优化：</p>
<ul>
<li>构造一个合适的目标函数（策略），使得这个目标函数取到极值的解就是你所要求的东西；</li>
<li>找到一个能让这个目标函数取到极值的方法（算法）</li>
</ul>
</blockquote>
<p>这里主要讨论几种常用的求解最优化问题的算法<br><a id="more"></a></p>
<h2 id="梯度下降法（最速下降法）"><a href="#梯度下降法（最速下降法）" class="headerlink" title="梯度下降法（最速下降法）"></a>梯度下降法（最速下降法）</h2><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><blockquote>
<p>在微积分里面，对多元函数的参数求偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度;从几何意义上讲，就是函数变化增加最快的地方。</p>
</blockquote>
<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><blockquote>
<p>梯度下降法是求解无约束最优化问题的一种常用的<strong>一阶优化方法</strong>，是一种<strong>迭代算法</strong>，每一步需要求解目标函数的梯度向量。</p>
</blockquote>
<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><ul>
<li>对于无约束优化问题$min_xf(x)$，其中$f(x)$为连续可微函数，若能构造一个序列$x^0,x^1,…$,满足$$f(x^{t+1})&lt;f(x^t),t=0,1,2,..$$，则不断执行该过程即可收敛到局部极小点；</li>
<li>而为了达到这一目的，根据泰勒展开式有$$f(x+\Delta x)\approx f(x)+\Delta x^T\nabla f(x)$$,而为了满足$f(x+\Delta x)&lt;f(x)$，可选择$$\Delta x=-\gamma \nabla f(x)$$即负梯度,其中步长（即学习率）$\gamma$是一个小常数（每步的步长可以不同）；</li>
<li>对于步长，可通过一维检索确定，即$$f(x^{(k)}-\gamma \nabla f(x))=min_{\gamma\geq 0}f(x^{(k)}-\gamma \nabla f(x))$$,但是这种方法会增加额外的计算开销，不过如果固定步长，也有可能导致糟糕的收敛，所以需要根据实际情况选择处理方法。</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<ul>
<li>输入：目标函数$f(x)$,梯度函数$g(x)=\nabla f(x)$，计算精度$\varepsilon$</li>
<li>输出：$f(x)$的极小点$x^*$</li>
<li>(1)取初始值$x^{(0)}\in R^n$,置$k=0$</li>
<li>(2)计算$f(x^{(k)})$</li>
<li>(3)计算梯度$g_k=g(x^{(k)})$,当$||g_k||&lt;\varepsilon$时，停止迭代，令极小点$x^*=x^{(k)}$,否则令负梯度$p_k=-g(x^{(k)})$,求步长$\lambda_k$，使$$f(x^{(k)}+\lambda_kp_k)=min_{\lambda\geq 0}f(x^{(k)}+\lambda p_k)$$</li>
<li>(4)迭代更新，置$x^{(k+1)}=x^{(k)}+\lambda_kp_k$,计算$f(x^{(k+1)})$,当$||f(x^{(k+1)})-f(x^{(k)})||&lt;\varepsilon$或$||x^{(k+1)}-x^{(k)}||&lt;\varepsilon$时，停止迭代，令$x^*=x^{(k)}$</li>
<li>(5)否则,置$k=k+1$,转第(3)步</li>
</ul>
</blockquote>
<p><em>Notes:</em></p>
<ul>
<li>一般情况下，步长可以取一个较小的值，而不必每次都计算当前的最佳步长</li>
<li>另外，该算法中停止迭代的条件出现了两次，第一次是刚计算出梯度时就与计算精度进行比较，第二次是分别把目标函数值以及两次迭代的输入$x$的差值与计算精度进行了比较，但其他的一些参考资料似乎只是检查了梯度下降的距离与计算精度的关系，即$||f(x^{(k+1)})-f(x^{(k)})||&lt;\varepsilon$，比如<a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">博客</a></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>梯度下降法靠近极小值时速度减慢（所以不必每次迭代刻意减小步长）</li>
<li>对某些目标函数可能会“之字型”地下降</li>
<li>若目标函数$f(x)$满足一些条件，则通过选取适当的步长能确保通过梯度下降收敛到局部极小点，比如若$f(x)$满足L-Lipschitz条件（对任意$x$存在常数$L$使得$||\nabla f(x)||\leq L$成立），则将步长设置为$1/2L$可确保收敛到局部极小点；</li>
<li>当目标函数是凸函数时，局部极小点即对应着函数的全局最小点</li>
</ul>
<h3 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h3><ul>
<li>梯度下降算法的步长会影响其收敛，步长太大可能难以收敛到局部最优值，步长太小则会导致收敛速度较慢；</li>
<li>初始值不同可能导致梯度下降算法收敛到不同的局部最优解，所以一般可以采取多次训练的方法求解</li>
<li>由于样本不同特征的取值范围不一样，可能导致迭代很慢，为了减少特征取值的影响，可以对特征数据归一化$$\frac{x-\overline{x}}{std(x)}$$从而加快收敛速度</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="批量梯度下降法"><a href="#批量梯度下降法" class="headerlink" title="批量梯度下降法"></a>批量梯度下降法</h4><blockquote>
<p>Batch Gradient Descent(BGD):在更新参数时使用所有的样本来进行更新</p>
</blockquote>
<p>$$\theta_i=\theta_i-\alpha\sum_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}$$<br>其中$\theta_i$为需要估计的达到局部最优时的参数值，步长为$\alpha$，一共$m$个样本$n$个特征,求梯度的时候用了所有样本的梯度数据</p>
<h4 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h4><blockquote>
<p>Stochastic Gradient Descent(SGD):计算梯度时仅选取一个样本来求梯度，适用于训练数据集数据量较大的情形</p>
</blockquote>
<p>$$\theta_i=\theta_i-\alpha(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}$$</p>
<h4 id="小批量梯度下降法"><a href="#小批量梯度下降法" class="headerlink" title="小批量梯度下降法"></a>小批量梯度下降法</h4><blockquote>
<p>Mini-batch Gradient Descent(MBGD):批量梯度下降法和随机梯度下降法的折衷，也就是对于$m$个样本，我们采用$x$个样本来迭代，$1&lt;x&lt;m$</p>
</blockquote>
<p>$$\theta_i=\theta_i-\alpha\sum_{j=t}^{t+x-1}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}$$</p>
<p><em>Notes:</em></p>
<ul>
<li>目标函数收敛速度来说：随机梯度下降法由于每次仅仅采用一个样本来迭代，训练速度很快，而批量梯度下降法在样本量很大的时候，训练速度不能让人满意。</li>
<li>对于准确度来说，随机梯度下降法用于仅仅用一个样本决定梯度方向，导致解很有可能不是最优。对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</li>
<li>小批量梯度下降法则是批量梯度下降法和随机梯度下降法的折衷</li>
</ul>
<h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p><em>严格来讲，最小二乘法其实并不能归类到最优化算法这里面来，主要是在涉及线性回归模型的目标函数求解时，不少资料里都提到过可以用最小二乘法或者梯度下降法求解，所以放到这里进行比较讨论，具体的一些讨论可以参照参考资料里的知乎的一系列问题</em></p>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于梯度下降法，当目标函数$f(x)$二阶可微时，可将一阶泰勒展开式$f(x+\Delta x)\approx f(x)+\Delta x^T\nabla f(x)$替换为更精确的二阶泰勒展开式，这样就得到了<strong>牛顿法</strong>，牛顿法是典型的二阶方法，其迭代轮数远小于梯度下降法；但另一方面由于牛顿法使用了二阶导数，所以其每轮迭代都涉及了海森矩阵的求逆，计算复杂度较高，尤其在高维问题中几乎不可行；若能以较低的计算代价寻找海森矩阵的近似逆矩阵，则可显著降低计算开销，这就是<strong>拟牛顿法</strong></li>
</ul>
<p>参考资料</p>
<ul>
<li><a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">刘建平Pinard的博客</a></li>
<li><a href="https://www.zhihu.com/question/24900876/answer/46567811" target="_blank" rel="external">知乎-最优化问题的简洁介绍是什么？</a></li>
<li><a href="https://www.zhihu.com/question/20822481" target="_blank" rel="external">知乎-最小二乘法和梯度下降法有哪些区别？</a></li>
<li>李航《统计学习方法》</li>
<li>周志华《机器学习》</li>
<li>Andrew Ng 机器学习课程（Coursera）</li>
<li><a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="external">梯度下降法维基百科</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> 最优化问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习笔记之线性模型]]></title>
      <url>/2017/07/09/linear-model/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><blockquote>
<p>线性模型试图学得一个通过属性的线性组合来进行预测的函数，即$$f(x)=w_1x_1+w_2x_2+…w_dx_d+b$$</p>
</blockquote>
<ul>
<li>线性模型形式简单、易于建模，具有很好的可解释性</li>
<li>很多功能强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得<a id="more"></a>
<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="线性回归-1"><a href="#线性回归-1" class="headerlink" title="线性回归"></a>线性回归</h3></li>
<li>模型<br>线性回归试图学得$f(x_i)=wx_i+b$,使得$f(x_i)\approx y_i$</li>
<li>均方误差<br>如何衡量$f(x)$与$y$之间的差别？<br>均方误差是回归任务中最常用的性能度量，所以关键在于使均方误差最小化，即<br>$$(w^*,b^*)=argmin_{(w,b)}\sum_{i=1}^m(f(x_i)-y_i)^2$$<br>$$(w^*,b^*)=argmin_{(w,b)}\sum_{i=1}^m(y_i-wx_i-b)^2$$<br>基于均方误差来进行模型求解的方法称为<strong>最小二乘法</strong>，在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小</li>
<li>参数估计<br>线性回归模型的最小二乘参数估计，即求解$w,b$使$E_{(w,b)}=\sum_{i=1}^m(y_i-wx_i-b)^2$最小化的过程</li>
<li>对w,b分别求导，得<ul>
<li>$$\frac{dE_{(w,b)}}{dw}=2\left(w\sum_{i=1}^mx_i^2-\sum_{i=1}^m(y_i-b)x_i\right)$$</li>
<li>$$\frac{dE_{(w,b)}}{db}=2\left(mb-\sum_{i=1}^m(y_i-wx_i)\right)$$</li>
</ul>
</li>
<li>令导数为0可求得<ul>
<li>$$w=\frac{\sum_{i=1}^my_i(x_i-\overline{x})}{\sum_{i=1}^mx_i^2-\frac{1}{m}(\sum_{i=1}^mx_i)^2}$$</li>
<li>$$b=\frac{1}{m}\sum_{i=1}^m(y_i-wx_i)$$<br>其中$\overline{x}=\frac{1}{m}\sum_{i=1}^mx_i$为$x$的均值</li>
</ul>
</li>
</ul>
<h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>线性模型可以有丰富的变化，对于原始的线性模型，我们希望其预测值逼近真实标记$y$，于是得到了线性回归模型，而如果我们令模型预测值逼近y的衍生物，这样一来就可以推广到广义的线性模型</p>
<blockquote>
<p>考虑单调可微函数$g(\cdot)$,令$$y=g^{-1}(w \cdot x+b)$$,这样得到的模型称为广义线性模型，其中函数$g(\cdot)$称为联系函数。</p>
</blockquote>
<p>实质上是在求取输入空间到输出空间的非线性函数映射</p>
<h4 id="例子——对数线性回归"><a href="#例子——对数线性回归" class="headerlink" title="例子——对数线性回归"></a>例子——对数线性回归</h4><p>假设认为示例所对应的输出标记是在指数尺度上变化，那就可将输出标记的对数作为线性模型逼近的目标，即<br>$$ln y=w \cdot x+b$$<br>即对数线性回归，实际上是在试图让$e^{w\cdot x+b}$逼近$y$,这里的对数函数就起到了将线性回归模型的预测值与真实标记联系起来的作用</p>
<p><em>Notes:此外，Logistic Regression模型可以看作是广义线性模型在分类问题上的延伸</em></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> LR </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习校招常考知识点小记]]></title>
      <url>/2017/07/08/ml-job/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<h2 id="概念-amp-原理"><a href="#概念-amp-原理" class="headerlink" title="概念&amp;原理"></a>概念&amp;原理</h2><blockquote>
<ul>
<li>高频话题是 SVM、LR、决策树（决策森林）和聚类算法，要重点准备；</li>
<li>算法要从以下几个方面来掌握<ul>
<li>产生背景</li>
<li>适用场合（数据规模，特征维度，是否有 Online 算法，离散/连续特征处理等角度）；</li>
<li>原理推导（最大间隔，软间隔，对偶）；</li>
<li>求解方法（随机梯度下降、拟牛顿法等优化算法）；</li>
<li>优缺点，相关改进；</li>
<li>和其他基本方法的对比；</li>
</ul>
</li>
<li>不能停留在能看懂的程度，还要对知识进行结构化整理，比如撰写自己的 cheet sheet，面试是在有限时间内向面试官输出自己知识的过程，如果仅仅是在面试现场才开始调动知识、组织表达，总还是不如系统的梳理准备；从面试官的角度多问自己一些问题，通过查找资料总结出全面的解答，比如如何预防或克服过拟合。<a id="more"></a></li>
<li>LDA的原理和推导；SVD、LDA</li>
<li>无监督和有监督算法的区别？</li>
<li>多分类怎么处理？（参见《机器学习》P64,通常切分为多个二分类，最后再集成）<ul>
<li>OVO</li>
<li>OVR</li>
<li>MVM–&gt;ECOC(纠错输出码)</li>
</ul>
</li>
<li>为什么会产生过拟合，有哪些方法可以预防或克服过拟合？</li>
<li>什么情况下一定会发生过拟合？<ul>
<li>训练集和测试集分布不一致的时候</li>
</ul>
</li>
<li>采用EM算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？</li>
<li>有哪些聚类方法？<ul>
<li>K-均值聚类算法、K-中心点聚类算法、CLARANS、 BIRCH、CLIQUE、DBSCAN等</li>
</ul>
</li>
<li>聚类算法中的距离度量有哪些？</li>
<li>如何进行实体识别？</li>
<li>聚类和分类有什么区别？分类是事先知道类标的，而聚类事先不知道类标。</li>
<li>L1和L2的区别</li>
<li>生成与判别模型</li>
<li>ROC-AUC<ul>
<li><a href="http://www.tuicool.com/articles/q6zYrq" target="_blank" rel="external">链接</a></li>
</ul>
</li>
<li>深度学习和机器学习的区别</li>
<li>数据挖掘和人工智能的区别</li>
<li>测试集和训练集的区别</li>
<li>PCA</li>
<li>什么是模糊聚类，还有划分聚类，层次聚类等<ul>
<li><a href="http://blog.csdn.net/xiahouzuoxin/article/details/7748823" target="_blank" rel="external">http://blog.csdn.net/xiahouzuoxin/article/details/7748823</a></li>
<li><a href="http://www.cnblogs.com/guolei/p/3899509.html" target="_blank" rel="external">http://www.cnblogs.com/guolei/p/3899509.html</a></li>
</ul>
</li>
<li>线性分类器与非线性分类器的区别及优劣；</li>
<li>特征比数据量还大时，选择什么样的分类器？</li>
<li>对于维度很高的特征，你是选择线性还是非线性分类器？</li>
<li>对于维度极低的特征，你是选择线性还是非线性分类器？</li>
<li>如何解决过拟合问题？</li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/24971995/" target="_blank" rel="external">L1和L2正则的区别，如何选择L1和L2正则？</a></li>
<li>线性回归的梯度下降和牛顿法求解公式的推导</li>
<li>如何处理类别不平衡问题？（参见《机器学习》P66）<ul>
<li>欠采样–&gt;EasyEnsemble</li>
<li>过采样–&gt;SMOTRE</li>
<li>阈值移动/代价敏感学习–&gt;原始数据嵌入“负正比”，具体的比如在xgboost中可以调整scale_pos_weight参数为数据集的负正比</li>
</ul>
</li>
<li>常见的最优化方法</li>
<li>牛顿法的原理</li>
<li>L1正则化的优化</li>
<li>0/1损失函数的常用替代损失函数（《机器学习》P130）<ul>
<li>hinge损失（合页损失）–&gt; SVM</li>
<li>指数损失 –&gt; AdaBoost</li>
<li>对率损失    –&gt; LR、最大熵</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><blockquote>
<ul>
<li>原理、推导、特性、优缺点、调参</li>
<li>统计学习的核心步骤：模型、策略、算法，你应当对logistic、SVM、决策树、KNN及各种聚类方法有深刻的理解。能够随手写出这些算法的核心递归步的伪代码以及他们优化的函数表达式和对偶问题形式。</li>
</ul>
</blockquote>
<ul>
<li>SVM的原理、推导、特性，SVM里面的核，SVM非线性分类，核函数的作用；SVM详细过程，支持向量，几何间隔概念，拉格朗日函数如何求取超平面，非线性分类；写写SVM的优化形式，用拉格朗日公式推导SVM kernel变换；SVM：中文分词；RBF核与高斯核的区别（没区别，高斯核就是rbf核）;SVM的支持向量的数学表示</li>
<li>LR 的推导，特性？；为什么可以使用logistic回归;logistic regression为什么使用sigmoid函数？;linear regression 如何处理离散值的情况，如特征为：男1，女0</li>
<li>决策树的特性？;决策树分裂</li>
<li>用EM算法推导解释 Kmeans；K-means起始点；K-means的具体流程；如何优化K-means</li>
<li>解释密度聚类算法</li>
<li>解释贝叶斯公式和朴素贝叶斯分类；贝叶斯分类器的优化和特殊情况的处理<ul>
<li>朴素贝叶斯核心思想利用先验概率得到后验概率，并且最终由期望风险最小化得出后验概率最大化，从而输出让后验概率最大化的值（具体概率与先验概率由加入拉普拉斯平滑的极大似然估计而成的贝叶斯估计得到），特征必须相互独立。</li>
</ul>
</li>
<li>KNN（分类与回归）</li>
<li>CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）</li>
<li>GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</li>
<li>随机森林（Bagging+CART）</li>
<li>神经网络,plsi的推导</li>
<li>关联分析、apriori</li>
<li>em算法推导</li>
<li>随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？</li>
<li>谱聚类处理同心圆的情况如何处理</li>
<li>spectral clustering的实现</li>
<li>推导softmax regression模型</li>
</ul>
<h2 id="模型比较"><a href="#模型比较" class="headerlink" title="模型比较"></a>模型比较</h2><ul>
<li>naive bayes和logistic regression的区别</li>
<li>SVM、LR、决策树的对比？<ul>
<li>LR vs. SVM（源于《机器学习》P132）<ul>
<li>同：优化目标相近，通常情形下性能也相当</li>
<li>异：<ul>
<li>LR的优势在于其输出具有自然的概率意义，给出预测标记的同时也给出了概率，而SVM要想得到概率输出需特殊处理</li>
<li>LR能直接用于多分类任务，而SVM则需要进行推广</li>
<li>SVM的解具有稀疏性（仅依赖于支持向量），LR对应的对率损失则是光滑的单调递减函数，因此LR的解依赖于更多的训练样本，其预测开销更大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GBDT和随机森林的区别？</li>
<li>哪些模型容易过拟合，模型怎么选择</li>
<li>改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度</li>
<li>lr的正则化，与SVM的区别</li>
<li>LR与最大熵的关系<ul>
<li>LR与最大熵模型都属于对数线性模型，形式类似</li>
<li>两个模型的学习一般采用极大似然估计，或正则化的极大似然估计，可以形式化为无约束最优化问题（意思然函数为目标函数的最优化问题，此时的目标函数是光滑的凸函数，可以保证找到全局最优解），求解该最优化问题的算法有改进的迭代尺度法、梯度下降法、拟牛顿法等</li>
</ul>
</li>
</ul>
<h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><blockquote>
<p>用了什么算法？为什么用？有什么优缺点？</p>
<pre><code>* [实际比赛中为什么tree-ensemble的机器学习方法更好](https://www.zhihu.com/question/51818176/answer/127637712)
    * 理论（VC维）：模型可控性更好，不易过拟合（用一些弱模型去提升）
    * 数据：一般基于树的算法的抗噪能力更强
        * 树模型中易对缺失值处理
        * 树模型对类别特征更友好
        * 特征的多样性导致很少使用svm，因为因为 svm 本质上是属于一个几何模型，这个模型需要去定义 instance 之间的 kernel 或者 similarity（线性svm中的内积），而我们无法预先设定一个很好的similarity。这样的数学模型使得 svm 更适合去处理 “同性质”的特征
    * 系统实现：——xgboost
        * 正确高效，C++实现
        * 灵活（深度定制不同的分类器、选择不同的损失函数、支持各种语言）、可扩展性好，可以推及到大数据、分布式训练（跨平台）
        * 简单易用（early_stop,自带cv）
    * 自适应非线性：随着决策树的生长，能够产生高度非线性的模型，而SVM等线性模型的非线形化需要基于核函数等方法，要求在学习之前就要定好核函数，然而确定合适的核函数并非易事。
    * 多分类器隐含正则：高度非线性的模型容易过拟合，因此几乎没有人会用单颗决策树。boosting和random forest等集成学习的方法都要训练多个有差异的学习器，近来有工作表明，这些有差异的学习器的组合，能够起到正则化的作用，从而使得总体复杂度降低，提高泛化能力。尤其对于random forest这样的“并行”集成方法，即使每一颗树都过拟合，直观的来讲，由于过拟合到不同的地方，总体投票或平均后并不会过拟合。
</code></pre></blockquote>
<ul>
<li>你在研究/项目/实习经历中主要用过哪些机器学习/数据挖掘的算法？<ul>
<li>最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，分类里用过 SVM、GBDT；</li>
<li>一般用法是什么，是不是自己实现的，有什么比较知名的实现，使用过程中踩过哪些坑；</li>
<li>优缺点分析。</li>
</ul>
</li>
<li>你熟悉的机器学习/数据挖掘算法主要有哪些？<ul>
<li>基础算法要多说，其它算法要挑熟悉程度高的说，不光列举算法，也适当说说应用场合；</li>
</ul>
</li>
<li>你用过哪些机器学习/数据挖掘工具或框架？</li>
<li>如何进行特征选择？</li>
<li>用过哪些聚类算法？</li>
<li>项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理<ul>
<li>量纲问题：归一化有利于优化迭代速度（梯度下降），提高精度（KNN）</li>
</ul>
</li>
<li>各类算法优缺点、模型调优细节</li>
<li>特征提取的方法（无关键词也是一个特征）</li>
<li>自己实现过什么机器学习算法?</li>
<li>从项目中在哪一方面体会最深</li>
<li>自己项目中有哪些可以迁移到其他领域的东西</li>
<li>项目相比别人有什么优劣</li>
<li>项目的数据从哪里来</li>
<li>项目的特征向量的归一化与异常处理</li>
<li>目前在研究什么</li>
</ul>
<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><ul>
<li>做广告点击率预测，用哪些数据什么算法<ul>
<li><a href="http://bbs.pinggu.org/thread-3182029-1-1.html" target="_blank" rel="external">http://bbs.pinggu.org/thread-3182029-1-1.html</a></li>
</ul>
</li>
<li>推荐系统的算法中最近邻和矩阵分解各自适用场景<ul>
<li><a href="http://www.doc88.com/p-3961053026557.html" target="_blank" rel="external">http://www.doc88.com/p-3961053026557.html</a></li>
</ul>
</li>
<li>今日头条的个性化推荐是如何实现的？</li>
<li>推荐算法（基于用户的协同过滤，基于内容的协同过滤）</li>
<li>如何做一个新闻推荐</li>
<li>NLP<ul>
<li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何高效地利用5台计算机完成文件词频统计工作？ <ul>
<li>Ans（有问题的）：将1T文件切分为5份，分配给5台计算机。每台计算机进行词频统计工作，输出一个结果为{单词：频数}的字典结果文件。将5台计算机生成的5个结果文件合并。</li>
</ul>
</li>
<li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？ <ul>
<li>Ans（不是最优）：首先将文件排序，然后遍历利用list存储结果即可。（不能用字典，因为200G统计出来的结果会很大，没有那么大的内存存放字典。由于经过排序操作，遍历存储并不会使结果丢失，所以用list存储结果即可，每当一个list即将占满内存，则将其写入文件，然后清空list继续存储结果。）</li>
</ul>
</li>
<li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中） <ul>
<li>Ans1（不是很好）：对1T文件中的单词进行抽样，获得其概率分布，遍历文件，然后根据首字母的概率均匀分配至5台计算机，如a到e的概率均为0.04, 0.04*5=0.2，则将所有以a-e的单词放入第1台计算机，若z的概率为0.2，则把所有以z开头的单词放入第5台计算机。缺点：不具有可扩展性，如果有100台计算机，那么可能就需要2个字母计算了，则程序就要改变。还有可能出现2台机器中有相同的单词。 </li>
<li>Ans2（不是最优）：遍历文件，对于每一个单词，获得单词中各字母的ASCII码值，然后将ASCII值之和取余。则每台机器中的单词必定是不一样。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h2><blockquote>
<ul>
<li>先不要考虑完善性或可实现性，调动你的一切知识储备和经验储备去设计，有多少说多少，想到什么说什么，方案都是在你和面试官讨论的过程里逐步完善的，不过面试官有两种风格：引导你思考考虑不周之处 or 指责你没有考虑到某些情况，遇到后者的话还请注意灵活调整答题策略;</li>
<li>和同学朋友开展讨论</li>
</ul>
</blockquote>
<ul>
<li>用户流失率预测怎么做（游戏公司的数据挖掘都喜欢问这个）（涉及数据不平衡问题和时间序列分析）<ul>
<li><a href="http://www.docin.com/p-1204742211.html" target="_blank" rel="external">http://www.docin.com/p-1204742211.html</a></li>
</ul>
</li>
<li>一个游戏的设计过程中该收集什么数据</li>
<li>如何从登陆日志中挖掘尽可能多的信息<ul>
<li><a href="http://www.docin.com/p-118297971.html" target="_blank" rel="external">http://www.docin.com/p-118297971.html</a></li>
</ul>
</li>
<li>给你公司内部群组的聊天记录，怎样区分出主管和员工？</li>
<li>如何评估网站内容的真实性（针对代刷、作弊类）？</li>
<li>深度学习在推荐系统上可能有怎样的发挥？</li>
<li>路段平均车速反映了路况，在道路上布控采集车辆速度，如何对路况做出合理估计？采集数据中的异常值如何处理？</li>
<li>如何根据语料计算两个词词义的相似度？</li>
<li>在百度贴吧里发布 APP 广告，问推荐策略？</li>
<li>如何判断自己实现的 LR、Kmeans 算法是否正确？</li>
<li>100亿数字，怎么统计前100大的？</li>
<li>每个实体有不同属性，现在有很多实体的各种属性数据，如何判断两个实体是否是同一种东西<ul>
<li>重写equals方法，对类里面的对象进行属性比较</li>
</ul>
</li>
<li>学校食堂如何应用数据挖掘的知识</li>
<li>有用户的搜索历史数据，如何判断用户此时的各种状态（准备买车、已经买车等）</li>
<li>给定年龄、性别、学历等信息，对用户的信用进行评估</li>
</ul>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul>
<li>如何判断函数凸或非凸？<ul>
<li>凸函数定义：对区间$[a,b]$上定义的函数$f$，若他对区间中任意两点$x_1,x_2$均有$f(\frac{x_1+x_2}{2})\leq \frac{f(x_1)+f(x_2)}{2}$,则称$f$为区间$[a,b]$上的凸函数。</li>
<li>U形曲线的函数通常是凸函数</li>
<li>对实数集上的函数通常可以通过求二阶导数来判别，而二阶导数在区间上非负则称为凸函数，若二阶导数在区间上恒大于0则称严格凸函数</li>
</ul>
</li>
<li>解释对偶的概念</li>
<li>一个概率题目： 6个LED灯管，找整体旋转180’后仍然是一个正常输入的情况（考虑全即可）</li>
<li>一个袋子里有很多种颜色的球，其中抽红球的概率为1/4，现在有放回地抽10个球，其中7个球为红球的概率是多少？（伯努利试验）</li>
<li>给定一个分类器p，它有0.5的概率输出1，0.5的概率输出0。<ul>
<li>Q1：如何生成一个分类器使该分类器输出1的概率为0.25，输出0的概率为0.75？ <ul>
<li>Ans：连续进行两次分类，两次结果均为1则输出1，其余情况（10,01,00）均输出0。</li>
</ul>
</li>
<li>Q2：如何生成一个分类器使该分类器输出1的概率为0.3，输出0的概率为0.7？ Tip：小明正在做一道选择题，问题只有A、B和C三个选项，通过抛一个硬币来使选择3个选项的概率相同。小明只需抛连续抛两次硬币，结果正正为A，正负为B，负正为C，负负则重新抛硬币。 <ul>
<li>Ans：连续进行4次分类（2^4=16 &gt; 10），结果前3种情况则输出1，结果接下来7种情况则输出0，其余情况重新进行分类。</li>
</ul>
</li>
</ul>
</li>
<li>概率题：一个游戏，升一级的概率为p1，等级保持不变的概率为p2，等级下降一级的概率为p3。一个用户经过n个回合，等级为m的概率</li>
</ul>
<h2 id="大数据相关"><a href="#大数据相关" class="headerlink" title="大数据相关"></a>大数据相关</h2><ul>
<li>如何用hadoop实现k-means？</li>
<li>spark工作原理</li>
<li>spark运行原理</li>
<li>map-reduce<ul>
<li>mapreduce常用的接口</li>
<li>mapreduce的工作流程</li>
<li>MR优化方式</li>
<li>什么样的情况下不能用mapreduce</li>
<li>mapreduce怎么实现join连接</li>
<li>如何解决mapreduce的数据倾斜</li>
<li>mapreduce怎么实现把移动数据到移动计算的</li>
</ul>
</li>
<li>10亿个整数，1G内存，O(n)算法，统计只出现一次的数。<ul>
<li>方案一：分拆然后分布式，方案二：对应每个数有三个状态，01代表出现一次，统计10亿以内数据，然后看最终哪些是01状态</li>
</ul>
</li>
<li>海量数据排序；<ul>
<li>bit位操作</li>
</ul>
</li>
<li>海量数据中求取出现次数最大的100个数<ul>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="external">链接</a></li>
<li>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；</li>
<li>双层桶划分</li>
<li>Bloom filter/Bitmap；</li>
<li>Trie树/数据库/倒排索引；</li>
<li>外排序；</li>
<li>分布式处理之Hadoop/Mapreduce。</li>
</ul>
</li>
<li>实现一个分布式的矩阵向量乘的算法</li>
<li>实现一个分布式的topN算法</li>
</ul>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><ul>
<li>介绍卷积神经网络，和DBN有什么区别？</li>
<li>Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧</li>
</ul>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ul>
<li>你觉得Python和Java在使用起来，有什么区别？</li>
<li>Java<ul>
<li>数组与链表的区别是什么？</li>
<li>给你两张表，表A和表B，其中表A有3条数据，表B有5条数据，问：表A left join 表B后有几条？</li>
<li>ArryList、LinkedList、vector的区别</li>
<li>hashMap HashTable的区别</li>
<li>垃圾回收机制</li>
<li>JVM的工作原理</li>
<li>for循环LinkedList</li>
<li>遍历HashMap的并且把某一个值删除</li>
<li>线程 进程</li>
<li>Java中Runnable和Thread的区别Callable</li>
<li>Callable与Future的介绍</li>
<li>sleep wait区别</li>
<li>java的数据类型</li>
<li>JAVA如何实现序列化</li>
<li>反序列化是什么？</li>
<li>序列化是将（内存中的）结构化的数据数据，序列化成2进制</li>
<li>python读取文件，写代码</li>
<li>python计算一个文件中有N行，每行一列的数的平均值，方差，写代码</li>
<li>main(argc,argv[])里面两个参数什么意思<ul>
<li>args是Java命令行参数，我们在DOS中执行Java程序的时候使用“java 文件名 args参数”。args这个数组可以接收到这些参数。当然也可以在一个类中main方法中直接调用另一个类里的main方法，因为main方法都是static修饰的静态方法，因此可以通过类名.main来调用，这时就可在调用处main方法中传入String[]类型的字符串数组，达到调用的目的，也可不传入参数</li>
</ul>
</li>
</ul>
</li>
<li>Python<ul>
<li>list有哪几种添加元素的方法，能否从表头插入元素？(append, extend和insert, insert能从表头插入元素, 但是时间复杂度为O(n).)</li>
<li>如何提高Python的运行效率</li>
<li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)（Python）</li>
<li>a = [1, 2, 3, 4], b = a, b[0] = 100, 请问print(a)结果是什么</li>
<li><a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="external">list是怎样实现的</a></li>
<li>常用的数据结构及应用场景（list，dict，tuple）</li>
<li>Python装饰器、yield等</li>
<li>给定一个文件，包含了data, ciyt, count等信息，写代码实现给定city和date1-date2日期内，count最高的日期</li>
</ul>
</li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul>
<li>两个数组，求差集</li>
<li>写程序实现二分查找算法，给出递归和非递归实现，并分析算法的时间复杂度。</li>
<li>实现单链表的反转</li>
<li>求两个一维数组的余弦相似度，写代码</li>
<li>字符串翻转</li>
<li>快排</li>
<li>非递归的二叉前/中/后序遍历</li>
<li>手写二叉树前/中/后序递归遍历算法（千万不要忘记异常处理！）</li>
<li>两个字符串的复制（除了字符串地址重叠的情况，也要注意判断字符串本身的空间足够不足够，对于异常情况要考虑全面）</li>
<li>一个数组，如果存在两个数之和等于第三个数，找出满足这一条件的最大的第三个数（设为x+y =c）</li>
<li>怎样将二叉排序树变成双向链表，且效率最高</li>
<li>从栈里找最小的元素，且时间复杂度为常数级</li>
<li>float转string</li>
<li>判断一棵树是否是另一棵的子树</li>
<li>在一个n*n的矩阵中填数的问题，那种转圈填数</li>
<li>链表存在环问题，环的第一个节点在哪里？</li>
<li>几个排序算法，时间复杂度&amp;空间复杂度</li>
<li>数据结构当中的树，都有哪些？<ul>
<li>二叉查找树（二叉排序树）、平衡二叉树（AVL树）、红黑树、B-树、B+树、字典树（trie树）、后缀树、广义后缀树</li>
<li><a href="http://www.cnblogs.com/dong008259/archive/2011/11/22/2255361.html" target="_blank" rel="external">链接</a></li>
</ul>
</li>
<li>输出一个循环矩阵</li>
<li>翻转字符串（《剑指offer》原题）</li>
<li>N个数找K大数那个题,堆解释了一遍,比较满意,问还能怎么优化O(Nlogk)的方法，并行方面想</li>
<li>一个班60个人怎么保证有两个人生日相同,听完后有点奇怪,①为什么是60个人?②为什么是保证?,反正没管这么多就是概率嘛,算就完了.<ul>
<li>1减去50个人生日不同的概率≈100%</li>
</ul>
</li>
<li>问一个字符串怎么判断是邮箱比如:vzcxn@sdf.gre.有限状态自动机,然后要我画状态转移图.<ul>
<li><a href="https://zhidao.baidu.com/question/1689951223170121588.html" target="_blank" rel="external">链接</a></li>
</ul>
</li>
<li>给10^10个64位数,100M内存的空间排序,一个求中位数的方法.用文件操作来做了,像快排一样,二分选个数统计大于那个数的数量和小于那个数的数量,如果能用100M的空间排序就把那些数排了,如果不能继续.直到能排为止.<ul>
<li><a href="http://blog.csdn.net/guyulongcs/article/details/7520467" target="_blank" rel="external">链接</a></li>
</ul>
</li>
<li>kmp算法</li>
<li>求最大字段和，用动态规划和分治法两个方法，时间复杂度怎么算</li>
<li>统计字符串中出现的字符个数，忽略大小写，其中可能有其他字符。</li>
<li>寻找二叉树的公共父节点</li>
<li>b+ b-树、红黑树</li>
<li>判断两条链表是否交叉</li>
<li>树的广度、深度遍历</li>
<li>稳定与不稳定排序</li>
<li>并行计算、压缩算法</li>
<li>最长上升子序列，两个大小相同的有序数组找公共中位数</li>
<li>介绍大顶堆和小顶堆</li>
<li>反转链表</li>
<li>单链表转二叉树，二叉树转单链表（要求原地）</li>
</ul>
<p>参考</p>
<ul>
<li><a href="https://www.zhihu.com/question/23259302#rd" target="_blank" rel="external">知乎-如何准备机器学习工程师的面试 ？</a></li>
<li><a href="https://www.zhihu.com/question/23259302/answer/24300412" target="_blank" rel="external">by 刘志权</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27151345" target="_blank" rel="external">机器学习及大数据相关面试的职责和面试问题(转)</a></li>
<li><a href="https://www.zhihu.com/question/23259302/answer/174467341" target="_blank" rel="external">by 姚凯飞</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记（六）——Logistic Regression]]></title>
      <url>/2017/07/08/lr/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>Logistic Regression与最大熵模型均属于对数线性模型<br><a id="more"></a></p>
<h2 id="Logistic-Regression的理解"><a href="#Logistic-Regression的理解" class="headerlink" title="Logistic Regression的理解"></a>Logistic Regression的理解</h2><h3 id="角度一：输入变量-X-服从Logistic分布的模型"><a href="#角度一：输入变量-X-服从Logistic分布的模型" class="headerlink" title="角度一：输入变量$X$服从Logistic分布的模型"></a>角度一：输入变量$X$服从Logistic分布的模型</h3><h4 id="Logistic分布"><a href="#Logistic分布" class="headerlink" title="Logistic分布"></a>Logistic分布</h4><ul>
<li>定义：设$X$是连续随机变量，$X$服从Logistic分布是指$X$具有下列分布函数和密度函数<ul>
<li>分布函数$$F(X)=P(X \leq x)=\frac{1}{1+e^{-(x-\mu)/\gamma}}$$</li>
<li>密度函数$$f(x)=F’(x)=\frac{e^{-(x-\mu)/\gamma}}{\gamma(1+e^{-(x-\mu)/\gamma})^2}$$<br>其中$\mu$为位置参数，$\gamma&gt;0$为形状参数</li>
</ul>
</li>
<li>分布函数属于Logistic函数，对应的图行为一条S形曲线（sigmoid curve），以点$\left(\mu,\frac{1}{2}\right)$为中心对称，如图<br><img src="/materials/img/LR/sigmoid.png" alt="sigmoid"><br>，曲线在中心附近增长较快</li>
</ul>
</blockquote>
<h4 id="二项LR模型"><a href="#二项LR模型" class="headerlink" title="二项LR模型"></a>二项LR模型</h4><blockquote>
<p>二项LR模型是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的Logistic分布，其中随机变量$X$的取值为实数，随机变量$Y$的取值为1或0</p>
</blockquote>
<ul>
<li>定义：二项LR模型是如下的条件概率分布：<br>$$P(Y=1|x)=\frac{exp(w \cdot x+b)}{1+exp(w \cdot x+b)}$$<br>$$P(Y=0|x)=\frac{1}{1+exp(w \cdot x+b)}$$其中$w \in R^n$称为权值向量，$b$称为偏置，两者为需要估计（学习）的参数,$w \cdot x$为$w$和$x$的内积</li>
<li>对于给定的输入实例$x$，按照上式可求得对应的条件概率，比较两个条件概率的大小，将实例划分到较大的一类</li>
<li>有时为了方便，将偏置扩充到权值向量中，即$w=(w^{(1)},w^{(2)},…,w^{(n)},b)^T, x=(x^{(1)},x^{(2)},…,x^{(n)},1)^T$,此时模型表示如下<br>$$P(Y=1|x)=\frac{exp(w \cdot x)}{1+exp(w \cdot x)}$$<br>$$P(Y=0|x)=\frac{1}{1+exp(w \cdot x)}$$</li>
</ul>
<h3 id="角度二：LR模型将线性分类函数转换为（条件）概率"><a href="#角度二：LR模型将线性分类函数转换为（条件）概率" class="headerlink" title="角度二：LR模型将线性分类函数转换为（条件）概率"></a>角度二：LR模型将线性分类函数转换为（条件）概率</h3><ul>
<li>几率：一个事件的几率是指该事件发生的概率与该事件不发生的概率的比值：若事件发生的概率为$p$则该事件的几率为$\frac{p}{1-p}$，进一步地该事件的对数几率为$$logit(p)=log\frac{p}{1-p}$$</li>
<li>而观察前面的LR模型可以发现，$$log\frac{P(Y=1|x)}{1-P(Y=1|x)}=log\frac{P(Y=1|x)}{P(Y=0|x)}=w \cdot x$$，也就是说，在LR模型中，输出$Y=1$的<strong>对数几率</strong>是输入$x$的<strong>线性函数</strong>，或者说<strong>输出$Y=1$的对数几率是由输入$x$的线性函数表示的模型，即LR模型</strong>（所以说Logistic Regression属于对数线性模型）</li>
<li>因此，针对对输入$x$进行分类的<strong>线性函数</strong>，通过LR模型可以将其转换为（条件）概率：$$P(Y=1|x)=\frac{exp(w \cdot x+b)}{1+exp(w \cdot x+b)}$$，其中线性函数的值越接近正无穷，概率值就越接近1，线性函数的值越接近负无穷，概率值就越接近0，这样的模型就是LR模型。</li>
</ul>
<h3 id="角度三：广义线性模型在分类问题上的推广（参考《机器学习》）"><a href="#角度三：广义线性模型在分类问题上的推广（参考《机器学习》）" class="headerlink" title="角度三：广义线性模型在分类问题上的推广（参考《机器学习》）"></a>角度三：广义线性模型在分类问题上的推广（参考《机器学习》）</h3><blockquote>
<p>用线性回归模型的预测结果去逼近真实标记的对数几率</p>
</blockquote>
<ul>
<li>对于二分类任务：其输出标记$y \in \lbrace 0,1 \rbrace$,而线性回归模型产生的预测值$f(x)=w\cdot x+b$是实值</li>
<li>而根据广义线性模型的思想，可以通过寻找一个联系函数来将分类任务的真实标记与线性回归模型的预测值联系起来</li>
<li>最直接的想法是使用单位阶跃函数，即<br><img src="/materials/img/LR/jieyue.png" alt="step function"><br>即若预测值$z$大于0就判为正例，小于0则判为反例<br><img src="/materials/img/LR/step_curve.png" alt="step curve"></li>
<li>但是单位阶跃函数不连续，所以我们希望找到一个替代函数来在一定程度上近似单位阶跃函数，并希望该函数单调可微，于是就引入了对数几率函数$$y=\frac{1}{1+e^{-z}}$$</li>
<li>将对数几率函数作为$g^-(\cdot)$带入广义线性模型则有$$y=\frac{1}{1+e^{-(w \cdot x+b)}}$$</li>
<li>其变形形式为$$ln\frac{y}{1-y}=w\cdot x+b$$,若将$y$视作样本$x$作为正例的可能性，则$1-y$是其作为反例的可能性，两者的比值$\frac{y}{1-y}$称为几率（联系角度二），反映了$x$作为正例的<strong>相对可能性</strong></li>
</ul>
<h2 id="LR模型的优点"><a href="#LR模型的优点" class="headerlink" title="LR模型的优点"></a>LR模型的优点</h2><ul>
<li>LR模型直接对分类可能性进行建模，无需事先假设数据分布，这样就避免了假设分布不准确所带来的问题</li>
<li>LR模型不是仅预测出类别，而是可得到近似概率预测，这对于许多需利用概率辅助决策的任务很有用</li>
<li>对数几率函数是任意阶可导的凸函数，有很好的数学性质，现有很多数值优化算法均可直接用于求取最优解</li>
</ul>
<h2 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h2><ul>
<li>基本思想：应用极大似然估计法估计模型参数，从而将问题转化为以对数似然函数为目标函数的最优化问题，然后采用梯度下降法或者拟牛顿法进行求解</li>
</ul>
<p><a href="https://www.nowcoder.com/discuss/3243" target="_blank" rel="external"><strong>此处的目标函数为考点</strong></a><br><img src="/materials/img/LR/LR.jpg" alt="lr"></p>
<p><a href="https://www.zhihu.com/question/24900876" target="_blank" rel="external">为什么LR模型的损失函数是交叉熵？</a>而线性回归模型的损失函数却是最小二乘呢？能否随意确定一个损失函数作为目标呢？</p>
<ul>
<li>答案是模型的损失函数由各自的响应变量$y$的概率分布决定，比如对于线性回归模型，针对的问题是预测某个结果，属于回归问题，其输出是连续值，所以我们对于该问题假设$y$服从正态分布；相对的，LR模型一般用来解决二分类问题，所以其输出是0/1，故而我们假设其输出服从伯努利分布；而进一步地，两者的损失函数都是通过极大似然估计推导的来的，所以模型的损失函数并非随意确定。</li>
<li>另外，对于线性回归问题，它的模型是 $p(y|x) = N(w^Tx, \sigma^2)$,我们采用最大似然来构造一个目标函数，最后用梯度下降来找到目标函数的最值。当然，对于这个问题，我们也可以不用梯度下降，直接用向量的投影来直接算出最优解的表达式,即“最小二乘法”；而LR模型是$p(y|x)=Ber(y|sigmoid(w^Tx))$，Ber是伯努利分布，sigmoid是logistic sigmoid函数，我们采用最大似然来构造一个目标函数，与之前的问题不同，这个目标函数比较复杂，是无法像线性回归那样一步直接算出最终的解的，但是，这个目标函数是凸的，所以我们依然能用梯度下降或者牛顿法来来找到它的最优解。</li>
<li>在LR中，<a href="https://tech.meituan.com/intro_to_logistic_regression.html" target="_blank" rel="external">最大似然函数与最小化对数损失函数等价</a></li>
</ul>
<h2 id="多项LR模型——多分类"><a href="#多项LR模型——多分类" class="headerlink" title="多项LR模型——多分类"></a>多项LR模型——多分类</h2><p>假设离散型随机变量$Y$的取值集合为$\lbrace 1,2,…,K \rbrace$，则多项LR模型是<br>$$P(Y=k|x)=\frac{exp(w_k \cdot x)}{1+\sum_{k=1}^{K-1}exp(w_k \cdot x)}$$<br>$$P(Y=K|x)=\frac{1}{1+\sum_{k=1}^{K-1}exp(w_k \cdot x)}$$<br>注意$k=1,2,…,K-1$,其中$x\in R^{n+1}, w_k \in R^{n+1}$</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><em>TODO:</em></h2><h2 id="LR与朴素贝叶斯"><a href="#LR与朴素贝叶斯" class="headerlink" title="LR与朴素贝叶斯"></a>LR与朴素贝叶斯</h2><h2 id="多分类-softmax"><a href="#多分类-softmax" class="headerlink" title="多分类-softmax"></a>多分类-softmax</h2><p>参考资料</p>
<ul>
<li>李航《统计学习方法》</li>
<li>周志华《机器学习》</li>
<li><a href="https://www.zhihu.com/question/24900876" target="_blank" rel="external">知乎-最小二乘、极大似然、梯度下降有何区别？</a></li>
<li><a href="https://tech.meituan.com/intro_to_logistic_regression.html" target="_blank" rel="external">美团点评技术团队</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> LR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GBDT]]></title>
      <url>/2017/07/07/GBDT/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p><em>参考资料:</em><a href="http://www.chengli.io/tutorials/gradient_boosting.pdf" target="_blank" rel="external">A Gentle Introduction to Gradient Boosting</a></p>
<blockquote>
<p>gradient boosting = gradient descent + boosting</p>
</blockquote>
<p>附：回顾<a href="/2017/06/29/boosting/" title="AdaBoost">AdaBoost</a></p>
<h2 id="AdaBoost-vs-Gradient-Boosting"><a href="#AdaBoost-vs-Gradient-Boosting" class="headerlink" title="AdaBoost vs. Gradient Boosting"></a>AdaBoost vs. Gradient Boosting</h2><table>
<thead>
<tr>
<th>AdaBoost</th>
<th>Gradient Boosting</th>
</tr>
</thead>
<tbody>
<tr>
<td>相同点</td>
<td>1、加性模型+前向分步算法<br> 2、每一步训练一个弱学习器以弥补前面模型的不足</td>
</tr>
<tr>
<td>不同点</td>
<td>1、AdaBoost中当前学习器的“不足”由样本权重来决定<br> 2、GBDT中当前学习器的“不足”由求梯度决定</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="Boosting历史"><a href="#Boosting历史" class="headerlink" title="Boosting历史"></a>Boosting历史</h2><ul>
<li>发明AdaBoost。第一个成功的提升算法</li>
<li>规整AdaBoost为使用特殊损失函数的梯度下降方法</li>
<li>将AdaBoost泛化为Gradient Boosting（能处理一般的损失函数）</li>
</ul>
<h2 id="简单例子理解"><a href="#简单例子理解" class="headerlink" title="简单例子理解"></a>简单例子理解</h2><p>给定数据集$(x_1,y_1),(x_2,y_2),…,(x_n,y_n)$，现在需要拟和模型$F(x)$来使平均误差最小化，假设你的朋友给你提供了一个模型$F$，你发现该模型还可以进一步提升，对于上述数据集，该模型存在少量错误，比如$F(x_1)=0.8$但$y_1=0.9; F(x_2)=1.4$但$y_2=1.3$，如何改进这个模型？</p>
<ul>
<li>一种可行的方法就是在原始的模型$F$的基础上添加一个模型，h（比如回归树），从而得到模型$F(x):=F(x)+h(x)$</li>
<li>通过拟合来改进该模型$$F(x_1)+h(x_1)=y_1$$<br>$$F(x_2)+h(x_2)=y_2$$<br>$$…$$<br>$$F(x_n)+h(x_n)=y_n$$<br>于是我们可以得到$$h(x_i)=y_i-F(x_i)$$,也就是在$F$的基础上我们针对数据集$(x_1,y_1-F(x_1)),(x_2,y_2-F(x_2)),…,(x_n,y_n-F(x_n))$拟和一个模型$h$，其中$y_i-F(x_i)$被称做是<strong>残差</strong></li>
</ul>
<h2 id="与梯度下降法的关联（回归树）"><a href="#与梯度下降法的关联（回归树）" class="headerlink" title="与梯度下降法的关联（回归树）"></a>与梯度下降法的关联（回归树）</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>$$\theta_i=\theta_i-\rho \frac{\partial J}{\partial \theta_i}$$通过朝负梯度方向移动来最小化函数</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><em>残差是如何与梯度联系起来的？</em><br><img src="/materials/img/GBDT/gd.jpg" alt="gradient descent"><br>那么我们为何还需要其他的损失函数？是因为平方损失函数不够好么？</p>
<p>平方损失函数</p>
<ul>
<li>优点：易于计算</li>
<li>缺点：对于离群值非常敏感（容易为了拟合离群值而导致整体性能下降）</li>
</ul>
<p>而其他的一些损失函数比如绝对损失函数、huber loss（丘陵损失）等对于离群值相对没有那么敏感</p>
<h3 id="一般过程（算法）"><a href="#一般过程（算法）" class="headerlink" title="一般过程（算法）"></a>一般过程（算法）</h3><blockquote>
<p>以$L$为损失函数的回归问题的一般过程</p>
<ul>
<li>初始化模型如$F(x)=\frac{\sum_{i=1}^ny_i}{n}$</li>
<li>循环直至收敛<ul>
<li>计算负梯度$-g(x_i)=-\frac{dL(y_i,F(x_i))}{dF(x_i)}$</li>
<li>用一个回归树$h$来拟合负梯度</li>
<li>更新模型$F:=F+\rho h$</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Notes:相较之下，负梯度关注离群点较少。</em></p>
<h2 id="GBDT用于分类——识别手写字母（多分类）"><a href="#GBDT用于分类——识别手写字母（多分类）" class="headerlink" title="GBDT用于分类——识别手写字母（多分类）"></a>GBDT用于分类——识别手写字母（多分类）</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>训练26个模型：$F_A ~ F_Z$</li>
<li>针对每一个样本实例，分别使用每一个模型打分，计算样本属于某个类别的概率</li>
<li>将概率最高的类标记为该样本的预测标记</li>
</ul>
<h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><ul>
<li>将样本集的实际标记转换为概率分布的形式（0-1）</li>
<li>计算各个模型预测样本属于各自分类的概率</li>
<li>计算真实概率与预测概率的差值，目的是通过调整模型减少整体误差（使预测点概率分布尽可能接近真实概率分布）</li>
</ul>
<p><em>Notes:优化参数矩阵、计算梯度矩阵</em></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> GBDT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模型集成小记]]></title>
      <url>/2017/07/03/ensemble/</url>
      <content type="html"><![CDATA[<p><em>本文主要基于周志华《机器学习》一书第八章 集成学习内容做的整理笔记，此外查阅了网上的一些博客和问答网站。</em></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>集成学习通过构建并结合多个学习器来完成学习任务。</p>
</blockquote>
<ul>
<li>如何使得集成学习性能比最好的单一学习器更好？<ul>
<li>准确性</li>
<li>多样性<blockquote>
<p>好而不同</p>
<a id="more"></a></blockquote>
</li>
</ul>
</li>
<li>如何产生并结合“好而不同”的个体学习器？<br>集成学习研究的核心<br>当前按照个体学习器的生成方式划分</li>
<li>bagging（及其变体随机森林）——个体学习器间不存在强依赖关系，可同时生成的并行化方法</li>
<li>boosting——个体学习器间存在强依赖关系，必须串行生成的序列化方法</li>
<li>从偏差-方差分解的角度，bagging和boosting分别是关注降低方差和降低偏差的两个代表，也可以按照机器学习技法的两张图来理解<br><img src="/materials/img/ensemble/under_over.png" alt="under_over"><br>第一幅图(对应boosting)可以看作进行了一个特征转换来防止欠拟合，第二幅图(对应bagging)则是为进行了一个正则化来防止过拟合</li>
</ul>
<h2 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h2><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><blockquote>
<p>首先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T,最终将这T个基学习器进行加权组合。</p>
</blockquote>
<h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>参见<a href="/2017/06/29/boosting/" title="提升方法">提升方法</a></p>
<ul>
<li>推导方式，基于“加性模型”，即基于基学习器的线性组合</li>
<li>如何在每一轮修改样本分布<ul>
<li>重赋权法：在每一轮训练中，根据样本分布为每一个训练样本重新赋予一个权重（比如《机器学习实战》一书中就是利用这种方法构建提升树算法，通过修改权重来计算每一轮的损失）</li>
<li>重采样法：利用重采样的训练集来对基学习器进行训练–&gt;重启动：避免训练过程过早停止</li>
</ul>
</li>
</ul>
<p><em>Notes:</em></p>
<ul>
<li>西瓜书上的算法还提到训练的每一轮开始都要检查当前学习器是否比随机猜测好，若条件不满足则抛弃当前学习器，这种情形可能会导致学习过程未达到T轮即停止，所以有重采样的方法来进行重启动避免出现此种情况；但是另一方面《统计学习方法》以及《机器学习实战》中的算法并未有这条判断语句；</li>
<li>《机器学习》一书中提到，从统计学的出发认为AdaBoost实质上是基于加性模型（后续指出这一视角阐释的是一个与AdaBoost很相似的过程而非其本身），以类似牛顿迭代法来优化指数损失函数，通过将迭代优化过程替换为其他优化方法产生了GradientBoosting、LPBoost等；而<a href="https://www.quora.com/What-are-the-differences-between-the-three-commonly-ensemble-learning-techniques-stacking-boosting-and-bagging" target="_blank" rel="external">这里</a>也提到每一种变体针对不同的问题（噪声、数据不平衡等）而拥有不同的权重更新规则。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p>从偏差-方差分解的角度来看，Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成（与bagging不同）。</p>
</blockquote>
<p><em>Notes:</em></p>
<ul>
<li>boosting对于噪音数据较为敏感</li>
</ul>
<h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><ul>
<li>Bootstrap AGGregatING的缩写</li>
<li>出发点依然是“好而不同”<ul>
<li>“不同”——不同基学习器基于不同的样本子集</li>
<li>“好”——使用相互有交叠的采样子集</li>
</ul>
</li>
</ul>
<h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p>基于自助采样法（bootstrap sampling）——“有放回地全抽”</p>
<blockquote>
<p>给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现，照这样我们可采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合；在对预测输出进行结合时，通常对分类任务使用简单投票法，对回归任务使用简单平均法</p>
</blockquote>
<h3 id="优点（相对于boosting）"><a href="#优点（相对于boosting）" class="headerlink" title="优点（相对于boosting）"></a>优点（相对于boosting）</h3><ul>
<li>高效——训练一个bagging集成与直接使用基学习器算法训练一个学习器的复杂度同阶</li>
<li>baggign能不经修改地用于多分类、回归任务（标准AdaBoosting只能适用于二分类任务）</li>
<li>包外估计——自助采样过程中剩余的样本可以作为验证集来对泛化性能进行“包外估计”</li>
</ul>
<p><em>Notes:</em>包外样本的其他好处（针对基学习器为决策树或神经网络时）</p>
<ul>
<li>可使用包外样本来辅助剪枝</li>
<li>用于估计决策树中各结点的后验概率以辅助对零训练样本节点的处理</li>
<li>当基学习器为神经网络时，可使用包外样本来辅助早期停止以减小过拟和风险</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p>从偏差-方差角度看，Bagging主要关注降低方差，因此它在不剪枝决策树、神经网络等易受样本扰动的学习器上效用更为明显。</p>
</blockquote>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>Bagging的一个扩展变体<ul>
<li>以决策树为基学习器构建Bagging集成</li>
<li>在决策树的训练过程中引入了随机属性选择</li>
</ul>
</li>
</ul>
<blockquote>
<p>传统决策树在选择划分属性时是在当前结点的属性集合中选择一个最优属性；而在随机森林中，对基决策树的每个节点，先从该节点属性集合中<strong>随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分</strong>，其中k控制了随机性的引入程度</p>
</blockquote>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>简单、易于实现、计算开销小</li>
<li>样本扰动+属性扰动</li>
</ul>
<h3 id="bagging-vs-随机森林"><a href="#bagging-vs-随机森林" class="headerlink" title="bagging vs. 随机森林"></a>bagging vs. 随机森林</h3><ul>
<li>两者收敛性相似，随机森林的起始性能往往相对较差，但会收敛到更低的泛化误差</li>
<li>随机森林的训练效率常优于Bagging，主要是决策树划分属性时，原始baggin需要对属性全集进行考虑，而rf是针对一个子集</li>
</ul>
<h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><h3 id="学习器结合的好处"><a href="#学习器结合的好处" class="headerlink" title="学习器结合的好处"></a>学习器结合的好处</h3><ul>
<li>统计的角度：假设空间很大时，可能存在多个假设在训练集上达到同等性能，但学习其可能误选导致泛化性能不佳，结合多个学习器可以减小该风险</li>
<li>计算的角度：降低陷入糟糕局部极小点的风险</li>
<li>表示的角度：结合多个学习器可扩大假设空间，对于真实假设在假设空间之外的情形可能学得更好的近似</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul>
<li>平均法(Averaging)<ul>
<li>简单平均法</li>
<li>加权平均法——BMA(贝叶斯模型平均：基于后验概率来为不同模型赋予权重)</li>
</ul>
</li>
<li>投票法(Voting)<ul>
<li>多数投票法<ul>
<li>绝对多数投票法：若某标记得票过半数则预测为该标记，否则拒绝预测（可靠性）</li>
<li>相对多数投票法：预测为得票最多的标记</li>
</ul>
</li>
<li>加权投票法</li>
<li>若按个体学习器输出值类型划分<ul>
<li>硬投票：预测为0/1</li>
<li>软投票：相当于对后验概率的一个估计</li>
</ul>
</li>
</ul>
</li>
<li>学习法<ul>
<li>Stacking:先从初始数据集训练出初级学习器，然后生成一个新的数据集用于训练元学习器，在这个新数据集中，初级学习器的输出被当作样例输入特征，而初始样本的标记仍被当作样例标记；一般使用交叉验证法或留一法来用训练初级学习器未使用的样本来产生元学习器的训练样本</li>
</ul>
</li>
</ul>
<p><em>Notes:关于Stacking</em></p>
<ul>
<li>《机器学习》作者也指出Stacking本身是一种著名的集成方法，且有不少变体和特例，但他这里是作为一种特殊的结合策略看待</li>
<li>关于Stacking的细节详述，个人觉得“<a href="https://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="external">如何在 Kaggle 首战中进入前 10%</a>”一文中阐述的比较透彻，以一幅图来说说明5折Stacking的过程</li>
<li>推荐一个Python的实现了Stacking集成的库<a href="https://github.com/rasbt/mlxtend" target="_blank" rel="external">mlxtend</a></li>
</ul>
<p><img src="/materials/img/ensemble/stacking.jpg" alt="stacking"><br>原作者举了一个5折stacking的例子，基本方法是，</p>
<ul>
<li>每一折取训练集80%的数据训练一个基模型并对剩下的20%的数据进行预测，同时将该模型对测试集做出预测，保留训练子集的预测结果和测试集的预测结果</li>
<li>将5折的训练子集预测结果结合起来构成第二层元模型的输入特征进行训练得到元分类器</li>
<li>将前面每一折在测试集预测得到的结果<strong>取均值</strong>作为最终元分类器的预测输入(最终的测试数据)，并使用训练好的元分类器在该数据上作出最终预测</li>
</ul>
<p>此外<a href="https://zhuanlan.zhihu.com/p/27424282" target="_blank" rel="external">知乎上的一篇文章</a>还提到</p>
<blockquote>
<p>可以将K个模型对Test Data的预测结果求平均，也可以用所有的Train Data重新训练一个新模型来预测Test Data</p>
</blockquote>
<h2 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h2><h3 id="误差-分歧分解"><a href="#误差-分歧分解" class="headerlink" title="误差-分歧分解"></a>误差-分歧分解</h3><ul>
<li>集成学习“好而不同”的理论分析，见《机器学习》P185~186</li>
<li>寻找集成泛化误差、个体学习器泛化误差、个体学习器间的分歧三者之间的关系</li>
</ul>
<h3 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h3><blockquote>
<p>多样性度量是用于度量集成中个体分类器的多样性，即估算个体学习器的多样化程度，典型做法是考虑个体分类器的两两相似/不相似性</p>
</blockquote>
<p>度量方法</p>
<ul>
<li>不合度量</li>
<li>相关系数</li>
<li>Q-统计量</li>
<li>k-统计量</li>
</ul>
<h3 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h3><p>如何增强多样性？——在学习过程中引入随机性</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>数据样本扰动</th>
<th>输入属性扰动</th>
<th>输出表示扰动</th>
<th>算法参数扰动</th>
</tr>
</thead>
<tbody>
<tr>
<td>思路</td>
<td>给定初始数据集，可从中产生不同的数据子集，再利用不同的数据子集训练出不同的个体学习器，通常基于采样法</td>
<td>从初始属性集中抽取若干个属性子集、基于每个属性子集训练一个基学习器（如随机子空间算法），最后结合</td>
<td>对输出表示进行操纵，比如<br> 1、对训练样本的类标记稍作变动（翻转法）<br> 2、对输出表示进行转化，如输出调制法<br> 3、将原任务拆解成多个可同时求解的子任务，如Ecoc法</td>
<td>随机设置不同的参数，比如<br>1、负相关法 <br> 2、对参数较少的算法，可将其学习过程中某些环节用其他类似方式替代</td>
</tr>
<tr>
<td>适用</td>
<td>不稳定学习器：决策树、神经网络</td>
<td>包含大量冗余属性的数据</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><em>Notes:</em></p>
<ul>
<li>数据样本扰动中相对的稳定基学习器包括：线性学习器、支持向量机、朴素贝叶斯、k近邻学习器等</li>
<li>对于算法参数扰动，与交叉验证做比较，交叉验证常常是在不同参数组合模型里选择最优参数组合模型，而集成则是将这些不同参数组合的模型结合起来，所以集成学习技术的实际计算开销并不比使用单一学习器大很多</li>
</ul>
<p>参考</p>
<ul>
<li>周志华《机器学习》</li>
<li><a href="https://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="external">kaggle-ensembling-guide</a></li>
<li><a href="https://www.quora.com/What-are-the-differences-between-the-three-commonly-ensemble-learning-techniques-stacking-boosting-and-bagging" target="_blank" rel="external">Bagging, Boosting &amp; Stacking</a></li>
<li><a href="https://stats.stackexchange.com/a/19053/152084" target="_blank" rel="external">stackexchange</a>及评论区</li>
<li><a href="https://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="external">如何在 Kaggle 首战中进入前 10%</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27424282" target="_blank" rel="external">分分钟带你杀入Kaggle Top 1%</a></li>
<li>机器学习技法</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> ensemble </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(八) —— 提升方法]]></title>
      <url>/2017/06/29/boosting/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>在分类问题中，Boosting通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，提高分类的性能。</p>
<p>“三个臭皮匠，顶个诸葛亮”</p>
<p>关于boosting，<strong>机器学习技法</strong>一课中开头举的一个小学生认苹果的例子比较传神，假设给定一堆水果，让一群小学生来识别其中的苹果，逐个的询问小学生根据什么样的规则来认为一个水果是苹果，比如学生A认为形状为圆的是苹果，第二个学生认为颜色为红的为水果等等，逐一询问学生的过程中，每问一个学生之后，按照他的规则对当前水果分类，记录其中的错分的水果然后让下一个同学重点根据这些被错分的水果来找找规则，这样一步一步的最后全班同学得到一个较为完备的规则来判定出苹果，这个过程中单个学生扮演的较色就是基分类器，比如常用的决策树桩，类似某一维的的感知机，在该维度将空间一分为二的划分样本，而教师的角色则是在这一过程中不断引导学生关注被上一个学生错分的样本来做出判定规则，并最终得出一个较为完备的输出结果</p>
</blockquote>
<p><strong>关键词：强可学习、弱可学习、PAC(probably approximately correct)</strong></p>
<p>由于发现弱学习算法通常比发现强学习算法容易，所以Boosting试图解决这么一个问题：“如果已经发现了‘弱学习算法’，那么能否将它提升为‘强学习算法’？”<br><a id="more"></a></p>
<blockquote>
<p>提升方法就是从弱学习算法出发，反复学习(改变训练数据的权值分布)，得到一系列弱分类器，然后组合这些弱分类器，构成一个强分类器；</p>
</blockquote>
<p>提升方法需要解决的两个问题：</p>
<ul>
<li>在每一轮训练中，如何改变训练数据的权值/概率分布？</li>
<li>在得到一系列弱分类器后，如何将弱分类器组合成一个强分类器？</li>
</ul>
<h2 id="AdaBoost——Adaptive-Boosting"><a href="#AdaBoost——Adaptive-Boosting" class="headerlink" title="AdaBoost——Adaptive Boosting"></a>AdaBoost——Adaptive Boosting</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>针对提升方法要解决的两个问题，AdaBoost的做法是这样的:（两个‘权值’）</p>
<ul>
<li>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值。（让被错误分类的样本得到当前弱分类器更多的‘关注’）</li>
<li>AdaBoost采取加权多数表决的方法来组合弱分类器：加大分类误差率小的弱分类器的权值</li>
</ul>
<p><em>Notes:由上述基本思路可以发现，对于AdaBoost算法而言，其中最核心的部分是<strong>两个权值</strong>的求解，一个是每一轮用于训练基分类器的训练数据的样本的权值分布，而另一个则是最终组合各个基分类器时代表各个基分类器的‘话语权’的分类器的权重，而这两者都跟每一轮的基分类器的分类错误、训练误差相关；样本的权值分布根据前一轮基分类器的错误来进行调整，是一种‘弥补前人错误’的体现，而基分类器的权重则是受到每一轮训练的基分类器在该轮的分类误差影响，分类误差越小的基分类器自然可信度越高，所以最终我们组合基分类器时给它赋予的‘话语权’越大。</em></p>
<h3 id="算法-AdaBoost"><a href="#算法-AdaBoost" class="headerlink" title="算法-AdaBoost"></a>算法-AdaBoost</h3><blockquote>
<ul>
<li>输入：<ul>
<li>训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $，其中$x_i \in R^n, y_i \in \lbrace -1, +1 \rbrace$;</li>
<li>弱学习算法</li>
</ul>
</li>
<li>输出：最终分类器$G(x)$</li>
<li>(1) 初始化训练样本的权值分布为<br>$$D_1=(w_{11},     w_{12},…,w_{1N}),         w_{1i}=\frac{1}{N}, i=1,2,…,N$$<br>即各个训练样本的权重均等</li>
<li>(2) 对$m=1,2,…,M,  m$表示训练轮数(亦即基分类器个数，因为每一轮产生一个基分类器)：<ul>
<li>使用具有权值分布$D_m$的训练数据集学习，得到基本分类器$G_m(x)$</li>
<li>计算$G_m(x)$在训练数据集上的分类错误率：<br>$$e_m=P(G_m(x_i) \neq y_i)=\sum_{i=1}^Nw_{mi}I(G_m(x_i) \neq y_i)$$<br>即(分类错误的样本$\times$该样本的权重)之和</li>
<li>计算最终基分类器在组合分类器中的权重值<br>$$\alpha_m=\frac{1}{2}log\frac{1-e_m}{e_m} $$<br>为什么是这么个值，周志华的西瓜书上有对应推导，也可以参考<a href="https://en.wikipedia.org/wiki/AdaBoost#Derivation" target="_blank" rel="external">维基百科的推导部分</a>(寻找最小化整体误差的基学习器$k_m$&lt;=&gt;寻找最小化权重分类错误率之和的$k_m$=&gt;对于确定的$k_m$在对原式求取对$\alpha_m$的导数并令其为0求得极小值)</li>
<li>更新训练数据集的权值分布<br>$$D_{m+1}=(w_{m+1,1},…,w_{m+1,i},…,w_{m+1,N})$$<br>如果$G_m(x_i)=y_i$那么$$w_{m+1,i}=\frac{w_{m,i}}{Z_m}e^{-\alpha_m}$$否则$$w_{m+1,i}=\frac{w_{m,i}}{Z_m}e^{\alpha_m}$$</li>
</ul>
</li>
</ul>
<p>如果将权重更新简化表示就是(因为$y_i,G_m(x_i) \in \lbrace -1, +1 \rbrace$,根据其异同可以决定指数部分的符号)<br>$$w_{m+1,i}=\frac{w_{m,i}}{Z_m}exp(-\alpha_my_iG_m(x_i))$$<br>其中$Z_m$是规范化因子，用来使权重分布成为一个概率分布(这里就可以看到错分样本的权重被调大)<br>$$Z_m=\sum_{i=1}^Nw_{m,i}exp(-\alpha_my_iG_m(x_i))$$</p>
<ul>
<li>(3) 构建基本分类器的线性组合<br>$$f(x)=\sum_{m=1}^M\alpha_mG_m(x)$$<br>得到最终分类器<br>$$G(x)=sign(f(x))=sign(\sum_{m=1}^M\alpha_mG_m(x))$$</li>
</ul>
</blockquote>
<p><em>Notes:</em></p>
<ul>
<li>关于权值分布更新的计算：由于$Z_m$是未规范化的权值分布更新结果之和，所以一般先通过<br>$$\acute{w_{m+1,i}}=w_{m,i}exp(-\alpha_my_iG_m(x_i))$$<br>进一步由$$Z_m=\sum_{i=1}^N\acute{w_{m+1,i}}$$求得$Z_m$，最后将$\acute{w_{m+1,i}}$均除以$Z_m$即得到$w_{m+1,i}$的值，其实本质上就是一个规范化的过程</li>
<li>训练结束的条件：一般是基分类器的组合分类器分类错误率足够小或者达到指定的基分类器数目（亦即迭代次数m）时即停止迭代训练</li>
<li>由上述算法可知AdaBoost的两大特点<ul>
<li>不改变所给的训练数据，而不断改变训练数据权值的分布，使得训练数据在基本分类器的学习中起不同的作用（与bagging的区别）</li>
<li>利用基本分类器的线性组合构建最终的分类器（与GBDT的区别）</li>
</ul>
</li>
<li>$f(x)$的符号决定实例的类别，其绝对值表示分类的确信度</li>
<li>关于上述算法流程的熟悉，可以通过书上P140简单的例子或者《机器学习实战》一书中对应AdaBoost实现的部分来感受一下</li>
<li>从整个算法的流程结合维基百科的推导可以看出算法的核心部分，即一再强调的两个权重$\alpha_m,w_m$，引用维基百科的话来说<blockquote>
<p>每一轮，我们通过最小化权重损失和$\sum_{y_i\neq G_m(x_i)}w_{m,i}$来选择最佳的基分类器$G_m$,并得到该基分类器对应的错误率$e_m=\sum_{i=1}^Nw_{mi}I(G_m(x_i) \neq y_i)$，用计算得到的错误率可以计算基分类器在最终的模型里的权重$\alpha_m=\frac{1}{2}log\frac{1-e_m}{e_m}$,最后根据该权重改善当前模型并更新下一轮的基分类器的权重分布$w_m$</p>
</blockquote>
</li>
<li>更行权重分布的计算过程也可以从样本的正反例比的角度来看，第$t+1$次调整权重分布的目的是为了学的一个与第$t$次不一样的模型，避免犯同样的错误，所以需要根据第$t$次的分类错误来重新调整样本分布，使正负样本权重和均衡(一般而言第$t$次训练后的分类错误的样本数要少于正确的样本数，其实这个过程也就是加大分错样本的权重)，具体而言就是按照正负样本比例调整，比如分类错误样本数为$p$,分类正确样本数为$q$错误率为$e_m=\frac{p}{p+q}$，则在第$t+1$轮需要将负样本权重调整为$w_t\times q$对应的正确样本权重调整为$w_t\times p$使两者平衡，也就等价于对错误样本$w_{t+1}=w_t\times (1-e_m)$,对正确样本$w_{t+1}=w_t\times (e_m)$,进一步可以定义变量$\lambda=\sqrt{\frac{1-e_m}{e_m}}$,于是对错误样本$w_{t+1}=w_t\times \lambda$,对正确样本$w_{t+1}=w_t \div \lambda$,(加根号的做法还是在机器学习技法上看到，另外的《统计学习方法》、《机器学习》上面都没有加根号)这么做使其具有更好的物理意义，具体的，如果分类错误率不超过$\frac{1}{2}$则$\lambda&gt;1$也就表明更加关足上一轮被错分样本，而减小正确分类的样本的关注度，同时也表明基分类器应该优于随机猜测</li>
<li>进一步地，对于$\alpha$即各个基分类器最终在加和模型里的权重而言，其创作者对取值设置为$\alpha_t=ln(\lambda)$，其物理意义就是在极限情况下随机猜测的话，分类错误率为0.5而对应的$\lambda=1$所以$\alpha=0$也就表明对于乱猜的分类器的分类结果最后不计入整体分类器，而另外对于分类错误率为0的情形，对应的$\alpha=\infty$也就是说如果一个单一的分类器就足以分类了，那么就用这一个就够了；此外，按照林轩田的说法，算法中基分类器和$\alpha_t$的计算是<strong>on the fly</strong>的做法，也就是每计算一个基分类器也就可以计算对应的$\alpha_t$，最后就得到一系列基分类器和对应的权重值</li>
</ul>
<p>简而言之就是每轮一方面通过最小化基分类器的权重损失和来选择该轮的基分类器以及最终的权重，另一方面据该轮表现来为修正当前模型的错误而更新样本权重分布</p>
<h3 id="训练误差分析"><a href="#训练误差分析" class="headerlink" title="训练误差分析"></a>训练误差分析</h3><p>即证明</p>
<blockquote>
<ul>
<li>AdaBoost能在学习过程中不断减少训练误差，即在训练数据集上的分类误差率（关于这一点进一步引出了AdaBoost是否不会过拟合的<a href="http://blog.sina.com.cn/s/blog_6ae183910101chcg.html" target="_blank" rel="external">讨论</a>）</li>
<li>AdaBoost的训练误差是以指数速率下降的</li>
</ul>
</blockquote>
<p><img src="/materials/img/AdaBoost/error_analysis1.jpg" alt="error_analysis1"><br><img src="/materials/img/AdaBoost/error_analysis2.jpg" alt="error_analysis2"><br><img src="/materials/img/AdaBoost/error_analysis3.jpg" alt="error_analysis3"></p>
<p>由上面两个定理，可以得到推论</p>
<blockquote>
<p>如果存在$\gamma&gt;0$,对所有$m$有$\gamma_m \leq \gamma$【原书这里是$\gamma_m \geq \gamma$，但个人感觉应该是$\leq$才能推得$exp(-2\sum_{m=1}^M \gamma_m^2) \leq exp(-2M\gamma^2)$】,则<br>$$\frac{1}{N}\sum_{i=1}^NI(G(x_i) \neq y_i) \leq exp(-2M\gamma^2)$$</p>
</blockquote>
<p>因为<br>$$\frac{1}{N}\sum_{i=1}^NI(G(x_i) \neq y_i) \leq \prod_mZ_m \leq exp(-2\sum_{m=1}^M \gamma_m^2) \leq exp(-2M\gamma^2)$$<br>这也表明在此条件下AdaBoost的训练误差是以指数速率速率下降的</p>
<p><em>Notes:</em></p>
<ul>
<li>AdaBoost算法不需要知道下界$\gamma$</li>
<li>AdaBoost具有适应性，即它能适应弱分类器各自的训练误差率，这也是它的名字Adaptive Boosting的由来</li>
</ul>
<h3 id="前向分步算法"><a href="#前向分步算法" class="headerlink" title="前向分步算法"></a>前向分步算法</h3><blockquote>
<p>可以认为AdaBoost算法是模型为加法模型，损失函数为指数函数，学习算法为前向分步算法时的二类分类学习方法。</p>
</blockquote>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>假设现在在给定训练数据和损失函数$L(y, f(x))$的条件下，要学习一个加法模型<br>$$f(x)=\sum_{m=1}^{M}\beta_mb(x;\gamma_m)$$<br>其中$b(x;\gamma_m)$为基函数，$\gamma_m$为基函数的参数，$\beta_m$为基函数的系数</li>
<li>学习该加法模型的问题可以转化为经验风险极小化即损失函数极小化问题<br>$$min_{\beta_m, \gamma_m}\sum_{i=1}^{N}L(y_i,\sum_{m=1}^{M}\beta_mb(x_i;\gamma_m))$$</li>
<li>而上述问题是一个<strong>需要同时求解从$m=1$到$M$所有参数$\beta_m, \gamma_m$的优化问题</strong>，较为复杂；</li>
<li>而前向分步算法的思想就是，针对该加法模型，从前到后，<strong>每一步仅学习一个基函数及其参数，逐步逼近上述优化目标函数式</strong>，如此简化优化的复杂度，即每一步只需优化损失函数<br>$$min_{\beta, \gamma}\sum_{i=1}^{N}L(y_i,\beta b(x_i;\gamma))$$</li>
</ul>
<h4 id="算法-加法模型-前向分步算法"><a href="#算法-加法模型-前向分步算法" class="headerlink" title="算法-加法模型+前向分步算法"></a>算法-加法模型+前向分步算法</h4><blockquote>
<ul>
<li>输入：<ul>
<li>训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $</li>
<li>损失函数$L(y, f(x))$</li>
<li>基函数集$b(x;\gamma)$</li>
</ul>
</li>
<li>输出：加法模型$f(x)$</li>
<li>(1) 初始化$f_0(x)=0$</li>
<li>(2) 对$m=1,2,…,M$<ul>
<li>极小化损失函数<br>$$(\beta_m, \gamma_m)=argmin_{\beta, \gamma}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+\beta b(x_i;\gamma))$$得到参数$\beta_m, \gamma_m$</li>
<li>更新<br>$$f_m(x)=f_{m-1}(x)+\beta_m b(x;\gamma_m)$$</li>
</ul>
</li>
<li>(3) 得到加法模型<br>$$f(x)=f_M(x)=\sum_{m=1}^M\beta_mb(x;\gamma_m)$$</li>
</ul>
</blockquote>
<p><em>Notes:由上述算法的第(2)部分可以看到，前向分布算法每次在上一个基函数得到的累加模型基础上通过极小化当前基函数与累加模型之和的损失函数值从而得到当前基函数及其参数，然后累加到前面得到的加法模型上，这样一步一步地逼近想要优化的目标函数，最终会得到一个近似的加法模型</em></p>
<h4 id="前向分步算法与AdaBoost"><a href="#前向分步算法与AdaBoost" class="headerlink" title="前向分步算法与AdaBoost"></a>前向分步算法与AdaBoost</h4><p><img src="/materials/img/AdaBoost/forward_step_alg1.jpg" alt="forward_step_alg1"><br><img src="/materials/img/AdaBoost/forward_step_alg2.jpg" alt="forward_step_alg2"><br><img src="/materials/img/AdaBoost/forward_step_alg3.jpg" alt="forward_step_alg3"><br>最后，来看一下每一轮样本权值的更新<br>$$f_m(x)=f_{m-1}(x)+\alpha_mG_m(x)$$<br>因为$\overline{w_{mi}}=exp(-y_if_{m-1}(x_i))$，对两边乘上$-y_i$并取指数得到<br>$$\overline{w_{m+1,i}}=\overline{w_{mi}}exp(-y_i\alpha_mG_m(x))$$<br>对比AdaBoost中的权值更新步骤<br>$$w_{m+1,i}=\frac{w_{m,i}}{Z_m}exp(-\alpha_my_iG_m(x_i))$$<br>仅相差规范化因子，因而等价</p>
<p><em>Notes:</em></p>
<ul>
<li>对于原书中证明求$\alpha_m^*$的最后$$e_m=\frac{\sum_{i=1}^N\overline{w_{mi}}I(y_i \neq G_m(x_i))}{\sum_{i=1}^N\overline{w_{mi}}}=\sum_{i=1}^Nw_{mi}I(y_i \neq G_m(x_i))$$中的后半部分是怎么来的实在理解不了，猜测可能跟AdaBoost训练误差界中的定理以及后面的$\overline{w_{m+1,i}}=\overline{w_{mi}}exp(-y_i\alpha_mG_m(x))$有关</li>
<li>推导的核心还是基分类器在最终分类器中的权重$\alpha_m$以及样本权重分布这两项的推导</li>
<li>为什么是指数损失函数？<em>参考周志华《机器学习》一书P174</em>(不过这里也只是逆向从如果是指数损失函数的角度来分析为什么可以用指数损失函数，并没有说明起源，比如为什么不用合页损失函数？)<ul>
<li>由最终得到的基分类器的线性组合$f(x)=\sum_{m=1}^M\alpha_mG_m(x)$</li>
<li>若$f(x)$能令指数损失函数最小化，即最小化$L(y,f(x))=e^{-yf(x)}$</li>
<li>对其求偏导得$$\frac{d(L(y,f(x)))}{df(x)}=-e^{f(x)}P(y=1|x)+e^{f(x)}P(y=-1|x)$$</li>
<li>令其为0得到$$f(x)=\frac{1}{2}ln\frac{P(y=1|x)}{P(y=-1|x)}$$</li>
<li>于是最终分类器$$sign(f(x))=sign(\frac{1}{2}ln\frac{P(y=1|x)}{P(y=-1|x)})$$</li>
<li>即$$sign(f(x))=1，如果P(y=1|x)&gt;P(y=-1|x)$$,而$$sign(f(x))=-1，如果P(y=-1|x)&gt;P(y=1|x)$$</li>
<li>也就表示，$sign(f(x))$达到了<em>贝叶斯最优错误率</em>，即<strong>若指数损失函数最小化则分类错误率也将最小化</strong>，这说明<ul>
<li>指数损失函数是分类任务原本0/1损失函数的一致的替代损失函数；</li>
<li>由于该替代函数有更好的数学性质（比如连续可微），因此我们用其替代0/1损失函数作为优化目标（类似的这种情况在SVM里用合页损失函数代替0-1损失函数也出现过）</li>
</ul>
</li>
<li>更多讨论也可以看看<a href="https://www.zhihu.com/question/48558534?q=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95AdaBoost%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%9D%A5%E4%BD%9C%E4%B8%BA%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F" target="_blank" rel="external">知乎</a>，似乎大部分观点认为AdaBoost=boosting+指数损失函数</li>
</ul>
</li>
<li>AdaBoost也可以从优化权值分布之和的角度进行推导，最后看作是“steepest descent with approximate functional gradient”,参见机器学习技法11.4</li>
</ul>
<h2 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul>
<li>提升树是以分类树或回归树为基本分类器的提升方法</li>
<li>以决策树为基函数的提升方法称为提升树（一般是用决策树桩(decision stump)即由一个根结点直接连接两个叶节点的简单决策树）</li>
<li>提升树模型可以表示为决策树的加法模型<br>$$f_M(x)=\sum_{m=1}^{M}T(x;\varTheta_m)$$<br>其中$T(x;\varTheta_m)$表示决策树，$\varTheta_m$为决策树的参数，$M$为树的个数</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>不同问题的提升树学习算法区别在于使用的损失函数不同</p>
<ul>
<li>回归树：平方误差（拟合残差）</li>
<li>分类树：指数损失函数</li>
<li>一般决策树：一般损失函数</li>
</ul>
</li>
<li><p>回归问题的提升树算法<br>前向分步算法</p>
</li>
</ul>
<blockquote>
<ul>
<li>输入：训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace ,x_i \in R^n, y_i \in R $</li>
<li>输出：提升树$f_M(x)$</li>
<li>(1) 初始化$f_0(x)=0$</li>
<li>(2) 对$m=1,2,…,M$<ul>
<li>计算残差$r_{mi}=y_i - f_{m-1}(x_i),　i=1,2,…,N$</li>
<li>拟合残差$r_{mi}$学习一个回归树，得到$T(x;\varTheta_m)$</li>
<li>更新$f_m(x)=f_{m-1}(x)+T(x;\varTheta_m)$</li>
</ul>
</li>
<li>(3) 得到回归问题提升树<br>$$f_M(x)=\sum_{m=1}^{M}T(x;\varTheta_m)$$</li>
</ul>
</blockquote>
<p><em>Notes:对于上述算法的过程理解可以参照原书P149的例子来感受一下，需要回顾决策树（主要是CART算法）的知识点</em></p>
<ul>
<li>除了一开始初始化以外，每一步都是拟合上一轮得到的加法模型的残差来寻找最佳切分点并构建决策树桩，然后将该决策树桩累加到加法模型上作为当前模型并计算平方损失误差</li>
<li>当当前模型的平方损失误差降到某一阈值时则当前模型就是最终输出的模型。</li>
</ul>
<h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><blockquote>
<p>提升树利用加法模型与前向分步算法实现学习的优化过程，当损失函数为平方损失（回归）和指数损失函数（分类）时，每一步的优化较为简单，但是<strong>对一般损失函数而言，往往每一步的优化并不容易</strong>，而梯度提升算法则是利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值$$-\left[\frac{\partial L(y,f(x_i)}{\partial f(x_i)} \right]_{f(x)=f_{m-1}(x)}$$作为回归问题提升树算法中的残差的近似值，拟合一个回归树</p>
</blockquote>
<h4 id="算法（回归树）"><a href="#算法（回归树）" class="headerlink" title="算法（回归树）"></a>算法（回归树）</h4><blockquote>
<ul>
<li>输入：<ul>
<li>训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace ,x_i \in R^n, y_i \in R $</li>
<li>损失函数$L(y,f(x))$</li>
</ul>
</li>
<li>输出：回归树$\widehat{f}(x)$</li>
<li>(1) 初始化$$f_0(x)=argmin_c\sum_{i=1}^NL(y_i,c)$$来估计使损失函数极小化的常数值，它是只有一个根节点的树</li>
<li>(2) 对$m=1,2,…,M$<ul>
<li>对$i=1,2,…,N$,计算$$r_{mi}=-\left[\frac{\partial L(y,f(x_i)}{\partial f(x_i)} \right]_{f(x)=f_{m-1}(x)}$$即损失函数的<strong>负梯度</strong>在当前模型的值，将它作为残差的估计（对于平方损失函数，它就是通常所说的残差；而对于一般损失函数，它就是残差的近似值）</li>
<li>对$r_{mi}$拟合一个回归树，得到第$m$棵树的叶节点区域$R_{mj}, j=1,2,…,J$</li>
<li>对$j=1,2,…,J$,计算$$c_{mj}=argmin_c\sum_{x_i \in R_{mj}}L(y_i, f_{m-1}(x_i)+c)$$即利用线性搜索估计叶节点区域的值，使损失函数极小化</li>
<li>更新回归树$$f_m(x)=f_{m-1}(x)+\sum_{j=1}^Jc_{mj}I(x \in R_{mj})$$</li>
</ul>
</li>
<li>(3) 得到最终的回归树$$\widehat{f}(x)=f_M(x)=\sum_{m=1}^M\sum_{j=1}^Jc_{mj}I(x \in R_{mj})$$</li>
</ul>
</blockquote>
<p><em>Notes:梯度提升树（回归树）的算法与原始的提升树（回归树）算法的核心区别主要在于残差计算这里，由于原始的回归树指定了平方损失函数所以可以直接计算残差，而梯度提升树针对一般损失函数，所以采用负梯度来近似求解残差。</em></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于《机器学习实战》一书的第7章内容用决策树桩实现了简单的AdaBoost算法</p>
<ul>
<li>简要叙述了Boosting及其与Bagging的异同</li>
<li>基于决策树桩实现了简单的AdaBoost算法</li>
<li>应用所实现的AdaBoost分类器对马疝病数据集进行分类</li>
<li>此外简要探讨了非平衡数据集的一些问题，包括<ul>
<li>精确率、召回率</li>
<li>过采样、欠采样</li>
<li>roc-auc的实现<br>原始代码可以参考我的<a href="https://github.com/LancelotHolmes/MLinAction/blob/master/AdaBoost.ipynb" target="_blank" rel="external">github</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《统计学习方法》</li>
<li>《机器学习》</li>
<li>《机器学习实战》</li>
<li><a href="https://en.wikipedia.org/wiki/AdaBoost#Derivation" target="_blank" rel="external">维基百科</a></li>
<li><a href="https://www.zhihu.com/question/48558534?q=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95AdaBoost%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%9D%A5%E4%BD%9C%E4%B8%BA%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%9F" target="_blank" rel="external">知乎</a></li>
<li>林轩田《机器学习技法》</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> decision tree </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础算法小记]]></title>
      <url>/2017/06/27/basic-algorithm/</url>
      <content type="html"><![CDATA[<p><em>本文大部分内容基于《算法》4th一书内容，部分补充来自于网络或者其他书籍</em></p>
<h2 id="查找类"><a href="#查找类" class="headerlink" title="查找类"></a>查找类</h2><h3 id="二分查找【重点】"><a href="#二分查找【重点】" class="headerlink" title="二分查找【重点】"></a>二分查找【重点】</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>在查找时，通过比较中位数与所查找值的大小关系，若找到则返回，若查找失败则相应的调整查找数据集的最高位/最低位的位置来使每次缩减查找范围为原始的一半<br><a id="more"></a></p>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li><p>循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">//二分查找适用于有序的数组，另外也有一些延伸用法，见剑指offer</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length&lt;=<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">		<span class="comment">//为什么是length-1,因为查找也是从第0位开始的</span></div><div class="line">		<span class="keyword">int</span> high = num.length-<span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> pos = -<span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(low &lt;= high)&#123;<span class="comment">//注意这里的取等与数组的元素奇偶个数、取边界值、边界以外的值相关，小心</span></div><div class="line">			<span class="keyword">int</span> mid = (low+high) &gt;&gt; <span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(num[mid] == key)&#123;</div><div class="line">				pos = mid;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &gt; key)&#123;</div><div class="line">				high = mid - <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				low = mid + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pos;</div><div class="line">		<span class="comment">//如果是需要在数组中不存在该键时要求返回插入的位置，则修改如下</span></div><div class="line"><span class="comment">//		return low;</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> (num==<span class="keyword">null</span>||num.length==<span class="number">0</span>)?-<span class="number">1</span>:binarySearchRecursive(num,key,<span class="number">0</span>,num.length-<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> key, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(begin&gt;end)&#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">			<span class="comment">//如果是需要在数组中不存在该键时要求返回插入的位置，则修改如下</span></div><div class="line"><span class="comment">//			return begin;</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> mid=(begin+end)&gt;&gt;<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(num[mid]==key)&#123;</div><div class="line">			<span class="keyword">return</span> mid;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num[mid]&gt;key)&#123;</div><div class="line">			<span class="keyword">return</span> binarySearchRecursive(num,key,begin,mid-<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> binarySearchRecursive(num,key,mid+<span class="number">1</span>,end);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</div><div class="line"><span class="comment">//		int[] num = &#123;&#125;;</span></div><div class="line">		System.out.println(binarySearch(num, <span class="number">9</span>));</div><div class="line">		System.out.println(binarySearchRecursive(num, <span class="number">9</span>));</div><div class="line">		</div><div class="line">		System.out.println(binarySearch(num, <span class="number">11</span>));</div><div class="line">		System.out.println(binarySearchRecursive(num, <span class="number">0</span>));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>在$N$个键的有序数组中进行二分查找最多需要$logN+1$次比较（无论是否成功）</strong>，即二分查找所需时间在对数范围之内。</p>
<h3 id="附：符号表（查找）的各种实现的优缺点"><a href="#附：符号表（查找）的各种实现的优缺点" class="headerlink" title="附：符号表（查找）的各种实现的优缺点"></a>附：符号表（查找）的各种实现的优缺点</h3><ul>
<li>符号表的各种实现的优缺点</li>
</ul>
<table>
<thead>
<tr>
<th>使用的数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>链表（顺序查找）</td>
<td>适用于小型问题</td>
<td>对于大型数据集很慢</td>
</tr>
<tr>
<td>有序数组(二分查找)</td>
<td>最优的查找效率和空间需求，能够进行有序性相关的操作</td>
<td>插入操作很慢</td>
</tr>
<tr>
<td>二叉查找树</td>
<td>实现简单，能够进行有序性相关的操作</td>
<td>没有性能上界的保证，此外链接需要额外的空间</td>
</tr>
<tr>
<td>平衡二叉查找树（红黑树实现）</td>
<td>最优的查找和插入效率，能够进行有序性相关的操作</td>
<td>链接需要额外的空间</td>
</tr>
<tr>
<td>散列表</td>
<td>能够快速的查找和插入常见类型的数据</td>
<td>需要计算各种类型的数据的散列，无法进行有序性相关的操作，此外链接和空结点需要额外的空间</td>
</tr>
</tbody>
</table>
<p><em>来源于《算法》一书中3.1.7</em></p>
<ul>
<li>各种符号表实现的渐进性能总结</li>
</ul>
<table>
<thead>
<tr>
<th>算法（数据结构）</th>
<th>查找（最坏情况）</th>
<th>插入（最坏情况）</th>
<th>查找命中（平均情况）</th>
<th>插入（平均情况）</th>
<th>关键接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查询（无序链表）</td>
<td>N</td>
<td>N</td>
<td>N/2</td>
<td>N</td>
<td>equals()</td>
</tr>
<tr>
<td>二分查找（有序数组）</td>
<td>$lgN$</td>
<td>N</td>
<td>$lgN$</td>
<td>N/2</td>
<td>compareTo()</td>
</tr>
<tr>
<td>二叉树查找（二叉查找树）</td>
<td>N</td>
<td>N</td>
<td>1.39$lgN$</td>
<td>1.39$lgN$</td>
<td>compareTo()</td>
</tr>
<tr>
<td>2-3树查找（红黑树）</td>
<td>2$lgN$</td>
<td>2$lgN$</td>
<td>1.00$lgN$</td>
<td>1.00$lgN$</td>
<td>compareTo()</td>
</tr>
<tr>
<td>拉链法（链表数组）</td>
<td>&lt;$lgN$</td>
<td>&lt;$lgN$</td>
<td>N/2M</td>
<td>N/M</td>
<td>equals()<br> hashCode()</td>
</tr>
<tr>
<td>线性探测法（并行数组）</td>
<td>c$lgN$</td>
<td>c$lgN$</td>
<td>&lt;1.5</td>
<td>&lt;2.5</td>
<td>equals()<br> hashCode()</td>
</tr>
</tbody>
</table>
<ul>
<li>N表示N次插入之后，M表示哈希表中的键的个数</li>
<li>Java的<code>java.util.TreeMap</code>和<code>java.util.HashMap</code>分别是基于红黑树和拉链法的散列表的符号表实现</li>
</ul>
<p><em>来源于《算法》一书中3.5.1</em></p>
<h2 id="排序类"><a href="#排序类" class="headerlink" title="排序类"></a>排序类</h2><h3 id="快速排序【重点】"><a href="#快速排序【重点】" class="headerlink" title="快速排序【重点】"></a>快速排序【重点】</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>分治+双指针：核心在于切分(partition)，即首先根据数组中的某一个元素(一般取当前首位元素)，将数组进行切分，最终目的是使该元素左侧元素均不大于该元素，该元素右侧元素均不小于该元素（通过双指针将左侧指针指向较大元素与右侧指针指向较小元素交换实现）；然后进一步递归地对左右子数组调用切分方法直到最终数组有序。</p>
<p><em>Notes:双指针i,j,<strong>保证i左侧元素均不超过pivot,而j右侧元素均不小于pivot</strong>，最终i,j相遇的地方即为pivot的位置，所以重点不在于pivot的选取，比如还可以取<a href="http://www.algolist.net/Algorithms/Sorting/Quicksort" target="_blank" rel="external">中间位置</a>或者任意位置，只是需要选定一个pivot来开始进行划分，每次划分都保证了双指针左右的元素的大小符合要求，然后递归的对双指针左右的元素进行切分处理</em></p>
<h4 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li><p>快速排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	shuffle(nums);	</div><div class="line">	quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(low&gt;=high)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> j=partition(nums,low,high);</div><div class="line">	quickSort(nums,low,j-<span class="number">1</span>);</div><div class="line">	quickSort(nums,j+<span class="number">1</span>,high);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> pivot=nums[low];	<span class="comment">//设置分割值为首位的元素值</span></div><div class="line">	<span class="keyword">int</span> i=low+<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j=high;</div><div class="line">	<span class="keyword">while</span>(i&lt;=j)&#123;</div><div class="line">		<span class="keyword">while</span>(i&lt;=j &amp;&amp; nums[i]&lt;pivot)&#123;	<span class="comment">//找到左侧超过pivot的第一个元素</span></div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(i&lt;=j &amp;&amp; nums[j]&gt;pivot)&#123;	<span class="comment">//找到右侧小于pivot的第一个元素</span></div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i&lt;=j)&#123;	<span class="comment">//交换两边的元素</span></div><div class="line">			<span class="keyword">int</span> temp=nums[i];</div><div class="line">			nums[i]=nums[j];</div><div class="line">			nums[j]=temp;</div><div class="line">			i++;</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//最后将pivot放置到“中间”位置达成a[low..j-1]&lt;=a[j]&lt;=a[j+1..high]</span></div><div class="line">	nums[low]=nums[j];</div><div class="line">	nums[j]=pivot;</div><div class="line">	<span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试及辅助函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">		nums[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;			</div><div class="line">		System.out.print(nums[i]+<span class="string">" "</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">		list.add(nums[i]);</div><div class="line">	&#125;</div><div class="line">	Collections.shuffle(list);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">		nums[i]=list.get(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>优点：<ul>
<li>实现简单，适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多；</li>
<li>原地排序（只需要一个很小的辅助栈）</li>
<li>将长度为N的数组排序所需时间和$NlgN$成正比</li>
<li>性能优势<ul>
<li>内循环简洁，只涉及元素比较，而像希尔排序、归并排序还涉及元素的移动</li>
<li>比较次数很少</li>
</ul>
</li>
</ul>
</li>
<li>缺点：切分不平衡时程序可能会变得极为低效–&gt; 这也是在快排中一开始对数组进行随机化处理（shuffle()）的原因，目的是为了降低这种情况出现的概率</li>
</ul>
<h4 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h4><ul>
<li>对于小数组切换到插入排序，修改<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(low&gt;=high)&#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(low+M&gt;=high)&#123;	<span class="comment">//M为转换参数，与系统相关，一般取5~15之间</span></div><div class="line">	insertSort(nums,low,high);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>三取样切分：使用数组的一部分元素的中位数来切分数组，代价是需要计算中位数</li>
<li>熵最优的排序——三向切分的快排<ul>
<li>针对存在大量重复元素的数组，可将性能提升到线性级别</li>
<li>将数组划分为三个部分，分别对应于小于、等于和大于切分元素的数组元素<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick3waySort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(high&lt;=low)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> lt=low,i=low+<span class="number">1</span>,gt=high;</div><div class="line">	<span class="keyword">int</span> pivot=nums[low];</div><div class="line">	<span class="keyword">while</span>(i&lt;=gt)&#123;	<span class="comment">//保证nums[low..lt-1]&lt;pivot=nums[lt..gt]&lt;nums[gt+1..high]</span></div><div class="line">		<span class="keyword">if</span>(nums[i]&lt;pivot)&#123;		<span class="comment">//而i在lt与gt之间，循环的过程就是不断调整i与gt之间的元素</span></div><div class="line">			exchange(nums,lt++,i++);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;pivot)&#123;</div><div class="line">			exchange(nums,i,gt--);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	quick3waySort(nums,low,lt-<span class="number">1</span>);</div><div class="line">	quick3waySort(nums,gt+<span class="number">1</span>,high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="归并排序【重点】"><a href="#归并排序【重点】" class="headerlink" title="归并排序【重点】"></a>归并排序【重点】</h3><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><ul>
<li>额外数组空间+双指针<ul>
<li>先将原始数组复制一份</li>
<li>分别遍历两个子数组，遍历原始数组，逐个比较指针指向的元素和移动指针，将较小的元素复制到原始的数组，若一个子数组指向最后，则将另一个子数组元素逐个复制到原数组中</li>
</ul>
</li>
<li>Java实现<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</div><div class="line">		copy[k]=nums[k];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> i=low;</div><div class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</div><div class="line">		<span class="keyword">if</span>(i&gt;mid)&#123;<span class="comment">//左子数组元素用尽</span></div><div class="line">			nums[k]=copy[j++];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;high)&#123;<span class="comment">//左子数组元素用尽</span></div><div class="line">			nums[k]=copy[i++];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(copy[i]&lt;copy[j])&#123;<span class="comment">//否则谁小就填充谁</span></div><div class="line">			nums[k]=copy[i++];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			nums[k]=copy[j++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的copy数组在类中一开始显式声明，然后在sort初始部分一次性分配空间初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copy;		<span class="comment">//事先声明一个辅助数组</span></div></pre></td></tr></table></figure></p>
<p><em>Notes:这里不一开始就复制所有元素到copy数组的原因在于，后续归并时是一个回退的过程，<strong>每次都是将前一阶段已经排好序的子数组复制到对应copy部分，然后进一步归并排序</strong>，所以如果一开始就复制而后面不复制，后面中间的排序过程就失效了</em></p>
<h4 id="递归方法（自顶向下）"><a href="#递归方法（自顶向下）" class="headerlink" title="递归方法（自顶向下）"></a>递归方法（自顶向下）</h4><ul>
<li>递归+分治的思想<br>对某一子数组排序，先将其对半分，然后对各部分分别递归调用排序，最后将有序的子数组归并为最终的排序结果<br><img src="/materials/img/basic_alg/top_down.jpg" alt="top down"></li>
<li>Java实现<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	copy=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">	mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(low&gt;=high)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> mid=(low+high)&gt;&gt;<span class="number">1</span>;</div><div class="line">	mergeSort(nums,low,mid);</div><div class="line">	mergeSort(nums,mid+<span class="number">1</span>,high);</div><div class="line">	<span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</div><div class="line">		merge(nums,low,mid,high);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>Notes:sort方法的作用在于安排多次merge方法调用的正确顺序，只有子数组有序了，merge方法才是有效的</em></p>
<ul>
<li>归并排序的时间复杂度分析<br><img src="/materials/img/basic_alg/merge_sort.jpg" alt="merge sort"><blockquote>
<p>对于长度为N的任意数组，自顶向下的归并排序需要$\frac{1}{2}NlgN$至$NlgN$次比较</p>
</blockquote>
</li>
</ul>
<p>如图，以$N$表示数组元素数目，n表示树的层级则有$n=lgN$,每个节点都表示一个mergeSort()方法通过merge()方法归并而成的子数组，第$k$层有$2^k$个子数组，每个数组的长度为$2^{n-k}$，所以归并最多需要$2^{n-k}$次比较，因此每层的比较次数为$2^k\times 2^{n-k}=2^n$,$n$层总共是$n2^n=NlgN$</p>
<h4 id="自底向上（非递归）"><a href="#自底向上（非递归）" class="headerlink" title="自底向上（非递归）"></a>自底向上（非递归）</h4><ul>
<li>先归并微型数组，然后再<strong>成对</strong>归并得到的子数组，直到将整个数组归并在一起<br><img src="/materials/img/basic_alg/bottom_up.jpg" alt="bottom up"></li>
<li>Java实现<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	copy=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;nums.length;sz*=<span class="number">2</span>)&#123;		<span class="comment">//每轮遍历倍增归并的子数组大小</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> low=<span class="number">0</span>;low&lt;nums.length;low+=(<span class="number">2</span>*sz))&#123;	<span class="comment">//成对归并</span></div><div class="line">			merge(nums,low,low+sz-<span class="number">1</span>,Math.min(low+<span class="number">2</span>*sz-<span class="number">1</span>, nums.length-<span class="number">1</span>));<span class="comment">//最后一组子数组大小可能小于对半分的子数组</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>自底向上的归并排序比较适合用链表组织的数据，这种方法只需要重新组织链表链接就能将链表原地排序</p>
</blockquote>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>优点：能保证将任意长度为$N$的数组排序所需时间和$NlgN$成正比，所以能使用归并排序处理数百万乃至更大规模的数组</li>
<li>缺点：他所需的额外空间与$N$成正比</li>
<li>归并排序是一种渐近最优的<strong>基于比较</strong>排序的算法：归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是$~NlgN$</li>
</ul>
<h4 id="进一步改进的方向"><a href="#进一步改进的方向" class="headerlink" title="进一步改进的方向"></a>进一步改进的方向</h4><ul>
<li>对小规模子数组用插入排序</li>
<li>不将元素复制到辅助数组，而是在递归调用的每个层次交换输入数组和辅助数组的角色</li>
</ul>
<h3 id="堆排序【重点】"><a href="#堆排序【重点】" class="headerlink" title="堆排序【重点】"></a>堆排序【重点】</h3><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><p>根据《算法》一书的实现方法，堆排序是使用了一种特殊的数据结构——优先队列从而实现快速获取数组中的最大或者最小值来完成排序。</p>
<ul>
<li>优先队列：两个核心操作：插入元素&amp;获取最大元素，在书中是使用了二叉堆（数组实现完全二叉树的数据结构）来实现的</li>
<li>基本思路是先将传入的数组处理成有序堆，然后逐个取最大元素（根节点）并<strong>恢复</strong>对有序的结构直到所有元素均被处理完</li>
</ul>
<blockquote>
<ul>
<li>堆有序：当一棵二叉树的每个节点都大于或等于它的两个子节点时，被称为堆有序</li>
<li>二叉堆是一组能够用堆有序的<strong>完全二叉树</strong>排序的元素，并在数组中按照层级存储</li>
</ul>
</blockquote>
<p><em>Notes:</em></p>
<ul>
<li>简言之，主要操作是堆的构建和每次取最大元素以后（堆结构局部破坏）调整和恢复堆结构的操作，也就是sink()方法</li>
<li>从下标0开始存储在数组中的完全二叉树有如下特点，对于二叉树的某一内部结点，假设其下标为k，则其父节点下标为(k-1)/2,两个子节点（若存在）的下标节点分别为2k+1和2k+2,所以我们可以根据下标很方便的交换元素来构建堆以及恢复堆</li>
<li>《算法》一书中给出的是从下标1开始的数组，把第0位作为哨兵在其他应用里会有用，这样的话父节点，子节点相应的需要调整为k,2k和2k+1，这里主要考虑到一般传进来的数组是从0开始的，为了避免需要开辟额外的空间建堆所以进行了修改，使其原地排序</li>
</ul>
<h4 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li>堆排序<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> N=nums.length-<span class="number">1</span>;</div><div class="line">	<span class="comment">//构建堆</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=(N-<span class="number">1</span>)/<span class="number">2</span>;k&gt;=<span class="number">0</span>;k--)&#123;</div><div class="line">		sink(nums,k,N);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//重复取最大元素并恢复堆结构</span></div><div class="line">	<span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</div><div class="line">		exchange(nums, <span class="number">0</span>, N--);</div><div class="line">		sink(nums,<span class="number">0</span>,N);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">	<span class="comment">//自上而下调整</span></div><div class="line">	<span class="keyword">while</span>(p*<span class="number">2</span>+<span class="number">1</span>&lt;=N)&#123;</div><div class="line">		<span class="keyword">int</span> temp=p*<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(temp+<span class="number">1</span>&lt;=N &amp;&amp; nums[temp]&lt;nums[temp+<span class="number">1</span>])&#123;<span class="comment">//取子节点中较大的一个元素</span></div><div class="line">			temp+=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(nums[p]&gt;=nums[temp])&#123;	<span class="comment">//此时堆有序，无需调整，结束循环</span></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//否则元素下沉</span></div><div class="line">		exchange(nums,p,temp);</div><div class="line">		p=temp;</div><div class="line">	&#125;		</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> temp=nums[i];</div><div class="line">	nums[i]=nums[j];</div><div class="line">	nums[j]=temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>堆排序能同时最优地利用空间和时间，即使在最坏的情形下也能保证使用$~2NlgN$次比较和恒定的额外空间</li>
<li>在空间比较紧张的开发中应用广泛(比如嵌入式系统)，但是现代操作系统中较少使用，主要是他无法利用缓存，数组元素很少与相邻的其他元素进行比较，所以缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，比如快排、归并排序甚至希尔排序</li>
<li>但另一方面，用堆实现的优先队列的应用却越来越重要，因为它能在插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行时间，另外常考算法比如topM和MultiWay(特别针对大数据、数据流)</li>
</ul>
<h4 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h4><p>可以通过先下沉后上浮来来免去检查元素是否到达正确位置的时间，但是这种方法需要额外的空间</p>
<h3 id="优先队列的应用延伸"><a href="#优先队列的应用延伸" class="headerlink" title="优先队列的应用延伸"></a>优先队列的应用延伸</h3><h4 id="TopM【考点】"><a href="#TopM【考点】" class="headerlink" title="TopM【考点】"></a>TopM【考点】</h4><p>问题描述，参照<a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" target="_blank" rel="external">geeksforgeeks</a></p>
<blockquote>
<p>打印一个无序数组中最大的M个元素</p>
</blockquote>
<h5 id="思路概述"><a href="#思路概述" class="headerlink" title="思路概述"></a>思路概述</h5><ul>
<li>部分排序，比如修改冒泡排序，执行M次，然后将数组末端的M个元素打印出来（也可以使用选择排序等，思路类似），时间复杂度为$O(NM)$</li>
<li>使用一个小型的缓存数组，将原数组中的M个元素先保存到一个大小为M的小数组中，然后查找其中的最小值记为min，接下来遍历原始数组剩余部分，遇到比min大的元素则从小数组中去掉min元素，插入新元素并重新查找到当前最小元素，时间复杂度为$O((N-M)*M+MlgM)$,前一项为遍历以及插入元素以后更新（查找）当前最小元素的时间消耗，后一项则是最后要按顺序打印的小数组排序时间复杂度</li>
<li>直接对原始数组进行排序，时间复杂度一般为$O(NlgN)$，但是这种方法对于数据量较大的情况是不合适的</li>
<li>使用大顶堆存储原始数组，这样构建大顶堆的时间为$O(N)$(参见《算法》P206命题R用下沉法构建堆)，构建好堆以后重复取M次堆顶元素的时间复杂度为$O(MlgN)$，因为涉及到每次取最大元素以后调整堆的操作，所以总体时间复杂度为$O(N+MlgN)$</li>
<li>有序统计【有待进一步分析】<ul>
<li>使用有序统计算法（order statistic algorithm）来找到第k大的元素，时间复杂度为$O(N)$</li>
<li>使用快速排序的切分算法来将前一步找到的第k大元素作为pivot切分点对数组进行切分，时间复杂度为O(N)</li>
<li>最后对与小于切分点的元素排序输出$O(MlgM)$</li>
<li>总体时间复杂度为$O(N+MlgM)$</li>
</ul>
</li>
<li>使用小顶堆【重点掌握】，该方法是对第二种方法的一个改进，即不使用暂存数组，而是使用一个大小为M的小顶堆来暂存数据，这样节省查找时间<ul>
<li>使用前M个元素构建一个小顶堆，时间复杂度$O(M)$</li>
<li>对后续每一个元素，将元素与堆顶元素比较，若比堆顶元素大，则交换并下沉调整堆，时间复杂度为$O((N-M)lgM)$</li>
<li>最后对小顶堆排序输出$O(MlgM)$<br>总体时间复杂度$O(M+(N-M)lgM+MlgM)$</li>
</ul>
</li>
</ul>
<h5 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h5><ul>
<li>针对小顶堆的方法，不过这里进行了微调，在后续插入数据时采取的方法是移除当前最小值然后插入元素调整堆的方法，可以修改<code>delMin()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">//用小顶堆实现从数组中找出其中最大的M个元素</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopM</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Scanner in=<span class="keyword">new</span> Scanner(System.in);</div><div class="line">		<span class="keyword">if</span>(in.hasNext())&#123;</div><div class="line">			<span class="keyword">int</span> cases=in.nextInt();</div><div class="line">			<span class="keyword">while</span>(cases--&gt;=<span class="number">0</span> &amp;&amp; in.hasNext())&#123;</div><div class="line">				<span class="keyword">int</span> N=in.nextInt();</div><div class="line">				<span class="keyword">int</span> M=in.nextInt();</div><div class="line">				<span class="keyword">int</span>[] total=<span class="keyword">new</span> <span class="keyword">int</span>[N];</div><div class="line">				<span class="keyword">int</span>[] heap=<span class="keyword">new</span> <span class="keyword">int</span>[M];</div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total.length;i++)&#123;</div><div class="line">					total[i]=in.nextInt();</div><div class="line">				&#125;</div><div class="line">				topM(total,heap);</div><div class="line">				printArray(heap);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		in.close();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">topM</span><span class="params">(<span class="keyword">int</span>[] total, <span class="keyword">int</span>[] top)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> N=total.length;</div><div class="line">		<span class="keyword">int</span> M=top.length;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(i&lt;M)&#123;</div><div class="line">				insert(top,i,total[i]);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				<span class="keyword">if</span>(total[i]&gt;getMin(top))&#123;</div><div class="line">					delMin(top);</div><div class="line">					insert(top,i,total[i]);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		heapSort(top);		</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[] top)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(top.length==<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> top[<span class="number">0</span>];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delMin</span><span class="params">(<span class="keyword">int</span>[] top)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> M=top.length;</div><div class="line">		exchange(top,<span class="number">0</span>,M-<span class="number">1</span>);</div><div class="line">		sink(top);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] top)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> M=top.length;</div><div class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span>(<span class="number">2</span>*i+<span class="number">2</span>&lt;=M-<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(left+<span class="number">1</span>!=M-<span class="number">1</span>&amp;&amp;top[left+<span class="number">1</span>]&lt;top[left])&#123;</div><div class="line">				left++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(top[i]&lt;=top[left])&#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			exchange(top,i,left);</div><div class="line">			i=left;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] top,<span class="keyword">int</span> index, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> M=top.length;</div><div class="line">		<span class="keyword">if</span>(index&gt;=M-<span class="number">1</span>)&#123;</div><div class="line">			index=M-<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		top[index]=key;</div><div class="line">		swim(top,index);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span>[] top, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">int</span> parent=(index-<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">			<span class="keyword">if</span>(top[parent]&gt;top[index])&#123;</div><div class="line">				exchange(top,index,parent);</div><div class="line">				index=parent;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp=nums[i];</div><div class="line">		nums[i]=nums[j];</div><div class="line">		nums[j]=temp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//构建小顶堆排序</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> N=nums.length-<span class="number">1</span>;</div><div class="line">		<span class="comment">//构建堆</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=(N-<span class="number">1</span>)/<span class="number">2</span>;k&gt;=<span class="number">0</span>;k--)&#123;</div><div class="line">			sink(nums,k,N);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//重复取最大元素并恢复堆结构</span></div><div class="line">		<span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</div><div class="line">			exchange(nums, <span class="number">0</span>, N--);</div><div class="line">			sink(nums,<span class="number">0</span>,N);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">		<span class="comment">//自上而下调整</span></div><div class="line">		<span class="keyword">while</span>(p*<span class="number">2</span>+<span class="number">1</span>&lt;=N)&#123;</div><div class="line">			<span class="keyword">int</span> temp=p*<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(temp+<span class="number">1</span>&lt;=N &amp;&amp; nums[temp]&gt;nums[temp+<span class="number">1</span>])&#123;<span class="comment">//取子节点中较小的一个元素</span></div><div class="line">				temp+=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(nums[p]&lt;=nums[temp])&#123;	<span class="comment">//此时堆有序，无需调整，结束循环</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//否则元素下沉</span></div><div class="line">			exchange(nums,p,temp);</div><div class="line">			p=temp;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;			</div><div class="line">			System.out.print(nums[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>从数据流中得到当前的k个最大的元素（默认数据流为无限）</p>
</blockquote>
<p>这样的话上述不少方法就不能使用了，常见思路如下</p>
<ul>
<li>维持一个大小为k的有序数组，这样和前面一样，针对后续读取的每一个元素，比当前数组中的首位元素（最小元素）小的元素忽略，大的则删除当前数组最小元素并插入该元素</li>
<li>使用大小为k的平衡二叉查找树来存储元素，当然要求是每次插入元素后得调整树结构保持树的平衡</li>
<li>小顶堆的做法，与前一个问题一致</li>
</ul>
<p><em>《剑指offer》第二版一书P209面试题40也有关于这个问题的讨论</em></p>
<h4 id="Multiway（多向归并）"><a href="#Multiway（多向归并）" class="headerlink" title="Multiway（多向归并）"></a>Multiway（多向归并）</h4><blockquote>
<p>将M个有序输入流归并为一个有序的输出流(《算法》中文版2.4.4.7 P205)</p>
</blockquote>
<h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>维持一个大小为M的小顶(索引)堆，存储来自不同输入流的索引</li>
<li>先逐个遍历输入流将每个输入流的首位元素（最小元素）插入到堆中，并与对应的索引关联</li>
<li>此时输出的最小元素即为所有输入流的最小元素，每输出一个最小元素，即在输出元素索引对应的输入流中读入下一个元素（如果存在）并插入堆中，这样就能保证每次输出的都是所有输入流中的最小元素</li>
</ul>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h4 id="霍夫曼压缩"><a href="#霍夫曼压缩" class="headerlink" title="霍夫曼压缩"></a>霍夫曼压缩</h4><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote>
<p>不断地选择剩余元素中的最小者并与当前剩余元素第一位交换<br>首先，找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置，再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，如此往复，直到将整个数组排序。</p>
</blockquote>
<h4 id="Java实现-4"><a href="#Java实现-4" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li><p>选择排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="keyword">int</span> minPos=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(nums[minPos]&gt;nums[j])&#123;</div><div class="line">				minPos=j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> temp=nums[i];</div><div class="line">		nums[i]=nums[minPos];</div><div class="line">		nums[minPos]=temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] nums=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</div><div class="line">	printArray(nums);</div><div class="line">	selectSort(nums);</div><div class="line">	printArray(nums);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;			</div><div class="line">		System.out.print(nums[i]+<span class="string">" "</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对于长度为$N$的数组，选择排序需要大约$N^2/2$次比较和$N$次交换</li>
<li>运行时间和输入无关（缺点），比如元素相等的数组/已经有序的数组与随机数组的排序时间一样长</li>
<li>数据移动是最少的，即元素交换次数是最少的，每次交换只改变两个数组元素的值，即交换次数和数组的大小呈线性关系，而其他的大部分排序算法是线性对数或者平方级别</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote>
<p>整理桥牌</p>
</blockquote>
<p>保证数组当前遍历的元素位置左方元素已经有序，然后将当前元素前向逐个比较，一边比较一边将前面的元素向后覆盖，直到找到第一个不大于该元素的位置，将该元素插入（《算法》一书中的基本实现采用的方法是将目标元素与前面比他大的元素逐个交换的做法，相较之下，我的这种直接移动所有较大元素的做法速度更快（《算法》一书作为练习题））</p>
<h4 id="Java实现-5"><a href="#Java实现-5" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li>插入排序<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="keyword">int</span> temp=nums[i+<span class="number">1</span>];</div><div class="line">		<span class="keyword">int</span> j=i+<span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;temp&lt;nums[j-<span class="number">1</span>])&#123;</div><div class="line">			nums[j]=nums[j-<span class="number">1</span>];</div><div class="line">			j--;</div><div class="line">		&#125;			</div><div class="line">		nums[j]=temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>插入排序所需时间取决于输入中元素的初始顺序，因此插入排序对于部分有序的数组十分高效，也很适合小规模数组（当数组中倒置（倒置指的是数组中两个顺序颠倒的元素）数量很少时，插入排序可能是最快的排序算法）</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>考虑到插入排序不适用于大规模乱序数组，所以进行改进得到的算法</li>
<li>原则是保证数组中任意间隔为h的元素有序，即交换间隔为h的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序</li>
<li>权衡了子数组的规模和有序性：排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序</li>
</ul>
<h4 id="Java实现-6"><a href="#Java实现-6" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li><p>希尔排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> h=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(h&lt;nums.length/<span class="number">3</span>)&#123;</div><div class="line">		h=h*<span class="number">3</span>+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-h;i++)&#123;</div><div class="line">			<span class="keyword">int</span> temp=nums[i+h];</div><div class="line">			<span class="keyword">int</span> j=i+h;</div><div class="line">			<span class="keyword">while</span>(j&gt;=h&amp;&amp;temp&lt;nums[j-h])&#123;</div><div class="line">				nums[j]=nums[j-h];</div><div class="line">				j-=h;</div><div class="line">			&#125;</div><div class="line">			nums[j]=temp;</div><div class="line">		&#125;</div><div class="line">		h/=<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;			</div><div class="line">		System.out.print(nums[i]+<span class="string">" "</span>);</div><div class="line">	&#125;</div><div class="line">	System.out.println();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">		nums[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</div><div class="line">	randArray(nums);</div><div class="line">	</div><div class="line">	printArray(nums);</div><div class="line">	shellSort(nums);</div><div class="line">	printArray(nums);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法性能取决于h值的选择，这里使用的是序列$\frac{3^k-1}{2}$，关于怎样的h值最好，尚无定论，实际应用中相差不大，但一般其时间复杂度不会到达$O(n^2)$</li>
<li>希尔排序也可用于大型数组，其优点在于代码量小而且不需要额外的存储空间，在手头没有现成的排序算法可以调用时，不妨实现希尔排序来辅助工作</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>用一个‘指针’遍历数组并比较与该指针指向元素相邻的元素，如果相邻元素呈逆序状态则交换元素，直到移动到数组末端即完成一轮冒泡排序，然后重复上述操作，一般会设置一个flag来在数组已经有序时（即该轮排序没有发生交换）结束排序</li>
<li>另外一种思路，由于每一次冒泡排序可以保证最大的元素‘沉到’最后一位，所以也可以不设置flag，而使用双指针，后一个指针的遍历范围逐轮缩小<br><em>其中第一个设置flag的方案更优，因为第二种方法即使在数组有序时也会循环遍历两次</em></li>
</ul>
<h4 id="Java实现-7"><a href="#Java实现-7" class="headerlink" title="Java实现"></a>Java实现</h4><ul>
<li><p>flag方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;	<span class="comment">//标记该轮排序是否没有发生交换操作（若是则表明当前数组已有序）</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(nums[i+<span class="number">1</span>]&lt;nums[i])&#123;</div><div class="line">				flag=<span class="keyword">false</span>;</div><div class="line">				exchange(nums,i,i+<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(flag)&#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp=nums[i];</div><div class="line">	nums[i]=nums[j];</div><div class="line">	nums[j]=temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length-i-<span class="number">1</span>;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</div><div class="line">				exchange(nums,j,j+<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数组有序时冒泡排序只需遍历一次数组，但是若当数组完全逆序时，则时间复杂度达到$O(n^2)$，这点和插入排序类似</li>
</ul>
<h3 id="排序算法小结"><a href="#排序算法小结" class="headerlink" title="排序算法小结"></a>排序算法小结</h3><table>
<thead>
<tr>
<th>算法</th>
<th>是否稳定</th>
<th>是否为原地排序</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>否</td>
<td>是</td>
<td>$N^2$</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>插入排序</td>
<td>是</td>
<td>是</td>
<td>介于$N$和$N^2$之间</td>
<td>1</td>
<td>取决于输入元素的排列情况</td>
</tr>
<tr>
<td>希尔排序</td>
<td>否</td>
<td>是</td>
<td>$NlgN?$,$N^{\frac{6}{5}}$</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>快速排序</td>
<td>否</td>
<td>是</td>
<td>$NlgN$</td>
<td>lgN</td>
<td>运行效率由概率提供保证</td>
</tr>
<tr>
<td>三向快速排序</td>
<td>否</td>
<td>是</td>
<td>介于$N$和$NlgN$之间</td>
<td>$lgN$</td>
<td>运行效率由概率保证，同时也取决于输入元素的分布情况</td>
</tr>
<tr>
<td>归并排序</td>
<td>是</td>
<td>否</td>
<td>$NlgN$</td>
<td>$N$</td>
<td>-</td>
</tr>
<tr>
<td>堆排序</td>
<td>否</td>
<td>是</td>
<td>$NlgN$</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>是</td>
<td>是</td>
<td>介于$N$和$N^2$之间</td>
<td>1</td>
<td>取决于输入元素的排列情况</td>
</tr>
</tbody>
</table>
<p><em>来源于《算法》一书中2.5.2</em></p>
<ul>
<li><p>稳定性</p>
<blockquote>
<p>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是稳定的</p>
</blockquote>
</li>
<li><p>稳定排序算法：<strong>插入排序、归并排序、冒泡排序</strong></p>
</li>
<li>另外有很多办法将任意排序算法变成稳定的，不过比较复杂</li>
<li><p>原地排序</p>
<blockquote>
<p>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法</p>
</blockquote>
</li>
<li><p>原地排序算法：上述算法中<strong>除了归并排序</strong>以外都是</p>
</li>
<li>对于Java而言，<code>java.util.Arrays.sort</code>实际上代表了一系列排序方法<ul>
<li>每种原始数据类型都有一个不同的排序方法</li>
<li>一个适用于所有实现了Comparable接口的数据类型的排序方法</li>
<li>一个适用于所有实现了比较器Comparator的数据类型的排序方法</li>
</ul>
</li>
<li>一般而言，Java系统程序员选择对原始数据类型使用（三向切分的）快速排序，对引用类型使用归并排序</li>
</ul>
<p><em>Notes:</em><br>关于排序算法稳定性以及其他更多的排序算法，可以参考<a href="https://www.wikiwand.com/en/Sorting_algorithm#/Stability" target="_blank" rel="external">这里</a></p>
<h3 id="排序的应用延伸"><a href="#排序的应用延伸" class="headerlink" title="排序的应用延伸"></a>排序的应用延伸</h3><h4 id="在线性对数时间内计算两组排列之间的Kendall-tau距离"><a href="#在线性对数时间内计算两组排列之间的Kendall-tau距离" class="headerlink" title="在线性对数时间内计算两组排列之间的Kendall tau距离"></a>在线性对数时间内计算两组排列之间的Kendall tau距离</h4><p><em>关键字：逆序对、归并排序</em></p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><blockquote>
<p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="external">数组中的逆序对</a><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>题目保证输入的数组中没有的相同的数字<br>数据范围：<br>对于%50的数据,size&lt;=10^4<br>对于%75的数据,size&lt;=10^5<br>对于%100的数据,size&lt;=2*10^5<br>例如，输入：1,2,3,4,5,6,7,0; 输出：7</p>
</blockquote>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>归并排序的变体，主要变化在于修改归并操作的复制数组部分，原始的是顺序比较和复制，而此处需要从末尾开始比较两个子数组元素值，记录逆序情况并复制到原始数组</p>
<h5 id="Java实现-8"><a href="#Java实现-8" class="headerlink" title="Java实现"></a>Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InversePairs</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] copy;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] a=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</div><div class="line">		<span class="keyword">int</span>[] a2=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</div><div class="line">		<span class="keyword">int</span>[] a3=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</div><div class="line">		System.out.println(InversePairs(a));</div><div class="line">		System.out.println(InversePairs(a2));</div><div class="line">		System.out.println(InversePairs(a3));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">    	<span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</div><div class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">return</span> mergeSort(array)%<span class="number">1000000007</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</div><div class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    	&#125;</div><div class="line">    	copy=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">    	<span class="keyword">int</span> low=<span class="number">0</span>,high=array.length-<span class="number">1</span>;</div><div class="line">    	<span class="keyword">int</span>[] cnt=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</div><div class="line">    	cnt[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">    	mergeSort(array,low,high,cnt);</div><div class="line">    	<span class="keyword">return</span> cnt[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span>[] cnt)</span> </span>&#123;</div><div class="line">    	<span class="keyword">if</span>(low&gt;=high)&#123;</div><div class="line">    		<span class="keyword">return</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</div><div class="line">    	cnt[<span class="number">0</span>]%=<span class="number">1000000007</span>;</div><div class="line">    	mergeSort(array,low,mid,cnt);</div><div class="line">    	cnt[<span class="number">0</span>]%=<span class="number">1000000007</span>;</div><div class="line">    	mergeSort(array,mid+<span class="number">1</span>,high,cnt);</div><div class="line">    	cnt[<span class="number">0</span>]%=<span class="number">1000000007</span>;</div><div class="line">    	<span class="keyword">if</span>(array[mid]&gt;array[mid+<span class="number">1</span>])&#123;</div><div class="line">    		cnt[<span class="number">0</span>]+=mergeAndCnt(array,low,mid,high);</div><div class="line">    	&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//修改过的merge方法，除了进行归并操作外还会统计范围内的逆序对数目</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeAndCnt</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(low&gt;=high)&#123;</div><div class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</div><div class="line">    		copy[k]=array[k];</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">int</span> i=mid,j=high;</div><div class="line">    	<span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> k=high;k&gt;=low;k--)&#123;</div><div class="line">    		<span class="keyword">if</span>(i&lt;low)&#123;	<span class="comment">//	左子数组耗尽</span></div><div class="line">    			array[k]=copy[j--];</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;mid+<span class="number">1</span>)&#123;	<span class="comment">//若右子数组耗尽</span></div><div class="line">    			array[k]=copy[i--];</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">else</span>&#123;</div><div class="line">    			<span class="keyword">if</span>(copy[i]&gt;copy[j])&#123;</div><div class="line">    				cnt+=(j-mid);	<span class="comment">//只有左子数组元素比右子数组元素大时才计算逆序对</span></div><div class="line">    				<span class="keyword">if</span>(cnt&gt;=<span class="number">1000000007</span>)&#123;</div><div class="line">    					cnt%=<span class="number">1000000007</span>;</div><div class="line">    				&#125;</div><div class="line">    				array[k]=copy[i--];</div><div class="line">    			&#125;</div><div class="line">    			<span class="keyword">else</span>&#123;</div><div class="line">    				array[k]=copy[j--];</div><div class="line">    			&#125;</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">return</span> cnt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为什么是对1000000007取模？<a href="https://www.liuchuo.net/archives/645" target="_blank" rel="external">参考</a></p>
<h4 id="找出一组元素的中位数"><a href="#找出一组元素的中位数" class="headerlink" title="找出一组元素的中位数"></a>找出一组元素的中位数</h4><p><em>快速排序的partition的进一步应用</em></p>
<h5 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h5><p>partition+二分查找：由于对原始数组进行一次切分可以得到数组中的一个索引k，而且此时的数组中该位置左边的元素都不超过该元素，右边的都不小于该元素，即k是第k+1大的元素（从1开始计）如果此时k恰为数组大小的一半，那么这个位置的元素就恰好是数组的中位数，如果不是，则采取二分查找的思想，在该索引的某一边进行进一步切分（比如k小于len(array)/2就在k的右侧进行切分），经过有限次切分就可以找到中位数对应的元素。</p>
<p><em>Notes:本题的变体是寻找数组中出现次数超过一半的数字</em></p>
<h4 id="最长重复子字符串"><a href="#最长重复子字符串" class="headerlink" title="最长重复子字符串"></a>最长重复子字符串</h4><p><em>特殊的字符串排序算法</em></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Robert Sedgewick《算法》4th</li>
<li><a href="http://www.algolist.net/Algorithms/Sorting/Quicksort" target="_blank" rel="external">http://www.algolist.net/Algorithms/Sorting/Quicksort</a></li>
<li><a href="https://www.wikiwand.com/en/Sorting_algorithm#/Stability" target="_blank" rel="external">排序算法稳定性</a></li>
<li><a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" target="_blank" rel="external">geeksforgeeks</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Note </tag>
            
            <tag> algorithm </tag>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[京东JData算法大赛]]></title>
      <url>/2017/06/25/JData/</url>
      <content type="html"><![CDATA[<h2 id="比赛简介"><a href="#比赛简介" class="headerlink" title="比赛简介"></a>比赛简介</h2><blockquote>
<p>本次大赛以京东商城真实的用户、商品和行为数据（脱敏后）为基础，参赛队伍需要通过数据挖掘的技术和机器学习的算法，构建用户购买商品的预测模型，输出高潜用户和目标商品的匹配结果，为精准营销提供高质量的目标群体。同时，希望参赛队伍能通过本次比赛，挖掘数据背后潜在的意义，为电商用户提供更简单、快捷、省心的购物体验。<br><a id="more"></a></p>
</blockquote>
<p>这是2017年京东举办的一场数据挖掘比赛，<a href="http://www.datafountain.cn/#/competitions/247/intro" target="_blank" rel="external">比赛地址</a>，吸引了不少人参加，和实验室的两个同学也一起参加进来体验一下真实比赛的氛围，总的来说整个过程确实比较辛苦，不过也算是痛并快乐着。看过赛题的朋友可能大多会和往年的阿里移动推荐大赛作比较，甚至更早一点的天猫推荐大赛比较，总的来说，确实很相像，目的都是以用户的历史行为记录以及商品、用户的一些特征来构建模型，预测用户未来的购买状况。</p>
<p>我们团队的最终比赛成绩如下，A榜排名139/4240，B榜排名97/4240<br><img src="/materials/img/JData/A.jpg" alt="a"></p>
<p><img src="/materials/img/JData/B.jpg" alt="b"></p>
<h2 id="关于比赛的一点思考"><a href="#关于比赛的一点思考" class="headerlink" title="关于比赛的一点思考"></a>关于比赛的一点思考</h2><h3 id="推荐算法？"><a href="#推荐算法？" class="headerlink" title="推荐算法？"></a>推荐算法？</h3><p>首先针对题目的目的需要明确一点，这并不是如比赛标题所言的那种构建<strong>推荐系统</strong>类型的比赛，关于这一点，我想引用网上大牛的原话来说明</p>
<ul>
<li><p>首先引用阿里移动推荐比赛内部赛的冠军<a href="https://bbs.aliyun.com/read/153103.html?spm=0.0.0.0.QmriRM" target="_blank" rel="external">算者</a>最后获胜时的文章中的内容</p>
<blockquote>
<p>1、代价不同。你推荐给我一首歌，不好听，大不了换一首，不好听，再换，最后总能找到自己喜欢的歌。可是购物呢，你推荐我一个服装品牌，我花了半个月的伙食费买了，等待了几天，到货后发现不满意，怎么办？扔掉？太可惜了！穿在身上？天天别扭！退掉？还要再花点邮费！不管结局怎们样，总之不爽。如果是买个家居什么的，不喜欢的话，可能后悔一辈子。所以购物的用户体验周期要远长于音乐、影视推荐。推荐的试错成本很大。<br>2、需求的单一性与喜好的相似性。喜欢看动作片，那么相似的动作片我都能看一遍。但是购物就不同了，购物更多的是刚需，喜欢可爱的衣服，一般人也不会把所有喜欢的可爱的衣服都买下来，更多的是每个季节只买一件。家居类的频次就低了，可能一辈子就买一次。不同的类目的需求频率是不一样的。</p>
</blockquote>
</li>
<li><p>另一个是天猫推荐算法大赛的top9的<a href="http://www.csdn.net/article/2014-08-27/2821403-the-top-9-of-ali-bigdata-competition/8" target="_blank" rel="external">获奖感言</a>里提到的</p>
<blockquote>
<p>和很多拿到这个问题的同学一样，一开始都觉得是推荐问题，那么通过查阅相关资料自然而然的都是协同过滤等相关推荐算法，实际效果可想而知。具体原因我认为是品牌的转移成本，具体是什么意思呢？打个比方，一个普通的消费者，前三个月某一天购买了苹果的一款手机，根据商品相似等算法我们可能得到苹果和三星很相似，然后在第四个月系统向他推荐了三星，从一个消费者的正常心理来看，这种推荐很难促成交易的发生。也许这个比方不太恰当，但是这个例子反映的信息包括品牌的实际周期，用户对品牌的黏度，消费能力，还有时间季节等因素，我们仅仅通过赛题给出的字段很难分析出这些因素，而这些都是反映品牌的转移成本的关键因素，因为购买行为的发生不是一个单步，而是涉及到很多前因后果以及最终的整体相关性的问题。基于以上考虑，实际上留给我们的就是挖掘买买相关，看买相关的这部分信息，从这点出发这次的问题实际上就是一个有监督的二分类问题。</p>
</blockquote>
</li>
</ul>
<p>通过以上的观点可以看到本题并非协同过滤算法那种构建推荐系统的比赛，而是一种根据离线历史行为记录预测用户未来某段时间买了又买的可能性</p>
<h3 id="与以往比赛的区别"><a href="#与以往比赛的区别" class="headerlink" title="与以往比赛的区别"></a>与以往比赛的区别</h3><p>抛开数据量等的区别，本次比赛与天猫、阿里推荐算法大赛的最主要的区别在于本次比赛并非预测未来某一天的可能发生购买行为的用户商品对，而是预测<strong>未来5天</strong>可能发生购买行为的用户商品对，如果说预测未来一天可能发生购买行为的用户商品对难以捕捉到当天购买（冲动消费等）的用户行为，那么把时间跨度加大到5天的话其实我们就间接地损失了不少可能预测出的用户商品对：</p>
<ul>
<li>首先根据我们的统计结果，大部分发生购买行为的用户商品对的交互在前三~五天，这也是在分析以前的一些比赛的ppt里提到的时间衰减规律的类似结论</li>
<li>此外，取某一个时间区间发生购买行为的用户商品对分析用户对该商品的交互行为，发现在这五天再往前取三天左右的时间交互的用户商品对仅占所有发生购买行为的用户商品对的约四分之一，仅用户的话能占到约一半，但是其中有四分之一的用户在这三天交互的对象并不是后五天购买的了的目标对象，而剩下的一半用户在这三天根本没有交互行为；而究其原因就是预测后五天的用户商品对购买情况的话，这五天对于我们而言就是一个黑匣子，而统计结果却显示我们需要目标时间点最近三天的交互状况，所以造成了预测的困难，后期也曾想过使用类似关联分析之类的方法，然而受精力时间限制也没尝试，所以这也是一个遗憾，不知道那些大牛是怎么处理的。</li>
</ul>
<p>接下来我就简单的从三个步骤来介绍下我们团队在这场比赛所做的一些尝试</p>
<ul>
<li>数据分析和预处理</li>
<li>特征工程</li>
<li>模型设计和评估</li>
</ul>
<h2 id="数据分析和预处理"><a href="#数据分析和预处理" class="headerlink" title="数据分析和预处理"></a>数据分析和预处理</h2><h3 id="官方信息"><a href="#官方信息" class="headerlink" title="官方信息"></a>官方信息</h3><ul>
<li>符号定义：<ul>
<li>S：提供的商品全集；</li>
<li>P：候选的商品子集，P是S的子集；</li>
<li>U：用户集合；</li>
<li>A：用户对S的行为数据集合；</li>
<li>C：S的评价数据。</li>
</ul>
</li>
<li>数据<ul>
<li>按用途：<pre><code>* 训练数据（2016-2-1~2016-4-15）：用户集合U中的用户，对商品集合S中部分商品的行为、评价、用户数据；提供部分候选商品的数据P。
* 预测数据（2016-4-16~2016-4-20）：用户是否下单P(P为候选商品集)中的商品，**每个用户只会下单一个商品**
</code></pre></li>
<li>按类别<ul>
<li>用户：ID,年龄，性别，用户等级，用户注册日期</li>
<li>商品：商品编号，属性1，属性2，属性3，品类ID，品牌ID</li>
<li>评价：商品编号，累计评论数（分段），是否有差评，差评率</li>
<li>行为：用户编号，商品编号，行为时间，<strong>点击模块编号</strong>，类型（浏览，加入购物车，购物车删除，下单，关注，点击），品类ID，品牌ID</li>
</ul>
</li>
<li>注：<ul>
<li>自行组成特征和数据格式，自由组合训练测试数据比例</li>
<li>预测数据<strong>分A,B榜计算分数</strong></li>
<li>数据均采样和脱敏，存在空值</li>
<li>预测用户在未来<strong>5天内</strong>，对某个目标品类下商品的购买意向。对于训练集中出现的每一个用户，参赛者的模型需要预测该用户在未来5天内是否购买目标品类下的商品以及所购买商品的SKU_ID。</li>
</ul>
</li>
</ul>
</li>
<li>评分标准：所有用户在2016-04-16到2016-04-20是否下单<strong>P中的商品</strong><ul>
<li>是否下单： F11=6*Recall*Precise/(5*Recall+Precise)</li>
<li>若下单，预测下单的商品ID是否正确： F12=5*Recall*Precise/(2*Recall+3*Precise)</li>
<li>Score=0.4*F11 + 0.6*F12</li>
<li>Precise为精确率，Recall为召回率</li>
</ul>
</li>
</ul>
<h3 id="FAQ中的一些信息"><a href="#FAQ中的一些信息" class="headerlink" title="FAQ中的一些信息"></a>FAQ中的一些信息</h3><ul>
<li>提供的数据文件编码格式为GBK</li>
<li>一个用户（user_id）只购买一个所提供的候选商品集合P中的商品（sku_id）；用户购买候选商品集合P之外的商品无需提交</li>
<li>评论数据为截止到当日的累计数据</li>
<li>model_id表明用户在页面上点击了哪一个位置；数据中可能存在一些空值，有可能是异常值，也有可能是在页面上点击了一个空白的位置产生的数据,自行理解并处理</li>
<li>集合P为候选商品集合，即参赛者预测的结果中的sku需要在集合P中；集合S为行为数据中的商品全集；</li>
<li>日期格式统一为”yyyy-mm-dd”，时间格式统一为”yyyy-mm-dd hh:mi:ss”</li>
<li>关于用户表中存在10条记录，用户注册时间晚于2016年4月15日情况为真实生产环境中的异常数据,自行理解并处理</li>
</ul>
<h3 id="数据集解析"><a href="#数据集解析" class="headerlink" title="数据集解析"></a>数据集解析</h3><p>这里涉及到的数据集是京东最新的数据集：</p>
<ol>
<li>JData_User.csv             用户数据集           105,321个用户</li>
<li>JData_Comment.csv           商品评论             558,552条记录</li>
<li>JData_Product.csv           预测商品集合           24,187条记录</li>
<li>JData_Action_201602.csv       2月份行为交互记录     11,485,424条记录</li>
<li>JData_Action_201603.csv       3月份行为交互记录     25,916,378条记录</li>
<li>JData_Action_201604.csv       4月份行为交互记录     13,199,934条记录</li>
</ol>
<h3 id="异常值判断"><a href="#异常值判断" class="headerlink" title="异常值判断"></a>异常值判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">import</span> matplotlib</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#定义文件名</span></div><div class="line">ACTION_201602_FILE = <span class="string">"data/JData_Action_201602.csv"</span></div><div class="line">ACTION_201603_FILE = <span class="string">"data/JData_Action_201603.csv"</span></div><div class="line">ACTION_201604_FILE = <span class="string">"data/JData_Action_201604.csv"</span></div><div class="line">COMMENT_FILE = <span class="string">"data/JData_Comment.csv"</span></div><div class="line">PRODUCT_FILE = <span class="string">"data/JData_Product.csv"</span></div><div class="line">USER_FILE = <span class="string">"data/JData_User.csv"</span></div><div class="line">USER_TABLE_FILE = <span class="string">"data/User_table.csv"</span></div><div class="line">ITEM_TABLE_FILE = <span class="string">"data/Item_table.csv"</span></div></pre></td></tr></table></figure>
<h3 id="数据背景信息"><a href="#数据背景信息" class="headerlink" title="数据背景信息"></a>数据背景信息</h3><p>根据官方给出的数据介绍里，可以知道数据可能存在哪些异常信息</p>
<ul>
<li>用户文件<ul>
<li>用户的age存在未知的情况，标记为-1</li>
<li>用户的sex存在保密情况，标记为2</li>
<li>后续分析发现，用户注册日期存在系统异常导致在预测日之后的情况，不过目前针对该特征没有想法，所以不作处理</li>
</ul>
</li>
<li>商品文件<ul>
<li>属性a1,a2,a3均存在未知情形，标记为-1</li>
</ul>
</li>
<li>行为文件<ul>
<li>model_id为点击模块编号，针对用户的行为类型为6时，可能存在空值</li>
</ul>
</li>
</ul>
<h3 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_empty</span><span class="params">(file_path, file_name)</span>:</span></div><div class="line">    df_file = pd.read_csv(file_path)</div><div class="line">    <span class="keyword">print</span> <span class="string">'Is there any missing value in &#123;0&#125;? &#123;1&#125;'</span>.format(file_name, df_file.isnull().any().any()) </div><div class="line"></div><div class="line">check_empty(USER_FILE, <span class="string">'User'</span>)</div><div class="line">check_empty(ACTION_201602_FILE, <span class="string">'Action 2'</span>)</div><div class="line">check_empty(ACTION_201603_FILE, <span class="string">'Action 3'</span>)</div><div class="line">check_empty(ACTION_201604_FILE, <span class="string">'Action 4'</span>)</div><div class="line">check_empty(COMMENT_FILE, <span class="string">'Comment'</span>)</div><div class="line">check_empty(PRODUCT_FILE, <span class="string">'Product'</span>)</div></pre></td></tr></table></figure>
<pre><code>Is there any missing value in User? True
Is there any missing value in Action 2? True
Is there any missing value in Action 3? True
Is there any missing value in Action 4? True
Is there any missing value in Comment? False
Is there any missing value in Product? False
</code></pre><p>由上述简单的分析可知，用户表及行为表中均存在空值记录，而评论表和商品表则不存在，但是结合之前的数据背景分析商品表中存在属性未知的情况，后续也需要针对分析，进一步的我们看看用户表和行为表中的空值情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_detail</span><span class="params">(f_path, f_name)</span>:</span></div><div class="line">    df_file = pd.read_csv(f_path)</div><div class="line">    <span class="keyword">print</span> <span class="string">'empty info in detail of &#123;0&#125;:'</span>.format(f_name)</div><div class="line">    <span class="keyword">print</span> pd.isnull(df_file).any()</div><div class="line"></div><div class="line">empty_detail(USER_FILE, <span class="string">'User'</span>)</div><div class="line">empty_detail(ACTION_201602_FILE, <span class="string">'Action 2'</span>)</div><div class="line">empty_detail(ACTION_201603_FILE, <span class="string">'Action 3'</span>)</div><div class="line">empty_detail(ACTION_201604_FILE, <span class="string">'Action 4'</span>)</div></pre></td></tr></table></figure>
<pre><code>empty info in detail of User:
user_id        False
age             True
sex             True
user_lv_cd     False
user_reg_tm     True
dtype: bool
empty info in detail of Action 2:
user_id     False
sku_id      False
time        False
model_id     True
type        False
cate        False
brand       False
dtype: bool
empty info in detail of Action 3:
user_id     False
sku_id      False
time        False
model_id     True
type        False
cate        False
brand       False
dtype: bool
empty info in detail of Action 4:
user_id     False
sku_id      False
time        False
model_id     True
type        False
cate        False
brand       False
dtype: bool
</code></pre><p>上面简单的输出了下存在空值的文件中具体哪些列存在空值(True)，结果如下</p>
<ul>
<li>User<ul>
<li>age</li>
<li>sex</li>
<li>user_reg_tm</li>
</ul>
</li>
<li>Action<ul>
<li>model_id</li>
</ul>
</li>
</ul>
<p>接下来具体看看各文件中的空值情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_records</span><span class="params">(f_path, f_name, col_name)</span>:</span></div><div class="line">    df_file = pd.read_csv(f_path)</div><div class="line">    missing = df_file[col_name].isnull().sum().sum()</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of missing &#123;0&#125; in &#123;1&#125; is &#123;2&#125;'</span>.format(col_name, f_name, missing) </div><div class="line">    <span class="keyword">print</span> <span class="string">'percent: '</span>, missing * <span class="number">1.0</span> / df_file.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">empty_records(USER_FILE, <span class="string">'User'</span>, <span class="string">'age'</span>)</div><div class="line">empty_records(USER_FILE, <span class="string">'User'</span>, <span class="string">'sex'</span>)</div><div class="line">empty_records(USER_FILE, <span class="string">'User'</span>, <span class="string">'user_reg_tm'</span>)</div><div class="line">empty_records(ACTION_201602_FILE, <span class="string">'Action 2'</span>, <span class="string">'model_id'</span>)</div><div class="line">empty_records(ACTION_201603_FILE, <span class="string">'Action 3'</span>, <span class="string">'model_id'</span>)</div><div class="line">empty_records(ACTION_201604_FILE, <span class="string">'Action 4'</span>, <span class="string">'model_id'</span>)</div></pre></td></tr></table></figure>
<pre><code>No. of missing age in User is 3
percent:  2.84843478509e-05
No. of missing sex in User is 3
percent:  2.84843478509e-05
No. of missing user_reg_tm in User is 3
percent:  2.84843478509e-05
No. of missing model_id in Action 2 is 4959617
percent:  0.431818363867
No. of missing model_id in Action 3 is 10553261
percent:  0.4072043169
No. of missing model_id in Action 4 is 5143018
percent:  0.38962452388
</code></pre><p>对比下数据集的记录数：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>文件说明</th>
<th>记录数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. JData_User.csv</td>
<td>用户数据集</td>
<td>105,321个用户</td>
</tr>
<tr>
<td>2. JData_Comment.csv</td>
<td>商品评论</td>
<td>558,552条记录</td>
</tr>
<tr>
<td>3. JData_Product.csv</td>
<td>预测商品集合</td>
<td>24,187条记录</td>
</tr>
<tr>
<td>4. JData_Action_201602.csv</td>
<td>2月份行为交互记录</td>
<td>11,485,424条记录</td>
</tr>
<tr>
<td>5. JData_Action_201603.csv</td>
<td>3月份行为交互记录</td>
<td>25,916,378条记录</td>
</tr>
<tr>
<td>6. JData_Action_201604.csv</td>
<td>4月份行为交互记录</td>
<td>13,199,934条记录</td>
</tr>
</tbody>
</table>
<p>两相对比结合前面输出的情况，针对不同数据进行不同处理</p>
<ul>
<li>用户文件 <ul>
<li>age,sex:先填充为对应的未知状态（-1|2），后续作为未知状态的值进一步分析和处理</li>
<li>user_reg_tm:暂时不做处理</li>
</ul>
</li>
<li>行为文件<ul>
<li>model_id涉及数目接近一半，而且当前针对该特征没有很好的处理方法，待定</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user = pd.read_csv(USER_FILE)</div><div class="line">user[<span class="string">'age'</span>].fillna(<span class="string">'-1'</span>, inplace=<span class="keyword">True</span>)</div><div class="line">user[<span class="string">'sex'</span>].fillna(<span class="number">2</span>, inplace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> pd.isnull(user).any()</div></pre></td></tr></table></figure>
<pre><code>user_id        False
age            False
sex            False
user_lv_cd     False
user_reg_tm     True
dtype: bool
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nan_reg_tm = user[user[<span class="string">'user_reg_tm'</span>].isnull()]</div><div class="line"><span class="keyword">print</span> nan_reg_tm</div></pre></td></tr></table></figure>
<pre><code>       user_id age  sex  user_lv_cd user_reg_tm
34072   234073  -1  2.0           1         NaN
38905   238906  -1  2.0           1         NaN
67704   267705  -1  2.0           1         NaN
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> len(user[<span class="string">'age'</span>].unique())</div><div class="line"><span class="keyword">print</span> len(user[<span class="string">'sex'</span>].unique())</div><div class="line"><span class="keyword">print</span> len(user[<span class="string">'user_lv_cd'</span>].unique())</div></pre></td></tr></table></figure>
<pre><code>7
3
5
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prod = pd.read_csv(PRODUCT_FILE)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> len(prod[<span class="string">'a1'</span>].unique())</div><div class="line"><span class="keyword">print</span> len(prod[<span class="string">'a2'</span>].unique())</div><div class="line"><span class="keyword">print</span> len(prod[<span class="string">'a3'</span>].unique())</div><div class="line"><span class="comment"># print len(prod['a2'].unique())</span></div><div class="line"><span class="keyword">print</span> len(prod[<span class="string">'brand'</span>].unique())</div></pre></td></tr></table></figure>
<pre><code>4
3
3
102
</code></pre><h3 id="未知记录"><a href="#未知记录" class="headerlink" title="未知记录"></a>未知记录</h3><p>接下来看看各个文件中的未知记录占的比重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'No. of unknown age user: &#123;0&#125; and the percent: &#123;1&#125; '</span>.format(user[user[<span class="string">'age'</span>]==<span class="string">'-1'</span>].shape[<span class="number">0</span>],</div><div class="line">                                                                  user[user[<span class="string">'age'</span>]==<span class="string">'-1'</span>].shape[<span class="number">0</span>]*<span class="number">1.0</span>/user.shape[<span class="number">0</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of unknown sex user: &#123;0&#125; and the percent: &#123;1&#125; '</span>.format(user[user[<span class="string">'sex'</span>]==<span class="number">2</span>].shape[<span class="number">0</span>],</div><div class="line">                                                                  user[user[<span class="string">'sex'</span>]==<span class="number">2</span>].shape[<span class="number">0</span>]*<span class="number">1.0</span>/user.shape[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<pre><code>No. of unknown age user: 14415 and the percent: 0.136867291423 
No. of unknown sex user: 54738 and the percent: 0.519725410887 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unknown_records</span><span class="params">(f_path, f_name, col_name)</span>:</span></div><div class="line">    df_file = pd.read_csv(f_path)</div><div class="line">    missing = df_file[df_file[col_name]==<span class="number">-1</span>].shape[<span class="number">0</span>]</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of unknown &#123;0&#125; in &#123;1&#125; is &#123;2&#125;'</span>.format(col_name, f_name, missing) </div><div class="line">    <span class="keyword">print</span> <span class="string">'percent: '</span>, missing * <span class="number">1.0</span> / df_file.shape[<span class="number">0</span>]</div><div class="line">    </div><div class="line">unknown_records(PRODUCT_FILE, <span class="string">'Product'</span>, <span class="string">'a1'</span>)</div><div class="line">unknown_records(PRODUCT_FILE, <span class="string">'Product'</span>, <span class="string">'a2'</span>)</div><div class="line">unknown_records(PRODUCT_FILE, <span class="string">'Product'</span>, <span class="string">'a3'</span>)</div></pre></td></tr></table></figure>
<pre><code>No. of unknown a1 in Product is 1701
percent:  0.0703270351842
No. of unknown a2 in Product is 4050
percent:  0.167445321867
No. of unknown a3 in Product is 3815
percent:  0.157729358746
</code></pre><p>小结一下</p>
<ul>
<li>空值部分对3条用户的sex,age填充为未知值,注册时间不作处理，此外行为数据部分model_id待定: 43.2%,40.7%,39.0%</li>
<li>未知值部分，用户age存在部分未知值: 13.7%，sex存在大量保密情况(超过一半) 52.0%</li>
<li>商品中各个属性存在部分未知的情况，a1&lt;a3&lt;a2，分别为： 7.0%,16.7%,15.8%</li>
</ul>
<h3 id="数据一致性验证"><a href="#数据一致性验证" class="headerlink" title="数据一致性验证"></a>数据一致性验证</h3><p>首先检查JData_User中的用户和JData_Action中的用户是否一致，保证行为数据中的所产生的行为均由用户数据中的用户产生（但是可能存在用户在行为数据中无行为）</p>
<p>思路：利用pd.Merge连接sku 和 Action中的sku, 观察Action中的数据是否减少</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_action_check</span><span class="params">()</span>:</span></div><div class="line">    df_user = pd.read_csv(<span class="string">'data/JData_User.csv'</span>)</div><div class="line">    df_sku = df_user.ix[:,<span class="string">'user_id'</span>].to_frame()</div><div class="line">    df_month2 = pd.read_csv(<span class="string">'data/JData_Action_201602.csv'</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">'Is action of Feb. from User file? '</span>, len(df_month2) == len(pd.merge(df_sku,df_month2))</div><div class="line">    df_month3 = pd.read_csv(<span class="string">'data/JData_Action_201603.csv'</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">'Is action of Mar. from User file? '</span>, len(df_month3) == len(pd.merge(df_sku,df_month3))</div><div class="line">    df_month4 = pd.read_csv(<span class="string">'data/JData_Action_201604.csv'</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">'Is action of Apr. from User file? '</span>, len(df_month4) == len(pd.merge(df_sku,df_month4))</div><div class="line"></div><div class="line">user_action_check()</div></pre></td></tr></table></figure>
<pre><code>Is action of Feb. from User file?  True
Is action of Mar. from User file?  True
Is action of Apr. from User file?  True
</code></pre><p>结论： User数据集中的用户和交互行为数据集中的用户完全一致</p>
<p><em>根据merge前后的数据量比对，能保证Action中的用户ID是User中的ID的子集</em></p>
<h3 id="重复记录分析"><a href="#重复记录分析" class="headerlink" title="重复记录分析"></a>重复记录分析</h3><p>除去各个数据文件中完全重复的记录,结果证明线上成绩反而大幅下降，可能解释是重复数据是有意义的，比如用户同时购买多件商品，同时添加多个数量的商品到购物车等…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deduplicate</span><span class="params">(filepath, filename, newpath)</span>:</span></div><div class="line">    df_file = pd.read_csv(filepath)       </div><div class="line">    before = df_file.shape[<span class="number">0</span>]</div><div class="line">    df_file.drop_duplicates(inplace=<span class="keyword">True</span>)</div><div class="line">    after = df_file.shape[<span class="number">0</span>]</div><div class="line">    n_dup = before-after</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of duplicate records for '</span> + filename + <span class="string">' is: '</span> + str(n_dup)</div><div class="line">    <span class="keyword">if</span> n_dup != <span class="number">0</span>:</div><div class="line">        df_file.to_csv(newpath, index=<span class="keyword">None</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">'no duplicate records in '</span> + filename</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># deduplicate('data/JData_Action_201602.csv', 'Feb. action', 'data/JData_Action_201602_dedup.csv')</span></div><div class="line">deduplicate(<span class="string">'data/JData_Action_201603.csv'</span>, <span class="string">'Mar. action'</span>, <span class="string">'data/JData_Action_201603_dedup.csv'</span>)</div><div class="line">deduplicate(<span class="string">'data/JData_Action_201604.csv'</span>, <span class="string">'Feb. action'</span>, <span class="string">'data/JData_Action_201604_dedup.csv'</span>)</div><div class="line">deduplicate(<span class="string">'data/JData_Comment.csv'</span>, <span class="string">'Comment'</span>, <span class="string">'data/JData_Comment_dedup.csv'</span>)</div><div class="line">deduplicate(<span class="string">'data/JData_Product.csv'</span>, <span class="string">'Product'</span>, <span class="string">'data/JData_Product_dedup.csv'</span>)</div><div class="line">deduplicate(<span class="string">'data/JData_User.csv'</span>, <span class="string">'User'</span>, <span class="string">'data/JData_User_dedup.csv'</span>)</div></pre></td></tr></table></figure>
<pre><code>No. of duplicate records for Mar. action is: 7085038
No. of duplicate records for Feb. action is: 3672710
No. of duplicate records for Comment is: 0
no duplicate records in Comment
No. of duplicate records for Product is: 0
no duplicate records in Product
No. of duplicate records for User is: 0
no duplicate records in User
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IsDuplicated = df_month.duplicated() </div><div class="line">df_d=df_month[IsDuplicated]</div><div class="line">df_d.groupby(<span class="string">'type'</span>).count()               <span class="comment">#发现重复数据大多数都是由于浏览（1），或者点击(6)产生</span></div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>type</th>
<th>user_id</th>
<th>sku_id</th>
<th>time</th>
<th>model_id</th>
<th>cate</th>
<th>brand</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2176378</td>
<td>2176378</td>
<td>2176378</td>
<td>0</td>
<td>2176378</td>
<td>2176378</td>
</tr>
<tr>
<td>2</td>
<td>636</td>
<td>636</td>
<td>636</td>
<td>0</td>
<td>636</td>
<td>636</td>
</tr>
<tr>
<td>3</td>
<td>1464</td>
<td>1464</td>
<td>1464</td>
<td>0</td>
<td>1464</td>
<td>1464</td>
</tr>
<tr>
<td>4</td>
<td>37</td>
<td>37</td>
<td>37</td>
<td>0</td>
<td>37</td>
<td>37</td>
</tr>
<tr>
<td>5</td>
<td>1981</td>
<td>1981</td>
<td>1981</td>
<td>0</td>
<td>1981</td>
<td>1981</td>
</tr>
<tr>
<td>6</td>
<td>575597</td>
<td>575597</td>
<td>575597</td>
<td>545054</td>
<td>575597</td>
<td>575597</td>
</tr>
</tbody>
</table>
<h3 id="检查是否存在注册时间在2016年-4月-15号之后的用户"><a href="#检查是否存在注册时间在2016年-4月-15号之后的用户" class="headerlink" title="检查是否存在注册时间在2016年-4月-15号之后的用户"></a>检查是否存在注册时间在2016年-4月-15号之后的用户</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">df_user = pd.read_csv(<span class="string">'data\JData_User.csv'</span>,encoding=<span class="string">'gbk'</span>)</div><div class="line">df_user[<span class="string">'user_reg_tm'</span>]=pd.to_datetime(df_user[<span class="string">'user_reg_tm'</span>])</div><div class="line">df_user.ix[df_user.user_reg_tm  &gt;= <span class="string">'2016-4-15'</span>]</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th>user_id</th>
<th>age</th>
<th>sex</th>
<th>user_lv_cd</th>
<th>user_reg_tm</th>
</tr>
</thead>
<tbody>
<tr>
<td>7457</td>
<td>207458</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7463</td>
<td>207464</td>
<td>26-35岁</td>
<td>2.0</td>
<td>2</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7467</td>
<td>207468</td>
<td>36-45岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7472</td>
<td>207473</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7482</td>
<td>207483</td>
<td>26-35岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7492</td>
<td>207493</td>
<td>16-25岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7493</td>
<td>207494</td>
<td>16-25岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7503</td>
<td>207504</td>
<td>16-25岁</td>
<td>2.0</td>
<td>4</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7510</td>
<td>207511</td>
<td>46-55岁</td>
<td>2.0</td>
<td>5</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7512</td>
<td>207513</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7518</td>
<td>207519</td>
<td>26-35岁</td>
<td>2.0</td>
<td>2</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7521</td>
<td>207522</td>
<td>26-35岁</td>
<td>0.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7525</td>
<td>207526</td>
<td>-1</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7533</td>
<td>207534</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7543</td>
<td>207544</td>
<td>26-35岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7544</td>
<td>207545</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7551</td>
<td>207552</td>
<td>26-35岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>7553</td>
<td>207554</td>
<td>16-25岁</td>
<td>2.0</td>
<td>4</td>
<td>2016-04-15</td>
</tr>
<tr>
<td>8545</td>
<td>208546</td>
<td>16-25岁</td>
<td>0.0</td>
<td>2</td>
<td>2016-04-29</td>
</tr>
<tr>
<td>9394</td>
<td>209395</td>
<td>16-25岁</td>
<td>1.0</td>
<td>2</td>
<td>2016-05-11</td>
</tr>
<tr>
<td>10362</td>
<td>210363</td>
<td>56岁以上</td>
<td>2.0</td>
<td>2</td>
<td>2016-05-24</td>
</tr>
<tr>
<td>10367</td>
<td>210368</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-05-24</td>
</tr>
<tr>
<td>11019</td>
<td>211020</td>
<td>36-45岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-06-06</td>
</tr>
<tr>
<td>12014</td>
<td>212015</td>
<td>36-45岁</td>
<td>2.0</td>
<td>2</td>
<td>2016-07-05</td>
</tr>
<tr>
<td>13850</td>
<td>213851</td>
<td>26-35岁</td>
<td>2.0</td>
<td>3</td>
<td>2016-09-11</td>
</tr>
<tr>
<td>14542</td>
<td>214543</td>
<td>-1</td>
<td>2.0</td>
<td>1</td>
<td>2016-10-05</td>
</tr>
<tr>
<td>16746</td>
<td>216747</td>
<td>16-25岁</td>
<td>2.0</td>
<td>1</td>
<td>2016-11-25</td>
</tr>
</tbody>
</table>
<p>由于注册时间是京东系统错误造成，如果行为数据中没有在4月15号之后的数据的话，那么说明这些用户还是正常用户，并不需要删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df_month = pd.read_csv(<span class="string">'data\JData_Action_201604.csv'</span>)</div><div class="line">df_month[<span class="string">'time'</span>] = pd.to_datetime(df_month[<span class="string">'time'</span>])</div><div class="line">df_month.ix[df_month.time &gt;= <span class="string">'2016-4-16'</span>]</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th>user_id</th>
<th>sku_id</th>
<th>time</th>
<th>model_id</th>
<th>type</th>
<th>cate</th>
<th>brand</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>结论：说明用户没有异常操作数据，所以这一批用户不删除</p>
<h3 id="行为数据中的user-id为浮点型，进行INT类型转换"><a href="#行为数据中的user-id为浮点型，进行INT类型转换" class="headerlink" title="行为数据中的user_id为浮点型，进行INT类型转换"></a>行为数据中的user_id为浮点型，进行INT类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">df_month = pd.read_csv(<span class="string">'data\JData_Action_201602.csv'</span>)</div><div class="line">df_month[<span class="string">'user_id'</span>] = df_month[<span class="string">'user_id'</span>].apply(<span class="keyword">lambda</span> x:int(x))</div><div class="line"><span class="keyword">print</span> df_month[<span class="string">'user_id'</span>].dtype</div><div class="line">df_month.to_csv(<span class="string">'data\JData_Action_201602.csv'</span>,index=<span class="keyword">None</span>)</div><div class="line">df_month = pd.read_csv(<span class="string">'data\JData_Action_201603.csv'</span>)</div><div class="line">df_month[<span class="string">'user_id'</span>] = df_month[<span class="string">'user_id'</span>].apply(<span class="keyword">lambda</span> x:int(x))</div><div class="line"><span class="keyword">print</span> df_month[<span class="string">'user_id'</span>].dtype</div><div class="line">df_month.to_csv(<span class="string">'data\JData_Action_201603.csv'</span>,index=<span class="keyword">None</span>)</div><div class="line">df_month = pd.read_csv(<span class="string">'data\JData_Action_201604.csv'</span>)</div><div class="line">df_month[<span class="string">'user_id'</span>] = df_month[<span class="string">'user_id'</span>].apply(<span class="keyword">lambda</span> x:int(x))</div><div class="line"><span class="keyword">print</span> df_month[<span class="string">'user_id'</span>].dtype</div><div class="line">df_month.to_csv(<span class="string">'data\JData_Action_201604.csv'</span>,index=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<pre><code>int64
int64
int64
</code></pre><h3 id="按照星期对用户购买行为进行分析"><a href="#按照星期对用户购买行为进行分析" class="headerlink" title="按照星期对用户购买行为进行分析"></a>按照星期对用户购买行为进行分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 提取购买(type=4)的行为数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_action_data</span><span class="params">(fname, chunk_size=<span class="number">100000</span>)</span>:</span></div><div class="line">    reader = pd.read_csv(fname, header=<span class="number">0</span>, iterator=<span class="keyword">True</span>)</div><div class="line">    chunks = []</div><div class="line">    loop = <span class="keyword">True</span></div><div class="line">    <span class="keyword">while</span> loop:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            chunk = reader.get_chunk(chunk_size)[</div><div class="line">                [<span class="string">"user_id"</span>, <span class="string">"sku_id"</span>, <span class="string">"type"</span>, <span class="string">"time"</span>]]</div><div class="line">            chunks.append(chunk)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            loop = <span class="keyword">False</span></div><div class="line">            print(<span class="string">"Iteration is stopped"</span>)</div><div class="line"></div><div class="line">    df_ac = pd.concat(chunks, ignore_index=<span class="keyword">True</span>)</div><div class="line">    <span class="comment"># type=4,为购买</span></div><div class="line">    df_ac = df_ac[df_ac[<span class="string">'type'</span>] == <span class="number">4</span>]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> df_ac[[<span class="string">"user_id"</span>, <span class="string">"sku_id"</span>, <span class="string">"time"</span>]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df_ac = []</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201602_FILE))</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201603_FILE))</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201604_FILE))</div><div class="line">df_ac = pd.concat(df_ac, ignore_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>Iteration is stopped
Iteration is stopped
Iteration is stopped
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(df_ac.dtypes)</div></pre></td></tr></table></figure>
<pre><code>user_id     int64
sku_id      int64
time       object
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将time字段转换为datetime类型</span></div><div class="line">df_ac[<span class="string">'time'</span>] = pd.to_datetime(df_ac[<span class="string">'time'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 使用lambda匿名函数将时间time转换为星期(周一为1, 周日为７)</span></div><div class="line">df_ac[<span class="string">'time'</span>] = df_ac[<span class="string">'time'</span>].apply(<span class="keyword">lambda</span> x: x.weekday() + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 周一到周日每天购买用户个数</span></div><div class="line">df_user = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'user_id'</span>].nunique()</div><div class="line">df_user = df_user.to_frame().reset_index()</div><div class="line">df_user.columns = [<span class="string">'weekday'</span>, <span class="string">'user_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 周一到周日每天购买商品个数</span></div><div class="line">df_item = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'sku_id'</span>].nunique()</div><div class="line">df_item = df_item.to_frame().reset_index()</div><div class="line">df_item.columns = [<span class="string">'weekday'</span>, <span class="string">'item_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 周一到周日每天购买记录个数</span></div><div class="line">df_ui = df_ac.groupby(<span class="string">'time'</span>, as_index=<span class="keyword">False</span>).size()</div><div class="line">df_ui = df_ui.to_frame().reset_index()</div><div class="line">df_ui.columns = [<span class="string">'weekday'</span>, <span class="string">'user_item_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 条形宽度</span></div><div class="line">bar_width = <span class="number">0.2</span></div><div class="line"><span class="comment"># 透明度</span></div><div class="line">opacity = <span class="number">0.4</span></div><div class="line"></div><div class="line">plt.bar(df_user[<span class="string">'weekday'</span>], df_user[<span class="string">'user_num'</span>], bar_width, </div><div class="line">        alpha=opacity, color=<span class="string">'c'</span>, label=<span class="string">'user'</span>)</div><div class="line">plt.bar(df_item[<span class="string">'weekday'</span>]+bar_width, df_item[<span class="string">'item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'g'</span>, label=<span class="string">'item'</span>)</div><div class="line">plt.bar(df_ui[<span class="string">'weekday'</span>]+bar_width*<span class="number">2</span>, df_ui[<span class="string">'user_item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'m'</span>, label=<span class="string">'user_item'</span>)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'weekday'</span>)</div><div class="line">plt.ylabel(<span class="string">'number'</span>)</div><div class="line">plt.title(<span class="string">'A Week Purchase Table'</span>)</div><div class="line">plt.xticks(df_user[<span class="string">'weekday'</span>] + bar_width * <span class="number">3</span> / <span class="number">2.</span>, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))</div><div class="line">plt.tight_layout() </div><div class="line">plt.legend(prop=&#123;<span class="string">'size'</span>:<span class="number">10</span>&#125;)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/week_purchase.png" alt="week_purchase"></p>
<p>分析：周六，周日购买量较少</p>
<h3 id="一个月中各天购买量"><a href="#一个月中各天购买量" class="headerlink" title="一个月中各天购买量"></a>一个月中各天购买量</h3><h4 id="2016年2月"><a href="#2016年2月" class="headerlink" title="2016年2月"></a>2016年2月</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df_ac = get_from_action_data(fname=ACTION_201602_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac[<span class="string">'time'</span>] = pd.to_datetime(df_ac[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div></pre></td></tr></table></figure>
<pre><code>Iteration is stopped
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df_user = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'user_id'</span>].nunique()</div><div class="line">df_user = df_user.to_frame().reset_index()</div><div class="line">df_user.columns = [<span class="string">'day'</span>, <span class="string">'user_num'</span>]</div><div class="line"></div><div class="line">df_item = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'sku_id'</span>].nunique()</div><div class="line">df_item = df_item.to_frame().reset_index()</div><div class="line">df_item.columns = [<span class="string">'day'</span>, <span class="string">'item_num'</span>]</div><div class="line"></div><div class="line">df_ui = df_ac.groupby(<span class="string">'time'</span>, as_index=<span class="keyword">False</span>).size()</div><div class="line">df_ui = df_ui.to_frame().reset_index()</div><div class="line">df_ui.columns = [<span class="string">'day'</span>, <span class="string">'user_item_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 条形宽度</span></div><div class="line">bar_width = <span class="number">0.2</span></div><div class="line"><span class="comment"># 透明度</span></div><div class="line">opacity = <span class="number">0.4</span></div><div class="line"><span class="comment"># 天数</span></div><div class="line">day_range = range(<span class="number">1</span>,len(df_user[<span class="string">'day'</span>]) + <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># 设置图片大小</span></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">10</span>))</div><div class="line"></div><div class="line">plt.bar(df_user[<span class="string">'day'</span>], df_user[<span class="string">'user_num'</span>], bar_width, </div><div class="line">        alpha=opacity, color=<span class="string">'c'</span>, label=<span class="string">'user'</span>)</div><div class="line">plt.bar(df_item[<span class="string">'day'</span>]+bar_width, df_item[<span class="string">'item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'g'</span>, label=<span class="string">'item'</span>)</div><div class="line">plt.bar(df_ui[<span class="string">'day'</span>]+bar_width*<span class="number">2</span>, df_ui[<span class="string">'user_item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'m'</span>, label=<span class="string">'user_item'</span>)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'day'</span>)</div><div class="line">plt.ylabel(<span class="string">'number'</span>)</div><div class="line">plt.title(<span class="string">'February Purchase Table'</span>)</div><div class="line">plt.xticks(df_user[<span class="string">'day'</span>] + bar_width * <span class="number">3</span> / <span class="number">2.</span>, day_range)</div><div class="line"><span class="comment"># plt.ylim(0, 80)</span></div><div class="line">plt.tight_layout() </div><div class="line">plt.legend(prop=&#123;<span class="string">'size'</span>:<span class="number">9</span>&#125;)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/month_2_buy.png" alt="month_2_buy"></p>
<p>分析： 2月份5,6,7,8,9,10 这几天购买量非常少，原因可能是中国农历春节，快递不营业</p>
<h4 id="2016年3月"><a href="#2016年3月" class="headerlink" title="2016年3月"></a>2016年3月</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df_ac = get_from_action_data(fname=ACTION_201603_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac[<span class="string">'time'</span>] = pd.to_datetime(df_ac[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div></pre></td></tr></table></figure>
<pre><code>Iteration is stopped
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df_user = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'user_id'</span>].nunique()</div><div class="line">df_user = df_user.to_frame().reset_index()</div><div class="line">df_user.columns = [<span class="string">'day'</span>, <span class="string">'user_num'</span>]</div><div class="line"></div><div class="line">df_item = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'sku_id'</span>].nunique()</div><div class="line">df_item = df_item.to_frame().reset_index()</div><div class="line">df_item.columns = [<span class="string">'day'</span>, <span class="string">'item_num'</span>]</div><div class="line"></div><div class="line">df_ui = df_ac.groupby(<span class="string">'time'</span>, as_index=<span class="keyword">False</span>).size()</div><div class="line">df_ui = df_ui.to_frame().reset_index()</div><div class="line">df_ui.columns = [<span class="string">'day'</span>, <span class="string">'user_item_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 条形宽度</span></div><div class="line">bar_width = <span class="number">0.2</span></div><div class="line"><span class="comment"># 透明度</span></div><div class="line">opacity = <span class="number">0.4</span></div><div class="line"><span class="comment"># 天数</span></div><div class="line">day_range = range(<span class="number">1</span>,len(df_user[<span class="string">'day'</span>]) + <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># 设置图片大小</span></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">10</span>))</div><div class="line"></div><div class="line">plt.bar(df_user[<span class="string">'day'</span>], df_user[<span class="string">'user_num'</span>], bar_width, </div><div class="line">        alpha=opacity, color=<span class="string">'c'</span>, label=<span class="string">'user'</span>)</div><div class="line">plt.bar(df_item[<span class="string">'day'</span>]+bar_width, df_item[<span class="string">'item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'g'</span>, label=<span class="string">'item'</span>)</div><div class="line">plt.bar(df_ui[<span class="string">'day'</span>]+bar_width*<span class="number">2</span>, df_ui[<span class="string">'user_item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'m'</span>, label=<span class="string">'user_item'</span>)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'day'</span>)</div><div class="line">plt.ylabel(<span class="string">'number'</span>)</div><div class="line">plt.title(<span class="string">'March Purchase Table'</span>)</div><div class="line">plt.xticks(df_user[<span class="string">'day'</span>] + bar_width * <span class="number">3</span> / <span class="number">2.</span>, day_range)</div><div class="line"><span class="comment"># plt.ylim(0, 80)</span></div><div class="line">plt.tight_layout() </div><div class="line">plt.legend(prop=&#123;<span class="string">'size'</span>:<span class="number">9</span>&#125;)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/month_3_buy.png" alt="month_3_buy"></p>
<p>分析：3月份14,15,16不知名节日，造成购物量剧增，总体来看，购物记录多于2月份</p>
<h4 id="2016年4月"><a href="#2016年4月" class="headerlink" title="2016年4月"></a>2016年4月</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df_ac = get_from_action_data(fname=ACTION_201604_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac[<span class="string">'time'</span>] = pd.to_datetime(df_ac[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div></pre></td></tr></table></figure>
<pre><code>Iteration is stopped
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df_user = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'user_id'</span>].nunique()</div><div class="line">df_user = df_user.to_frame().reset_index()</div><div class="line">df_user.columns = [<span class="string">'day'</span>, <span class="string">'user_num'</span>]</div><div class="line"></div><div class="line">df_item = df_ac.groupby(<span class="string">'time'</span>)[<span class="string">'sku_id'</span>].nunique()</div><div class="line">df_item = df_item.to_frame().reset_index()</div><div class="line">df_item.columns = [<span class="string">'day'</span>, <span class="string">'item_num'</span>]</div><div class="line"></div><div class="line">df_ui = df_ac.groupby(<span class="string">'time'</span>, as_index=<span class="keyword">False</span>).size()</div><div class="line">df_ui = df_ui.to_frame().reset_index()</div><div class="line">df_ui.columns = [<span class="string">'day'</span>, <span class="string">'user_item_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 条形宽度</span></div><div class="line">bar_width = <span class="number">0.2</span></div><div class="line"><span class="comment"># 透明度</span></div><div class="line">opacity = <span class="number">0.4</span></div><div class="line"><span class="comment"># 天数</span></div><div class="line">day_range = range(<span class="number">1</span>,len(df_user[<span class="string">'day'</span>]) + <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># 设置图片大小</span></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">10</span>))</div><div class="line"></div><div class="line">plt.bar(df_user[<span class="string">'day'</span>], df_user[<span class="string">'user_num'</span>], bar_width, </div><div class="line">        alpha=opacity, color=<span class="string">'c'</span>, label=<span class="string">'user'</span>)</div><div class="line">plt.bar(df_item[<span class="string">'day'</span>]+bar_width, df_item[<span class="string">'item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'g'</span>, label=<span class="string">'item'</span>)</div><div class="line">plt.bar(df_ui[<span class="string">'day'</span>]+bar_width*<span class="number">2</span>, df_ui[<span class="string">'user_item_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'m'</span>, label=<span class="string">'user_item'</span>)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'day'</span>)</div><div class="line">plt.ylabel(<span class="string">'number'</span>)</div><div class="line">plt.title(<span class="string">'April Purchase Table'</span>)</div><div class="line">plt.xticks(df_user[<span class="string">'day'</span>] + bar_width * <span class="number">3</span> / <span class="number">2.</span>, day_range)</div><div class="line"><span class="comment"># plt.ylim(0, 80)</span></div><div class="line">plt.tight_layout() </div><div class="line">plt.legend(prop=&#123;<span class="string">'size'</span>:<span class="number">9</span>&#125;)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/month_4_buy.png" alt="month_4_buy"></p>
<p>分析：似乎每个月中旬都有较强的购物欲望？</p>
<h3 id="商品分类别销售统计"><a href="#商品分类别销售统计" class="headerlink" title="商品分类别销售统计"></a>商品分类别销售统计</h3><h4 id="周一到周日各商品类别销售情况"><a href="#周一到周日各商品类别销售情况" class="headerlink" title="周一到周日各商品类别销售情况"></a>周一到周日各商品类别销售情况</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从行为记录中提取商品类别数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_action_data</span><span class="params">(fname, chunk_size=<span class="number">100000</span>)</span>:</span></div><div class="line">    reader = pd.read_csv(fname, header=<span class="number">0</span>, iterator=<span class="keyword">True</span>)</div><div class="line">    chunks = []</div><div class="line">    loop = <span class="keyword">True</span></div><div class="line">    <span class="keyword">while</span> loop:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            chunk = reader.get_chunk(chunk_size)[</div><div class="line">                [<span class="string">"cate"</span>, <span class="string">"brand"</span>, <span class="string">"type"</span>, <span class="string">"time"</span>]]</div><div class="line">            chunks.append(chunk)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            loop = <span class="keyword">False</span></div><div class="line">            print(<span class="string">"Iteration is stopped"</span>)</div><div class="line"></div><div class="line">    df_ac = pd.concat(chunks, ignore_index=<span class="keyword">True</span>)</div><div class="line">    <span class="comment"># type=4,为购买</span></div><div class="line">    df_ac = df_ac[df_ac[<span class="string">'type'</span>] == <span class="number">4</span>]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> df_ac[[<span class="string">"cate"</span>, <span class="string">"brand"</span>, <span class="string">"type"</span>, <span class="string">"time"</span>]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df_ac = []</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201602_FILE))</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201603_FILE))</div><div class="line">df_ac.append(get_from_action_data(fname=ACTION_201604_FILE))</div><div class="line">df_ac = pd.concat(df_ac, ignore_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>Iteration is stopped
Iteration is stopped
Iteration is stopped
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将time字段转换为datetime类型</span></div><div class="line">df_ac[<span class="string">'time'</span>] = pd.to_datetime(df_ac[<span class="string">'time'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 使用lambda匿名函数将时间time转换为星期(周一为1, 周日为７)</span></div><div class="line">df_ac[<span class="string">'time'</span>] = df_ac[<span class="string">'time'</span>].apply(<span class="keyword">lambda</span> x: x.weekday() + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 观察有几个类别商品</span></div><div class="line">df_ac.groupby(df_ac[<span class="string">'cate'</span>]).count()</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>cate</th>
<th>cate</th>
<th>brand</th>
<th>type</th>
<th>time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>9326</td>
<td>9326</td>
<td>9326</td>
<td>9326</td>
</tr>
<tr>
<td>5</td>
<td>8138</td>
<td>8138</td>
<td>8138</td>
<td>8138</td>
</tr>
<tr>
<td>6</td>
<td>6982</td>
<td>6982</td>
<td>6982</td>
<td>6982</td>
</tr>
<tr>
<td>7</td>
<td>6214</td>
<td>6214</td>
<td>6214</td>
<td>6214</td>
</tr>
<tr>
<td>8</td>
<td>13281</td>
<td>13281</td>
<td>13281</td>
<td>13281</td>
</tr>
<tr>
<td>9</td>
<td>4104</td>
<td>4104</td>
<td>4104</td>
<td>4104</td>
</tr>
<tr>
<td>10</td>
<td>189</td>
<td>189</td>
<td>189</td>
<td>189</td>
</tr>
<tr>
<td>11</td>
<td>18</td>
<td>18</td>
<td>18</td>
<td>18</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 周一到周日每天购买商品类别4的数量统计</span></div><div class="line">df_product = df_ac[<span class="string">'brand'</span>].groupby([df_ac[<span class="string">'time'</span>],df_ac[<span class="string">'cate'</span>]]).count()</div><div class="line">df_product=df_product.unstack()</div><div class="line">df_product.plot(kind=<span class="string">'bar'</span>,title=<span class="string">'Cate Purchase Table in a Week'</span>,figsize=(<span class="number">14</span>,<span class="number">10</span>))</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/week_cate_buy.png" alt="week_cate_buy"></p>
<p>分析：星期二买类别8的最多，星期天最少。</p>
<h4 id="每月各类商品销售情况（只关注商品8）"><a href="#每月各类商品销售情况（只关注商品8）" class="headerlink" title="每月各类商品销售情况（只关注商品8）"></a>每月各类商品销售情况（只关注商品8）</h4><h5 id="2016年2，3，4月"><a href="#2016年2，3，4月" class="headerlink" title="2016年2，3，4月"></a>2016年2，3，4月</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">df_ac2 = get_from_action_data(fname=ACTION_201602_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac2[<span class="string">'time'</span>] = pd.to_datetime(df_ac2[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div><div class="line">df_ac3 = get_from_action_data(fname=ACTION_201603_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac3[<span class="string">'time'</span>] = pd.to_datetime(df_ac3[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div><div class="line">df_ac4 = get_from_action_data(fname=ACTION_201604_FILE)</div><div class="line"></div><div class="line"><span class="comment"># 将time字段转换为datetime类型并使用lambda匿名函数将时间time转换为天</span></div><div class="line">df_ac4[<span class="string">'time'</span>] = pd.to_datetime(df_ac4[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.day)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dc_cate2 = df_ac2[df_ac2[<span class="string">'cate'</span>]==<span class="number">8</span>]</div><div class="line">dc_cate2 = dc_cate2[<span class="string">'brand'</span>].groupby(dc_cate2[<span class="string">'time'</span>]).count()</div><div class="line">dc_cate2 = dc_cate2.to_frame().reset_index()</div><div class="line">dc_cate2.columns = [<span class="string">'day'</span>, <span class="string">'product_num'</span>]</div><div class="line"></div><div class="line">dc_cate3 = df_ac3[df_ac3[<span class="string">'cate'</span>]==<span class="number">8</span>]</div><div class="line">dc_cate3 = dc_cate3[<span class="string">'brand'</span>].groupby(dc_cate3[<span class="string">'time'</span>]).count()</div><div class="line">dc_cate3 = dc_cate3.to_frame().reset_index()</div><div class="line">dc_cate3.columns = [<span class="string">'day'</span>, <span class="string">'product_num'</span>]</div><div class="line"></div><div class="line">dc_cate4 = df_ac4[df_ac4[<span class="string">'cate'</span>]==<span class="number">8</span>]</div><div class="line">dc_cate4 = dc_cate4[<span class="string">'brand'</span>].groupby(dc_cate4[<span class="string">'time'</span>]).count()</div><div class="line">dc_cate4 = dc_cate4.to_frame().reset_index()</div><div class="line">dc_cate4.columns = [<span class="string">'day'</span>, <span class="string">'product_num'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 条形宽度</span></div><div class="line">bar_width = <span class="number">0.2</span></div><div class="line"><span class="comment"># 透明度</span></div><div class="line">opacity = <span class="number">0.4</span></div><div class="line"><span class="comment"># 天数</span></div><div class="line">day_range = range(<span class="number">1</span>,len(dc_cate3[<span class="string">'day'</span>]) + <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># 设置图片大小</span></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">10</span>))</div><div class="line"></div><div class="line">plt.bar(dc_cate2[<span class="string">'day'</span>], dc_cate2[<span class="string">'product_num'</span>], bar_width, </div><div class="line">        alpha=opacity, color=<span class="string">'c'</span>, label=<span class="string">'February'</span>)</div><div class="line">plt.bar(dc_cate3[<span class="string">'day'</span>]+bar_width, dc_cate3[<span class="string">'product_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'g'</span>, label=<span class="string">'March'</span>)</div><div class="line">plt.bar(dc_cate4[<span class="string">'day'</span>]+bar_width*<span class="number">2</span>, dc_cate4[<span class="string">'product_num'</span>], </div><div class="line">        bar_width, alpha=opacity, color=<span class="string">'m'</span>, label=<span class="string">'April'</span>)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'day'</span>)</div><div class="line">plt.ylabel(<span class="string">'number'</span>)</div><div class="line">plt.title(<span class="string">'Cate-8 Purchase Table'</span>)</div><div class="line">plt.xticks(dc_cate3[<span class="string">'day'</span>] + bar_width * <span class="number">3</span> / <span class="number">2.</span>, day_range)</div><div class="line"><span class="comment"># plt.ylim(0, 80)</span></div><div class="line">plt.tight_layout() </div><div class="line">plt.legend(prop=&#123;<span class="string">'size'</span>:<span class="number">9</span>&#125;)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/JData/month_cate_buy.png" alt="month_cate_buy"></p>
<p>分析：2月份对类别8商品的购买普遍偏低，3，4月份普遍偏高，3月15日购买极其多！可以对比3月份的销售记录，发现类别8将近占了3月15日总销售的一半！同时发现，3,4月份类别8销售记录在前半个月特别相似，除了4月8号，9号和3月15号。</p>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">comment_date = [</div><div class="line">    <span class="string">"2016-02-01"</span>, <span class="string">"2016-02-08"</span>, <span class="string">"2016-02-15"</span>, <span class="string">"2016-02-22"</span>, <span class="string">"2016-02-29"</span>,</div><div class="line">    <span class="string">"2016-03-07"</span>, <span class="string">"2016-03-14"</span>, <span class="string">"2016-03-21"</span>, <span class="string">"2016-03-28"</span>, <span class="string">"2016-04-04"</span>,</div><div class="line">    <span class="string">"2016-04-11"</span>, <span class="string">"2016-04-15"</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_actions_1</span><span class="params">()</span>:</span></div><div class="line">    action = pd.read_csv(action_1_path)</div><div class="line">    <span class="keyword">return</span> action</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_actions_2</span><span class="params">()</span>:</span></div><div class="line">    action2 = pd.read_csv(action_2_path)</div><div class="line">    <span class="keyword">return</span> action2</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_actions_3</span><span class="params">()</span>:</span></div><div class="line">    action3 = pd.read_csv(action_3_path)</div><div class="line">    <span class="keyword">return</span> action3</div><div class="line"><span class="comment"># 读取并拼接所有行为记录文件</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_action</span><span class="params">()</span>:</span></div><div class="line">    action_1 = get_actions_1()</div><div class="line">    action_2 = get_actions_2()</div><div class="line">    action_3 = get_actions_3()</div><div class="line">    actions = pd.concat([action_1, action_2, action_3]) <span class="comment"># type: pd.DataFrame</span></div><div class="line"><span class="comment">#     actions = pd.read_csv(action_path)</span></div><div class="line">    <span class="keyword">return</span> actions</div><div class="line"></div><div class="line"><span class="comment"># 获取某个时间段的行为记录</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_actions</span><span class="params">(start_date, end_date, all_actions)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :param start_date:</div><div class="line">    :param end_date:</div><div class="line">    :return: actions: pd.Dataframe</div><div class="line">    """</div><div class="line">    actions = all_actions[(all_actions.time &gt;= start_date) &amp; (all_actions.time &lt; end_date)].copy()</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h3 id="用户特征"><a href="#用户特征" class="headerlink" title="用户特征"></a>用户特征</h3><h4 id="用户基本特征"><a href="#用户基本特征" class="headerlink" title="用户基本特征"></a>用户基本特征</h4><p>获取基本的用户特征，基于用户本身属性多为类别特征的特点，对age,sex,usr_lv_cd进行独热编码操作，对于用户注册时间暂时不处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_basic_user_feat</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 针对年龄的中文字符问题处理，首先是读入的时候编码，填充空值，然后将其数值化，最后独热编码，此外对于sex也进行了数值类型转换</span></div><div class="line">    user = pd.read_csv(user_path, encoding=<span class="string">'gbk'</span>)</div><div class="line"><span class="comment">#     user['age'].fillna('-1', inplace=True)</span></div><div class="line"><span class="comment">#     user['sex'].fillna(2, inplace=True)</span></div><div class="line">    user[<span class="string">'sex'</span>] = user[<span class="string">'sex'</span>].astype(int)    </div><div class="line">    user[<span class="string">'age'</span>] = user[<span class="string">'age'</span>].astype(unicode)</div><div class="line">    le = preprocessing.LabelEncoder()    </div><div class="line">    age_df = le.fit_transform(user[<span class="string">'age'</span>])</div><div class="line"><span class="comment">#     print list(le.classes_)</span></div><div class="line"></div><div class="line">    age_df = pd.get_dummies(age_df, prefix=<span class="string">'age'</span>)</div><div class="line">    sex_df = pd.get_dummies(user[<span class="string">'sex'</span>], prefix=<span class="string">'sex'</span>)</div><div class="line">    user_lv_df = pd.get_dummies(user[<span class="string">'user_lv_cd'</span>], prefix=<span class="string">'user_lv_cd'</span>)</div><div class="line">    user = pd.concat([user[<span class="string">'user_id'</span>], age_df, sex_df, user_lv_df], axis=<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> user</div></pre></td></tr></table></figure>
<h3 id="商品特征"><a href="#商品特征" class="headerlink" title="商品特征"></a>商品特征</h3><h4 id="商品基本特征"><a href="#商品基本特征" class="headerlink" title="商品基本特征"></a>商品基本特征</h4><p>根据商品文件获取基本的特征，针对属性a1,a2,a3进行独热编码，商品类别和品牌直接作为特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_basic_product_feat</span><span class="params">()</span>:</span></div><div class="line">    product = pd.read_csv(product_path)</div><div class="line">    attr1_df = pd.get_dummies(product[<span class="string">"a1"</span>], prefix=<span class="string">"a1"</span>)</div><div class="line">    attr2_df = pd.get_dummies(product[<span class="string">"a2"</span>], prefix=<span class="string">"a2"</span>)</div><div class="line">    attr3_df = pd.get_dummies(product[<span class="string">"a3"</span>], prefix=<span class="string">"a3"</span>)</div><div class="line">    product = pd.concat([product[[<span class="string">'sku_id'</span>, <span class="string">'cate'</span>, <span class="string">'brand'</span>]], attr1_df, attr2_df, attr3_df], axis=<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> product</div></pre></td></tr></table></figure>
<h3 id="评论特征"><a href="#评论特征" class="headerlink" title="评论特征"></a>评论特征</h3><ul>
<li>分时间段</li>
<li>对评论数进行独热编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_comments_product_feat</span><span class="params">(end_date)</span>:</span></div><div class="line">    comments = pd.read_csv(comment_path)</div><div class="line">    comment_date_end = end_date</div><div class="line">    comment_date_begin = comment_date[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> date <span class="keyword">in</span> reversed(comment_date):</div><div class="line">        <span class="keyword">if</span> date &lt; comment_date_end:</div><div class="line">            comment_date_begin = date</div><div class="line">            <span class="keyword">break</span></div><div class="line">    comments = comments[comments.dt==comment_date_begin]</div><div class="line">    df = pd.get_dummies(comments[<span class="string">'comment_num'</span>], prefix=<span class="string">'comment_num'</span>)</div><div class="line">    <span class="comment"># 为了防止某个时间段不具备评论数为0的情况（测试集出现过这种情况）</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</div><div class="line">        <span class="keyword">if</span> <span class="string">'comment_num_'</span> + str(i) <span class="keyword">not</span> <span class="keyword">in</span> df.columns:</div><div class="line">            df[<span class="string">'comment_num_'</span> + str(i)] = <span class="number">0</span></div><div class="line">    df = df[[<span class="string">'comment_num_0'</span>, <span class="string">'comment_num_1'</span>, <span class="string">'comment_num_2'</span>, <span class="string">'comment_num_3'</span>, <span class="string">'comment_num_4'</span>]]</div><div class="line">    </div><div class="line">    comments = pd.concat([comments, df], axis=<span class="number">1</span>) <span class="comment"># type: pd.DataFrame</span></div><div class="line">        <span class="comment">#del comments['dt']</span></div><div class="line">        <span class="comment">#del comments['comment_num']</span></div><div class="line">    comments = comments[[<span class="string">'sku_id'</span>, <span class="string">'has_bad_comment'</span>, <span class="string">'bad_comment_rate'</span>,<span class="string">'comment_num_0'</span>, <span class="string">'comment_num_1'</span>, </div><div class="line">                         <span class="string">'comment_num_2'</span>, <span class="string">'comment_num_3'</span>, <span class="string">'comment_num_4'</span>]]</div><div class="line">    <span class="keyword">return</span> comments</div></pre></td></tr></table></figure>
<h3 id="行为特征"><a href="#行为特征" class="headerlink" title="行为特征"></a>行为特征</h3><ul>
<li>分时间段</li>
<li>对行为类别进行独热编码</li>
<li>分别按照用户-类别行为分组和用户-类别-商品行为分组统计，然后计算<ul>
<li>用户对同类别下其他商品的行为计数</li>
<li>针对用户对同类别下目标商品的行为计数与该时间段的行为均值作差</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_action_feat</span><span class="params">(start_date, end_date, all_actions, i)</span>:</span></div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line">    actions = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>,<span class="string">'type'</span>]]</div><div class="line">    <span class="comment"># 不同时间累积的行为计数（3,5,7,10,15,21,30）</span></div><div class="line">    df = pd.get_dummies(actions[<span class="string">'type'</span>], prefix=<span class="string">'action_before_%s'</span> %i)</div><div class="line">    before_date = <span class="string">'action_before_%s'</span> %i</div><div class="line">    actions = pd.concat([actions, df], axis=<span class="number">1</span>)  <span class="comment"># type: pd.DataFrame</span></div><div class="line">    <span class="comment"># 分组统计，用户-类别-商品,不同用户对不同类别下商品的行为计数</span></div><div class="line">    actions = actions.groupby([<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>,<span class="string">'cate'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line">    <span class="comment"># 分组统计，用户-类别，不同用户对不同商品类别的行为计数</span></div><div class="line">    user_cate = actions.groupby([<span class="string">'user_id'</span>,<span class="string">'cate'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line">    <span class="keyword">del</span> user_cate[<span class="string">'sku_id'</span>]</div><div class="line">    <span class="keyword">del</span> user_cate[<span class="string">'type'</span>]</div><div class="line">    actions = pd.merge(actions, user_cate, how=<span class="string">'left'</span>, on=[<span class="string">'user_id'</span>,<span class="string">'cate'</span>])</div><div class="line">    <span class="comment">#本类别下其他商品点击量</span></div><div class="line">    <span class="comment"># 前述两种分组含有相同名称的不同行为的计数，系统会自动针对名称调整添加后缀,x,y，所以这里作差统计的是同一类别下其他商品的行为计数</span></div><div class="line">    actions[before_date+<span class="string">'_1_y'</span>] = actions[before_date+<span class="string">'_1_y'</span>] - actions[before_date+<span class="string">'_1_x'</span>]</div><div class="line">    actions[before_date+<span class="string">'_2_y'</span>] = actions[before_date+<span class="string">'_2_y'</span>] - actions[before_date+<span class="string">'_2_x'</span>]</div><div class="line">    actions[before_date+<span class="string">'_3_y'</span>] = actions[before_date+<span class="string">'_3_y'</span>] - actions[before_date+<span class="string">'_3_x'</span>]</div><div class="line">    actions[before_date+<span class="string">'_4_y'</span>] = actions[before_date+<span class="string">'_4_y'</span>] - actions[before_date+<span class="string">'_4_x'</span>]</div><div class="line">    actions[before_date+<span class="string">'_5_y'</span>] = actions[before_date+<span class="string">'_5_y'</span>] - actions[before_date+<span class="string">'_5_x'</span>]</div><div class="line">    actions[before_date+<span class="string">'_6_y'</span>] = actions[before_date+<span class="string">'_6_y'</span>] - actions[before_date+<span class="string">'_6_x'</span>]</div><div class="line">    <span class="comment"># 统计用户对不同类别下商品计数与该类别下商品行为计数均值（对时间）的差值</span></div><div class="line">    actions[before_date+<span class="string">'minus_mean_1'</span>] = actions[before_date+<span class="string">'_1_x'</span>] - (actions[before_date+<span class="string">'_1_x'</span>]/i)</div><div class="line">    actions[before_date+<span class="string">'minus_mean_2'</span>] = actions[before_date+<span class="string">'_2_x'</span>] - (actions[before_date+<span class="string">'_2_x'</span>]/i)</div><div class="line">    actions[before_date+<span class="string">'minus_mean_3'</span>] = actions[before_date+<span class="string">'_3_x'</span>] - (actions[before_date+<span class="string">'_3_x'</span>]/i)</div><div class="line">    actions[before_date+<span class="string">'minus_mean_4'</span>] = actions[before_date+<span class="string">'_4_x'</span>] - (actions[before_date+<span class="string">'_4_x'</span>]/i)</div><div class="line">    actions[before_date+<span class="string">'minus_mean_5'</span>] = actions[before_date+<span class="string">'_5_x'</span>] - (actions[before_date+<span class="string">'_5_x'</span>]/i)</div><div class="line">    actions[before_date+<span class="string">'minus_mean_6'</span>] = actions[before_date+<span class="string">'_6_x'</span>] - (actions[before_date+<span class="string">'_6_x'</span>]/i)</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'type'</span>]</div><div class="line">    <span class="comment"># 保留cate特征</span></div><div class="line"><span class="comment">#     del actions['cate']</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h3 id="用户-行为"><a href="#用户-行为" class="headerlink" title="用户-行为"></a>用户-行为</h3><h4 id="累积用户特征"><a href="#累积用户特征" class="headerlink" title="累积用户特征"></a>累积用户特征</h4><ul>
<li>分时间段</li>
<li>用户不同行为的<ul>
<li>购买转化率</li>
<li>均值</li>
<li>标准差</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_accumulate_user_feat</span><span class="params">(end_date, all_actions, day)</span>:</span></div><div class="line">    start_date = datetime.strptime(end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=day)</div><div class="line">    start_date = start_date.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    before_date = <span class="string">'user_action_%s'</span> % day</div><div class="line"></div><div class="line">    feature = [</div><div class="line">        <span class="string">'user_id'</span>, before_date + <span class="string">'_1'</span>, before_date + <span class="string">'_2'</span>, before_date + <span class="string">'_3'</span>,</div><div class="line">        before_date + <span class="string">'_4'</span>, before_date + <span class="string">'_5'</span>, before_date + <span class="string">'_6'</span>,</div><div class="line">        before_date + <span class="string">'_1_ratio'</span>, before_date + <span class="string">'_2_ratio'</span>,</div><div class="line">        before_date + <span class="string">'_3_ratio'</span>, before_date + <span class="string">'_5_ratio'</span>,</div><div class="line">        before_date + <span class="string">'_6_ratio'</span>, before_date + <span class="string">'_1_mean'</span>,</div><div class="line">        before_date + <span class="string">'_2_mean'</span>, before_date + <span class="string">'_3_mean'</span>,</div><div class="line">        before_date + <span class="string">'_4_mean'</span>, before_date + <span class="string">'_5_mean'</span>,</div><div class="line">        before_date + <span class="string">'_6_mean'</span>, before_date + <span class="string">'_1_std'</span>,</div><div class="line">        before_date + <span class="string">'_2_std'</span>, before_date + <span class="string">'_3_std'</span>, before_date + <span class="string">'_4_std'</span>,</div><div class="line">        before_date + <span class="string">'_5_std'</span>, before_date + <span class="string">'_6_std'</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line">    df = pd.get_dummies(actions[<span class="string">'type'</span>], prefix=before_date)</div><div class="line"></div><div class="line"><span class="comment">#     actions['date'] = pd.to_datetime(actions['time']).apply(lambda x: x.date())</span></div><div class="line"></div><div class="line">    actions = pd.concat([actions[[<span class="string">'user_id'</span>, <span class="string">'date'</span>]], df], axis=<span class="number">1</span>)</div><div class="line">    <span class="comment"># 分组统计，用户不同日期的行为计算标准差</span></div><div class="line">    actions_date = actions.groupby([<span class="string">'user_id'</span>, <span class="string">'date'</span>]).sum()</div><div class="line">    actions_date = actions_date.unstack()</div><div class="line">    actions_date.fillna(<span class="number">0</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    action_1 = np.std(actions_date[before_date + <span class="string">'_1'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_1 = action_1.to_frame()</div><div class="line">    action_1.columns = [before_date + <span class="string">'_1_std'</span>]</div><div class="line">    action_2 = np.std(actions_date[before_date + <span class="string">'_2'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_2 = action_2.to_frame()</div><div class="line">    action_2.columns = [before_date + <span class="string">'_2_std'</span>]</div><div class="line">    action_3 = np.std(actions_date[before_date + <span class="string">'_3'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_3 = action_3.to_frame()</div><div class="line">    action_3.columns = [before_date + <span class="string">'_3_std'</span>]</div><div class="line">    action_4 = np.std(actions_date[before_date + <span class="string">'_4'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_4 = action_4.to_frame()</div><div class="line">    action_4.columns = [before_date + <span class="string">'_4_std'</span>]</div><div class="line">    action_5 = np.std(actions_date[before_date + <span class="string">'_5'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_5 = action_5.to_frame()</div><div class="line">    action_5.columns = [before_date + <span class="string">'_5_std'</span>]</div><div class="line">    action_6 = np.std(actions_date[before_date + <span class="string">'_6'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_6 = action_6.to_frame()</div><div class="line">    action_6.columns = [before_date + <span class="string">'_6_std'</span>]</div><div class="line">    actions_date = pd.concat(</div><div class="line">        [action_1, action_2, action_3, action_4, action_5, action_6], axis=<span class="number">1</span>)</div><div class="line">    actions_date[<span class="string">'user_id'</span>] = actions_date.index</div><div class="line">    <span class="comment"># 分组统计，按用户分组，统计用户各项行为的转化率、均值</span></div><div class="line">    actions = actions.groupby([<span class="string">'user_id'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line"><span class="comment">#     days_interal = (datetime.strptime(end_date, '%Y-%m-%d') -</span></div><div class="line"><span class="comment">#                     datetime.strptime(start_date, '%Y-%m-%d')).days</span></div><div class="line">    <span class="comment"># 转化率</span></div><div class="line"><span class="comment">#     actions[before_date + '_1_ratio'] = actions[before_date +</span></div><div class="line"><span class="comment">#                                                 '_4'] / actions[before_date +</span></div><div class="line"><span class="comment">#                                                                 '_1']</span></div><div class="line"><span class="comment">#     actions[before_date + '_2_ratio'] = actions[before_date +</span></div><div class="line"><span class="comment">#                                                 '_4'] / actions[before_date +</span></div><div class="line"><span class="comment">#                                                                 '_2']</span></div><div class="line"><span class="comment">#     actions[before_date + '_3_ratio'] = actions[before_date +</span></div><div class="line"><span class="comment">#                                                 '_4'] / actions[before_date +</span></div><div class="line"><span class="comment">#                                                                 '_3']</span></div><div class="line"><span class="comment">#     actions[before_date + '_5_ratio'] = actions[before_date +</span></div><div class="line"><span class="comment">#                                                 '_4'] / actions[before_date +</span></div><div class="line"><span class="comment">#                                                                 '_5']</span></div><div class="line"><span class="comment">#     actions[before_date + '_6_ratio'] = actions[before_date +</span></div><div class="line"><span class="comment">#                                                 '_4'] / actions[before_date +</span></div><div class="line"><span class="comment">#                                                                 '_6']</span></div><div class="line">    actions[before_date + <span class="string">'_1_ratio'</span>] =  np.log(<span class="number">1</span> + actions[before_date + <span class="string">'_4'</span>]) - np.log(<span class="number">1</span> + actions[before_date +<span class="string">'_1'</span>])</div><div class="line">    actions[before_date + <span class="string">'_2_ratio'</span>] =  np.log(<span class="number">1</span> + actions[before_date + <span class="string">'_4'</span>]) - np.log(<span class="number">1</span> + actions[before_date +<span class="string">'_2'</span>])</div><div class="line">    actions[before_date + <span class="string">'_3_ratio'</span>] =  np.log(<span class="number">1</span> + actions[before_date + <span class="string">'_4'</span>]) - np.log(<span class="number">1</span> + actions[before_date +<span class="string">'_3'</span>])</div><div class="line">    actions[before_date + <span class="string">'_5_ratio'</span>] =  np.log(<span class="number">1</span> + actions[before_date + <span class="string">'_4'</span>]) - np.log(<span class="number">1</span> + actions[before_date +<span class="string">'_5'</span>])</div><div class="line">    actions[before_date + <span class="string">'_6_ratio'</span>] =  np.log(<span class="number">1</span> + actions[before_date + <span class="string">'_4'</span>]) - np.log(<span class="number">1</span> + actions[before_date +<span class="string">'_6'</span>])</div><div class="line">    <span class="comment"># 均值</span></div><div class="line">    actions[before_date + <span class="string">'_1_mean'</span>] = actions[before_date + <span class="string">'_1'</span>] / day</div><div class="line">    actions[before_date + <span class="string">'_2_mean'</span>] = actions[before_date + <span class="string">'_2'</span>] / day</div><div class="line">    actions[before_date + <span class="string">'_3_mean'</span>] = actions[before_date + <span class="string">'_3'</span>] / day</div><div class="line">    actions[before_date + <span class="string">'_4_mean'</span>] = actions[before_date + <span class="string">'_4'</span>] / day</div><div class="line">    actions[before_date + <span class="string">'_5_mean'</span>] = actions[before_date + <span class="string">'_5'</span>] / day</div><div class="line">    actions[before_date + <span class="string">'_6_mean'</span>] = actions[before_date + <span class="string">'_6'</span>] / day</div><div class="line">    actions = pd.merge(actions, actions_date, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = actions[feature]</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h4 id="用户近期行为特征"><a href="#用户近期行为特征" class="headerlink" title="用户近期行为特征"></a>用户近期行为特征</h4><p>在上面针对用户进行累积特征提取的基础上，分别提取用户近一个月、近三天的特征，然后提取一个月内用户除去最近三天的行为占据一个月的行为的比重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_recent_user_feat</span><span class="params">(end_date, all_actions)</span>:</span></div><div class="line">    actions_3 = get_accumulate_user_feat(end_date, all_actions, <span class="number">3</span>)</div><div class="line">    actions_30 = get_accumulate_user_feat(end_date, all_actions, <span class="number">30</span>)</div><div class="line">    actions = pd.merge(actions_3, actions_30, how =<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    <span class="keyword">del</span> actions_3</div><div class="line">    <span class="keyword">del</span> actions_30</div><div class="line">    </div><div class="line">    actions[<span class="string">'recent_action1'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_1'</span>]-actions[<span class="string">'user_action_3_1'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_1'</span>])</div><div class="line">    actions[<span class="string">'recent_action2'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_2'</span>]-actions[<span class="string">'user_action_3_2'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_2'</span>])</div><div class="line">    actions[<span class="string">'recent_action3'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_3'</span>]-actions[<span class="string">'user_action_3_3'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_3'</span>])</div><div class="line">    actions[<span class="string">'recent_action4'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_4'</span>]-actions[<span class="string">'user_action_3_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_4'</span>])</div><div class="line">    actions[<span class="string">'recent_action5'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_5'</span>]-actions[<span class="string">'user_action_3_5'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_5'</span>])</div><div class="line">    actions[<span class="string">'recent_action6'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_6'</span>]-actions[<span class="string">'user_action_3_6'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'user_action_30_6'</span>])</div><div class="line">    </div><div class="line"><span class="comment">#     actions['recent_action1'] = (actions['user_action_30_1']-actions['user_action_3_1'])/actions['user_action_30_1']</span></div><div class="line"><span class="comment">#     actions['recent_action2'] = (actions['user_action_30_2']-actions['user_action_3_2'])/actions['user_action_30_2']</span></div><div class="line"><span class="comment">#     actions['recent_action3'] = (actions['user_action_30_3']-actions['user_action_3_3'])/actions['user_action_30_3']</span></div><div class="line"><span class="comment">#     actions['recent_action4'] = (actions['user_action_30_4']-actions['user_action_3_4'])/actions['user_action_30_4']</span></div><div class="line"><span class="comment">#     actions['recent_action5'] = (actions['user_action_30_5']-actions['user_action_3_5'])/actions['user_action_30_5']</span></div><div class="line"><span class="comment">#     actions['recent_action6'] = (actions['user_action_30_6']-actions['user_action_3_6'])/actions['user_action_30_6']</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h4 id="用户对同类别下各种商品的行为"><a href="#用户对同类别下各种商品的行为" class="headerlink" title="用户对同类别下各种商品的行为"></a>用户对同类别下各种商品的行为</h4><ul>
<li>用户对各个类别的各项行为操作统计</li>
<li>用户对各个类别操作行为统计占对所有类别操作行为统计的比重</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#增加了用户对不同类别的交互特征</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_cate_feature</span><span class="params">(start_date, end_date, all_actions)</span>:</span></div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line">    actions = actions[[<span class="string">'user_id'</span>, <span class="string">'cate'</span>, <span class="string">'type'</span>]]</div><div class="line">    df = pd.get_dummies(actions[<span class="string">'type'</span>], prefix=<span class="string">'type'</span>)</div><div class="line">    actions = pd.concat([actions[[<span class="string">'user_id'</span>, <span class="string">'cate'</span>]], df], axis=<span class="number">1</span>)</div><div class="line">    actions = actions.groupby([<span class="string">'user_id'</span>, <span class="string">'cate'</span>]).sum()</div><div class="line">    actions = actions.unstack()</div><div class="line">    actions.columns = actions.columns.swaplevel(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line">    actions.columns = actions.columns.droplevel()</div><div class="line">    actions.columns = [</div><div class="line">        <span class="string">'cate_4_type1'</span>, <span class="string">'cate_5_type1'</span>, <span class="string">'cate_6_type1'</span>, <span class="string">'cate_7_type1'</span>,</div><div class="line">        <span class="string">'cate_8_type1'</span>, <span class="string">'cate_9_type1'</span>, <span class="string">'cate_10_type1'</span>, <span class="string">'cate_11_type1'</span>,</div><div class="line">        <span class="string">'cate_4_type2'</span>, <span class="string">'cate_5_type2'</span>, <span class="string">'cate_6_type2'</span>, <span class="string">'cate_7_type2'</span>,</div><div class="line">        <span class="string">'cate_8_type2'</span>, <span class="string">'cate_9_type2'</span>, <span class="string">'cate_10_type2'</span>, <span class="string">'cate_11_type2'</span>,</div><div class="line">        <span class="string">'cate_4_type3'</span>, <span class="string">'cate_5_type3'</span>, <span class="string">'cate_6_type3'</span>, <span class="string">'cate_7_type3'</span>,</div><div class="line">        <span class="string">'cate_8_type3'</span>, <span class="string">'cate_9_type3'</span>, <span class="string">'cate_10_type3'</span>, <span class="string">'cate_11_type3'</span>,</div><div class="line">        <span class="string">'cate_4_type4'</span>, <span class="string">'cate_5_type4'</span>, <span class="string">'cate_6_type4'</span>, <span class="string">'cate_7_type4'</span>,</div><div class="line">        <span class="string">'cate_8_type4'</span>, <span class="string">'cate_9_type4'</span>, <span class="string">'cate_10_type4'</span>, <span class="string">'cate_11_type4'</span>,</div><div class="line">        <span class="string">'cate_4_type5'</span>, <span class="string">'cate_5_type5'</span>, <span class="string">'cate_6_type5'</span>, <span class="string">'cate_7_type5'</span>,</div><div class="line">        <span class="string">'cate_8_type5'</span>, <span class="string">'cate_9_type5'</span>, <span class="string">'cate_10_type5'</span>, <span class="string">'cate_11_type5'</span>,</div><div class="line">        <span class="string">'cate_4_type6'</span>, <span class="string">'cate_5_type6'</span>, <span class="string">'cate_6_type6'</span>, <span class="string">'cate_7_type6'</span>,</div><div class="line">        <span class="string">'cate_8_type6'</span>, <span class="string">'cate_9_type6'</span>, <span class="string">'cate_10_type6'</span>, <span class="string">'cate_11_type6'</span></div><div class="line">    ]</div><div class="line">    actions = actions.fillna(<span class="number">0</span>)</div><div class="line">    actions[<span class="string">'cate_action_sum'</span>] = actions.sum(axis=<span class="number">1</span>)</div><div class="line">    actions[<span class="string">'cate8_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_8_type1'</span>] + actions[<span class="string">'cate_8_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_8_type3'</span>] + actions[<span class="string">'cate_8_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_8_type5'</span>] + actions[<span class="string">'cate_8_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate4_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_4_type1'</span>] + actions[<span class="string">'cate_4_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_4_type3'</span>] + actions[<span class="string">'cate_4_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_4_type5'</span>] + actions[<span class="string">'cate_4_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate5_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_5_type1'</span>] + actions[<span class="string">'cate_5_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_5_type3'</span>] + actions[<span class="string">'cate_5_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_5_type5'</span>] + actions[<span class="string">'cate_5_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate6_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_6_type1'</span>] + actions[<span class="string">'cate_6_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_6_type3'</span>] + actions[<span class="string">'cate_6_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_6_type5'</span>] + actions[<span class="string">'cate_6_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate7_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_7_type1'</span>] + actions[<span class="string">'cate_7_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_7_type3'</span>] + actions[<span class="string">'cate_7_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_7_type5'</span>] + actions[<span class="string">'cate_7_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate9_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_9_type1'</span>] + actions[<span class="string">'cate_9_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_9_type3'</span>] + actions[<span class="string">'cate_9_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_9_type5'</span>] + actions[<span class="string">'cate_9_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate10_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_10_type1'</span>] + actions[<span class="string">'cate_10_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_10_type3'</span>] + actions[<span class="string">'cate_10_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_10_type5'</span>] + actions[<span class="string">'cate_10_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line">    actions[<span class="string">'cate11_percentage'</span>] = (</div><div class="line">        actions[<span class="string">'cate_11_type1'</span>] + actions[<span class="string">'cate_11_type2'</span>] +</div><div class="line">        actions[<span class="string">'cate_11_type3'</span>] + actions[<span class="string">'cate_11_type4'</span>] +</div><div class="line">        actions[<span class="string">'cate_11_type5'</span>] + actions[<span class="string">'cate_11_type6'</span>]</div><div class="line">    ) / actions[<span class="string">'cate_action_sum'</span>]</div><div class="line"></div><div class="line">    actions[<span class="string">'cate8_type1_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type1'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type1'</span>] + actions[<span class="string">'cate_4_type1'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type1'</span>] + actions[<span class="string">'cate_6_type1'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type1'</span>] + actions[<span class="string">'cate_9_type1'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type1'</span>] + actions[<span class="string">'cate_11_type1'</span>])</div><div class="line"></div><div class="line">    actions[<span class="string">'cate8_type2_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type2'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type2'</span>] + actions[<span class="string">'cate_4_type2'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type2'</span>] + actions[<span class="string">'cate_6_type2'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type2'</span>] + actions[<span class="string">'cate_9_type2'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type2'</span>] + actions[<span class="string">'cate_11_type2'</span>])</div><div class="line">    actions[<span class="string">'cate8_type3_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type3'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type3'</span>] + actions[<span class="string">'cate_4_type3'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type3'</span>] + actions[<span class="string">'cate_6_type3'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type3'</span>] + actions[<span class="string">'cate_9_type3'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type3'</span>] + actions[<span class="string">'cate_11_type3'</span>])</div><div class="line">    actions[<span class="string">'cate8_type4_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type4'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type4'</span>] + actions[<span class="string">'cate_4_type4'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type4'</span>] + actions[<span class="string">'cate_6_type4'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type4'</span>] + actions[<span class="string">'cate_9_type4'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type4'</span>] + actions[<span class="string">'cate_11_type4'</span>])</div><div class="line">    actions[<span class="string">'cate8_type5_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type5'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type5'</span>] + actions[<span class="string">'cate_4_type5'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type5'</span>] + actions[<span class="string">'cate_6_type5'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type5'</span>] + actions[<span class="string">'cate_9_type5'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type5'</span>] + actions[<span class="string">'cate_11_type5'</span>])</div><div class="line">    actions[<span class="string">'cate8_type6_percentage'</span>] = np.log(</div><div class="line">        <span class="number">1</span> + actions[<span class="string">'cate_8_type6'</span>]) - np.log(</div><div class="line">            <span class="number">1</span> + actions[<span class="string">'cate_8_type6'</span>] + actions[<span class="string">'cate_4_type6'</span>] +</div><div class="line">            actions[<span class="string">'cate_5_type6'</span>] + actions[<span class="string">'cate_6_type6'</span>] +</div><div class="line">            actions[<span class="string">'cate_7_type6'</span>] + actions[<span class="string">'cate_9_type6'</span>] +</div><div class="line">            actions[<span class="string">'cate_10_type6'</span>] + actions[<span class="string">'cate_11_type6'</span>])</div><div class="line">    actions[<span class="string">'user_id'</span>] = actions.index</div><div class="line">    actions = actions[[</div><div class="line">        <span class="string">'user_id'</span>, <span class="string">'cate8_percentage'</span>, <span class="string">'cate4_percentage'</span>, <span class="string">'cate5_percentage'</span>,</div><div class="line">        <span class="string">'cate6_percentage'</span>, <span class="string">'cate7_percentage'</span>, <span class="string">'cate9_percentage'</span>,</div><div class="line">        <span class="string">'cate10_percentage'</span>, <span class="string">'cate11_percentage'</span>, <span class="string">'cate8_type1_percentage'</span>,</div><div class="line">        <span class="string">'cate8_type2_percentage'</span>, <span class="string">'cate8_type3_percentage'</span>,</div><div class="line">        <span class="string">'cate8_type4_percentage'</span>, <span class="string">'cate8_type5_percentage'</span>,</div><div class="line">        <span class="string">'cate8_type6_percentage'</span></div><div class="line">    ]]</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h3 id="商品-行为"><a href="#商品-行为" class="headerlink" title="商品-行为"></a>商品-行为</h3><h4 id="累积商品特征"><a href="#累积商品特征" class="headerlink" title="累积商品特征"></a>累积商品特征</h4><ul>
<li>分时间段</li>
<li>针对商品的不同行为的<ul>
<li>购买转化率</li>
<li>均值</li>
<li>标准差</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_accumulate_product_feat</span><span class="params">(start_date, end_date, all_actions)</span>:</span></div><div class="line">    feature = [</div><div class="line">        <span class="string">'sku_id'</span>, <span class="string">'product_action_1'</span>, <span class="string">'product_action_2'</span>,</div><div class="line">        <span class="string">'product_action_3'</span>, <span class="string">'product_action_4'</span>,</div><div class="line">        <span class="string">'product_action_5'</span>, <span class="string">'product_action_6'</span>,</div><div class="line">        <span class="string">'product_action_1_ratio'</span>, <span class="string">'product_action_2_ratio'</span>,</div><div class="line">        <span class="string">'product_action_3_ratio'</span>, <span class="string">'product_action_5_ratio'</span>,</div><div class="line">        <span class="string">'product_action_6_ratio'</span>, <span class="string">'product_action_1_mean'</span>,</div><div class="line">        <span class="string">'product_action_2_mean'</span>, <span class="string">'product_action_3_mean'</span>,</div><div class="line">        <span class="string">'product_action_4_mean'</span>, <span class="string">'product_action_5_mean'</span>,</div><div class="line">        <span class="string">'product_action_6_mean'</span>, <span class="string">'product_action_1_std'</span>,</div><div class="line">        <span class="string">'product_action_2_std'</span>, <span class="string">'product_action_3_std'</span>, <span class="string">'product_action_4_std'</span>,</div><div class="line">        <span class="string">'product_action_5_std'</span>, <span class="string">'product_action_6_std'</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line">    df = pd.get_dummies(actions[<span class="string">'type'</span>], prefix=<span class="string">'product_action'</span>)</div><div class="line">    <span class="comment"># 按照商品-日期分组，计算某个时间段该商品的各项行为的标准差</span></div><div class="line"><span class="comment">#     actions['date'] = pd.to_datetime(actions['time']).apply(lambda x: x.date())</span></div><div class="line">    actions = pd.concat([actions[[<span class="string">'sku_id'</span>, <span class="string">'date'</span>]], df], axis=<span class="number">1</span>)</div><div class="line">    actions_date = actions.groupby([<span class="string">'sku_id'</span>, <span class="string">'date'</span>]).sum()</div><div class="line">    actions_date = actions_date.unstack()</div><div class="line">    actions_date.fillna(<span class="number">0</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    action_1 = np.std(actions_date[<span class="string">'product_action_1'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_1 = action_1.to_frame()</div><div class="line">    action_1.columns = [<span class="string">'product_action_1_std'</span>]</div><div class="line">    action_2 = np.std(actions_date[<span class="string">'product_action_2'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_2 = action_2.to_frame()</div><div class="line">    action_2.columns = [<span class="string">'product_action_2_std'</span>]</div><div class="line">    action_3 = np.std(actions_date[<span class="string">'product_action_3'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_3 = action_3.to_frame()</div><div class="line">    action_3.columns = [<span class="string">'product_action_3_std'</span>]</div><div class="line">    action_4 = np.std(actions_date[<span class="string">'product_action_4'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_4 = action_4.to_frame()</div><div class="line">    action_4.columns = [<span class="string">'product_action_4_std'</span>]</div><div class="line">    action_5 = np.std(actions_date[<span class="string">'product_action_5'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_5 = action_5.to_frame()</div><div class="line">    action_5.columns = [<span class="string">'product_action_5_std'</span>]</div><div class="line">    action_6 = np.std(actions_date[<span class="string">'product_action_6'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_6 = action_6.to_frame()</div><div class="line">    action_6.columns = [<span class="string">'product_action_6_std'</span>]</div><div class="line">    actions_date = pd.concat(</div><div class="line">        [action_1, action_2, action_3, action_4, action_5, action_6], axis=<span class="number">1</span>)</div><div class="line">    actions_date[<span class="string">'sku_id'</span>] = actions_date.index</div><div class="line"></div><div class="line">    actions = actions.groupby([<span class="string">'sku_id'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line">    days_interal = (datetime.strptime(end_date, <span class="string">'%Y-%m-%d'</span>) - datetime.strptime(start_date, <span class="string">'%Y-%m-%d'</span>)).days</div><div class="line">    <span class="comment"># 针对商品分组，计算购买转化率</span></div><div class="line"><span class="comment">#     actions['product_action_1_ratio'] = actions['product_action_4'] / actions[</span></div><div class="line"><span class="comment">#         'product_action_1']</span></div><div class="line"><span class="comment">#     actions['product_action_2_ratio'] = actions['product_action_4'] / actions[</span></div><div class="line"><span class="comment">#         'product_action_2']</span></div><div class="line"><span class="comment">#     actions['product_action_3_ratio'] = actions['product_action_4'] / actions[</span></div><div class="line"><span class="comment">#         'product_action_3']</span></div><div class="line"><span class="comment">#     actions['product_action_5_ratio'] = actions['product_action_4'] / actions[</span></div><div class="line"><span class="comment">#         'product_action_5']</span></div><div class="line"><span class="comment">#     actions['product_action_6_ratio'] = actions['product_action_4'] / actions[</span></div><div class="line"><span class="comment">#         'product_action_6']</span></div><div class="line">    actions[<span class="string">'product_action_1_ratio'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'product_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'product_action_1'</span>])</div><div class="line">    actions[<span class="string">'product_action_2_ratio'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'product_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'product_action_2'</span>])</div><div class="line">    actions[<span class="string">'product_action_3_ratio'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'product_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'product_action_3'</span>])</div><div class="line">    actions[<span class="string">'product_action_5_ratio'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'product_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'product_action_5'</span>])</div><div class="line">    actions[<span class="string">'product_action_6_ratio'</span>] =  np.log(<span class="number">1</span> + actions[<span class="string">'product_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'product_action_6'</span>])</div><div class="line">    <span class="comment"># 计算各种行为的均值</span></div><div class="line">    actions[<span class="string">'product_action_1_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_1'</span>] / days_interal</div><div class="line">    actions[<span class="string">'product_action_2_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_2'</span>] / days_interal</div><div class="line">    actions[<span class="string">'product_action_3_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_3'</span>] / days_interal</div><div class="line">    actions[<span class="string">'product_action_4_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_4'</span>] / days_interal</div><div class="line">    actions[<span class="string">'product_action_5_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_5'</span>] / days_interal</div><div class="line">    actions[<span class="string">'product_action_6_mean'</span>] = actions[</div><div class="line">        <span class="string">'product_action_6'</span>] / days_interal</div><div class="line">    actions = pd.merge(actions, actions_date, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = actions[feature]</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h3 id="类别特征"><a href="#类别特征" class="headerlink" title="类别特征"></a>类别特征</h3><p>分时间段下各个商品类别的</p>
<ul>
<li>购买转化率</li>
<li>标准差</li>
<li>均值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_accumulate_cate_feat</span><span class="params">(start_date, end_date, all_actions)</span>:</span></div><div class="line">    feature = [<span class="string">'cate'</span>,<span class="string">'cate_action_1'</span>, <span class="string">'cate_action_2'</span>, <span class="string">'cate_action_3'</span>, <span class="string">'cate_action_4'</span>, <span class="string">'cate_action_5'</span>, </div><div class="line">               <span class="string">'cate_action_6'</span>, <span class="string">'cate_action_1_ratio'</span>, <span class="string">'cate_action_2_ratio'</span>, </div><div class="line">               <span class="string">'cate_action_3_ratio'</span>, <span class="string">'cate_action_5_ratio'</span>, <span class="string">'cate_action_6_ratio'</span>, <span class="string">'cate_action_1_mean'</span>,</div><div class="line">               <span class="string">'cate_action_2_mean'</span>, <span class="string">'cate_action_3_mean'</span>, <span class="string">'cate_action_4_mean'</span>, <span class="string">'cate_action_5_mean'</span>,</div><div class="line">               <span class="string">'cate_action_6_mean'</span>, <span class="string">'cate_action_1_std'</span>, <span class="string">'cate_action_2_std'</span>, <span class="string">'cate_action_3_std'</span>,</div><div class="line">               <span class="string">'cate_action_4_std'</span>, <span class="string">'cate_action_5_std'</span>, <span class="string">'cate_action_6_std'</span>]</div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line"><span class="comment">#     actions['date'] = pd.to_datetime(actions['time']).apply(lambda x: x.date())</span></div><div class="line">    df = pd.get_dummies(actions[<span class="string">'type'</span>], prefix=<span class="string">'cate_action'</span>)</div><div class="line">    actions = pd.concat([actions[[<span class="string">'cate'</span>,<span class="string">'date'</span>]], df], axis=<span class="number">1</span>)</div><div class="line">    <span class="comment"># 按照类别-日期分组计算针对不同类别的各种行为某段时间的标准差</span></div><div class="line">    actions_date = actions.groupby([<span class="string">'cate'</span>,<span class="string">'date'</span>]).sum()</div><div class="line">    actions_date = actions_date.unstack()</div><div class="line">    actions_date.fillna(<span class="number">0</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    action_1 = np.std(actions_date[<span class="string">'cate_action_1'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_1 = action_1.to_frame()</div><div class="line">    action_1.columns = [<span class="string">'cate_action_1_std'</span>]</div><div class="line">    action_2 = np.std(actions_date[<span class="string">'cate_action_2'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_2 = action_2.to_frame()</div><div class="line">    action_2.columns = [<span class="string">'cate_action_2_std'</span>]</div><div class="line">    action_3 = np.std(actions_date[<span class="string">'cate_action_3'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_3 = action_3.to_frame()</div><div class="line">    action_3.columns = [<span class="string">'cate_action_3_std'</span>]</div><div class="line">    action_4 = np.std(actions_date[<span class="string">'cate_action_4'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_4 = action_4.to_frame()</div><div class="line">    action_4.columns = [<span class="string">'cate_action_4_std'</span>]</div><div class="line">    action_5 = np.std(actions_date[<span class="string">'cate_action_5'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_5 = action_5.to_frame()</div><div class="line">    action_5.columns = [<span class="string">'cate_action_5_std'</span>]</div><div class="line">    action_6 = np.std(actions_date[<span class="string">'cate_action_6'</span>], axis=<span class="number">1</span>)</div><div class="line">    action_6 = action_6.to_frame()</div><div class="line">    action_6.columns = [<span class="string">'cate_action_6_std'</span>]</div><div class="line">    actions_date = pd.concat([action_1, action_2, action_3, action_4, action_5, action_6], axis=<span class="number">1</span>)</div><div class="line">    actions_date[<span class="string">'cate'</span>] = actions_date.index</div><div class="line">    <span class="comment"># 按照类别分组，统计各个商品类别下行为的转化率</span></div><div class="line">    actions = actions.groupby([<span class="string">'cate'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line">    days_interal = (datetime.strptime(end_date, <span class="string">'%Y-%m-%d'</span>)-datetime.strptime(start_date, <span class="string">'%Y-%m-%d'</span>)).days</div><div class="line">    </div><div class="line"><span class="comment">#     actions['cate_action_1_ratio'] = actions['cate_action_4'] / actions['cate_action_1']</span></div><div class="line"><span class="comment">#     actions['cate_action_2_ratio'] = actions['cate_action_4'] / actions['cate_action_2']</span></div><div class="line"><span class="comment">#     actions['cate_action_3_ratio'] = actions['cate_action_4'] / actions['cate_action_3']</span></div><div class="line"><span class="comment">#     actions['cate_action_5_ratio'] = actions['cate_action_4'] / actions['cate_action_5']</span></div><div class="line"><span class="comment">#     actions['cate_action_6_ratio'] = actions['cate_action_4'] / actions['cate_action_6']</span></div><div class="line">    actions[<span class="string">'cate_action_1_ratio'</span>] =(np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_1'</span>]))</div><div class="line">    actions[<span class="string">'cate_action_2_ratio'</span>] =(np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_2'</span>]))</div><div class="line">    actions[<span class="string">'cate_action_3_ratio'</span>] =(np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_3'</span>]))</div><div class="line">    actions[<span class="string">'cate_action_5_ratio'</span>] =(np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_5'</span>]))</div><div class="line">    actions[<span class="string">'cate_action_6_ratio'</span>] =(np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_4'</span>]) - np.log(<span class="number">1</span> + actions[<span class="string">'cate_action_6'</span>]))</div><div class="line">    <span class="comment"># 按照类别分组，统计各个商品类别下行为在一段时间的均值</span></div><div class="line">    actions[<span class="string">'cate_action_1_mean'</span>] = actions[<span class="string">'cate_action_1'</span>] /  days_interal</div><div class="line">    actions[<span class="string">'cate_action_2_mean'</span>] = actions[<span class="string">'cate_action_2'</span>] /  days_interal</div><div class="line">    actions[<span class="string">'cate_action_3_mean'</span>] = actions[<span class="string">'cate_action_3'</span>] /  days_interal</div><div class="line">    actions[<span class="string">'cate_action_4_mean'</span>] = actions[<span class="string">'cate_action_4'</span>] /  days_interal</div><div class="line">    actions[<span class="string">'cate_action_5_mean'</span>] = actions[<span class="string">'cate_action_5'</span>] /  days_interal</div><div class="line">    actions[<span class="string">'cate_action_6_mean'</span>] = actions[<span class="string">'cate_action_6'</span>] /  days_interal</div><div class="line">    actions = pd.merge(actions, actions_date, how =<span class="string">'left'</span>,on=<span class="string">'cate'</span>)</div><div class="line">    actions = actions[feature]</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<h3 id="构造训练集-验证集"><a href="#构造训练集-验证集" class="headerlink" title="构造训练集/验证集"></a>构造训练集/验证集</h3><ul>
<li>标签,采用滑动窗口的方式，构造训练集的时候针对产生购买的行为标记为1</li>
<li>整合特征</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_labels</span><span class="params">(start_date, end_date, all_actions)</span>:</span></div><div class="line">    actions = get_actions(start_date, end_date, all_actions)</div><div class="line"><span class="comment">#     actions = actions[actions['type'] == 4]</span></div><div class="line">    <span class="comment"># 修改为预测购买了商品8的用户预测</span></div><div class="line">    actions = actions[(actions[<span class="string">'type'</span>] == <span class="number">4</span>) &amp; (actions[<span class="string">'cate'</span>]==<span class="number">8</span>)]</div><div class="line">    </div><div class="line">    actions = actions.groupby([<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>], as_index=<span class="keyword">False</span>).sum()</div><div class="line">    actions[<span class="string">'label'</span>] = <span class="number">1</span></div><div class="line">    actions = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'label'</span>]]</div><div class="line">    <span class="keyword">return</span> actions</div></pre></td></tr></table></figure>
<p>构造训练集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_actions</span><span class="params">(user, product, all_actions, train_start_date)</span>:</span></div><div class="line">    train_end_date = datetime.strptime(train_start_date, <span class="string">'%Y-%m-%d'</span>) + timedelta(days=<span class="number">3</span>)</div><div class="line">    train_end_date = train_end_date.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    <span class="comment"># 修正prod_acc,cate_acc的时间跨度</span></div><div class="line">    start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=<span class="number">30</span>)</div><div class="line">    start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    <span class="keyword">print</span> train_end_date</div><div class="line">    user_acc = get_recent_user_feat(train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_recent_user_feat finsihed'</span></div><div class="line">    </div><div class="line">    user_cate = get_user_cate_feature(train_start_date, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_user_cate_feature finished'</span></div><div class="line">    </div><div class="line">    product_acc = get_accumulate_product_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_product_feat finsihed'</span></div><div class="line">    cate_acc = get_accumulate_cate_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_cate_feat finsihed'</span></div><div class="line">    comment_acc = get_comments_product_feat(train_end_date)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_comments_product_feat finished'</span></div><div class="line">    <span class="comment"># 标记</span></div><div class="line">    test_start_date = train_end_date</div><div class="line">    test_end_date = datetime.strptime(test_start_date, <span class="string">'%Y-%m-%d'</span>) + timedelta(days=<span class="number">5</span>)</div><div class="line">    test_end_date = test_end_date.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    labels = get_labels(test_start_date, test_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">"get labels"</span></div><div class="line">    </div><div class="line">    actions = <span class="keyword">None</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">30</span>):</div><div class="line">        start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=i)</div><div class="line">        start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">        <span class="keyword">if</span> actions <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            actions = get_action_feat(start_days, train_end_date, all_actions, i)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 注意这里的拼接key</span></div><div class="line">            actions = pd.merge(actions, get_action_feat(start_days, train_end_date, all_actions, i), how=<span class="string">'left'</span>,</div><div class="line">                               on=[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line"></div><div class="line">    actions = pd.merge(actions, user, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_acc, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_cate, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    <span class="comment"># 注意这里的拼接key</span></div><div class="line">    actions = pd.merge(actions, product, how=<span class="string">'left'</span>, on=[<span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line">    actions = pd.merge(actions, product_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = pd.merge(actions, cate_acc, how=<span class="string">'left'</span>, on=<span class="string">'cate'</span>)</div><div class="line">    actions = pd.merge(actions, comment_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = pd.merge(actions, labels, how=<span class="string">'left'</span>, on=[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>])</div><div class="line">    <span class="comment"># 主要是填充拼接商品基本特征、评论特征、标签之后的空值</span></div><div class="line">    actions = actions.fillna(<span class="number">0</span>)</div><div class="line"><span class="comment">#     return actions</span></div><div class="line">    <span class="comment"># 采样</span></div><div class="line">    action_postive = actions[actions[<span class="string">'label'</span>] == <span class="number">1</span>]</div><div class="line">    action_negative = actions[actions[<span class="string">'label'</span>] == <span class="number">0</span>]</div><div class="line">    <span class="keyword">del</span> actions</div><div class="line">    neg_len = len(action_postive) * <span class="number">10</span></div><div class="line">    action_negative = action_negative.sample(n=neg_len)</div><div class="line">    action_sample = pd.concat([action_postive, action_negative], ignore_index=<span class="keyword">True</span>)    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> action_sample</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_train_set</span><span class="params">(train_start_date, setNums ,f_path)</span>:</span></div><div class="line">    train_actions = <span class="keyword">None</span></div><div class="line">    all_actions = get_all_action()</div><div class="line">    <span class="keyword">print</span> <span class="string">"get all actions!"</span></div><div class="line">    user = get_basic_user_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_user_feat finsihed'</span></div><div class="line">    product = get_basic_product_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_product_feat finsihed'</span></div><div class="line">    <span class="comment"># 滑窗,构造多组训练集/验证集</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(setNums):</div><div class="line">        <span class="keyword">print</span> train_start_date</div><div class="line">        <span class="keyword">if</span> train_actions <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            train_actions = make_actions(user, product, all_actions, train_start_date)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            train_actions = pd.concat([train_actions, make_actions(user, product, all_actions, train_start_date)],</div><div class="line">                                          ignore_index=<span class="keyword">True</span>)</div><div class="line">        <span class="comment"># 接下来每次移动一天</span></div><div class="line">        train_start_date = datetime.strptime(train_start_date, <span class="string">'%Y-%m-%d'</span>) + timedelta(days=<span class="number">1</span>)</div><div class="line">        train_start_date = train_start_date.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">"round &#123;0&#125;/&#123;1&#125; over!"</span>.format(i+<span class="number">1</span>, setNums)</div><div class="line"></div><div class="line">    train_actions.to_csv(f_path, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 训练集</span></div><div class="line">train_start_date = <span class="string">'2016-03-01'</span></div><div class="line">make_train_set(train_start_date, <span class="number">34</span>, <span class="string">'train_set.csv'</span>)</div></pre></td></tr></table></figure>
<p>构造线下测试集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_val_answer</span><span class="params">(val_start_date, val_end_date, all_actions, label_val_s1_path)</span>:</span></div><div class="line">    actions = get_actions(val_start_date, val_end_date,all_actions)</div><div class="line">    actions = actions[(actions[<span class="string">'type'</span>] == <span class="number">4</span>) &amp; (actions[<span class="string">'cate'</span>] == <span class="number">8</span>)]</div><div class="line">    actions = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>]]</div><div class="line">    actions = actions.drop_duplicates()</div><div class="line">    actions.to_csv(label_val_s1_path, index=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_val_set</span><span class="params">(train_start_date, train_end_date, val_s1_path)</span>:</span></div><div class="line">    <span class="comment"># 修改时间跨度</span></div><div class="line">    start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=<span class="number">30</span>)</div><div class="line">    start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    all_actions = get_all_action()</div><div class="line">    <span class="keyword">print</span> <span class="string">"get all actions!"</span></div><div class="line">    user = get_basic_user_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_user_feat finsihed'</span></div><div class="line">    </div><div class="line">    product = get_basic_product_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_product_feat finsihed'</span></div><div class="line"><span class="comment">#     user_acc = get_accumulate_user_feat(train_end_date,all_actions,30)</span></div><div class="line"><span class="comment">#     print 'get_accumulate_user_feat finished'</span></div><div class="line">    user_acc = get_recent_user_feat(train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_recent_user_feat finsihed'</span></div><div class="line">    user_cate = get_user_cate_feature(train_start_date, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_user_cate_feature finished'</span></div><div class="line"> </div><div class="line">    product_acc = get_accumulate_product_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_product_feat finsihed'</span></div><div class="line">    cate_acc = get_accumulate_cate_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_cate_feat finsihed'</span></div><div class="line">    comment_acc = get_comments_product_feat(train_end_date)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_comments_product_feat finished'</span></div><div class="line">    </div><div class="line">    actions = <span class="keyword">None</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">30</span>):</div><div class="line">        start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=i)</div><div class="line">        start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">        <span class="keyword">if</span> actions <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            actions = get_action_feat(start_days, train_end_date, all_actions,i)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            actions = pd.merge(actions, get_action_feat(start_days, train_end_date,all_actions,i), how=<span class="string">'left'</span>,</div><div class="line">                               on=[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line"></div><div class="line">    actions = pd.merge(actions, user, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_acc, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_cate, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    <span class="comment"># 注意这里的拼接key</span></div><div class="line">    actions = pd.merge(actions, product, how=<span class="string">'left'</span>, on=[<span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line">    actions = pd.merge(actions, product_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = pd.merge(actions, cate_acc, how=<span class="string">'left'</span>, on=<span class="string">'cate'</span>)</div><div class="line">    actions = pd.merge(actions, comment_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = actions.fillna(<span class="number">0</span>)</div><div class="line">   </div><div class="line">    </div><div class="line"><span class="comment">#     print actions</span></div><div class="line">    <span class="comment"># 构造真实用户购买情况作为后续验证</span></div><div class="line">    val_start_date = train_end_date</div><div class="line">    val_end_date = datetime.strptime(val_start_date, <span class="string">'%Y-%m-%d'</span>) + timedelta(days=<span class="number">5</span>)</div><div class="line">    val_end_date = val_end_date.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    make_val_answer(val_start_date, val_end_date, all_actions, <span class="string">'label_'</span>+val_s1_path)</div><div class="line">    </div><div class="line">    actions.to_csv(val_s1_path, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 验证集</span></div><div class="line"><span class="comment"># train_start_date = '2016-04-06'</span></div><div class="line"><span class="comment"># make_train_set(train_start_date, 3, 'val_set.csv')</span></div><div class="line">make_val_set(<span class="string">'2016-04-06'</span>, <span class="string">'2016-04-09'</span>, <span class="string">'val_1.csv'</span>)</div><div class="line">make_val_set(<span class="string">'2016-04-07'</span>, <span class="string">'2016-04-10'</span>, <span class="string">'val_2.csv'</span>)</div><div class="line">make_val_set(<span class="string">'2016-04-08'</span>, <span class="string">'2016-04-11'</span>, <span class="string">'val_3.csv'</span>)</div></pre></td></tr></table></figure>
<h3 id="构造测试集"><a href="#构造测试集" class="headerlink" title="构造测试集"></a>构造测试集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_test_set</span><span class="params">(train_start_date, train_end_date)</span>:</span></div><div class="line">    start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=<span class="number">30</span>)</div><div class="line">    start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    all_actions = get_all_action()</div><div class="line">    <span class="keyword">print</span> <span class="string">"get all actions!"</span></div><div class="line">    user = get_basic_user_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_user_feat finsihed'</span></div><div class="line">    product = get_basic_product_feat()</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_basic_product_feat finsihed'</span></div><div class="line">    </div><div class="line">    user_acc = get_recent_user_feat(train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_user_feat finsihed'</span></div><div class="line">    </div><div class="line">    user_cate = get_user_cate_feature(train_start_date, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_user_cate_feature finished'</span></div><div class="line">    </div><div class="line">    product_acc = get_accumulate_product_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_product_feat finsihed'</span></div><div class="line">    cate_acc = get_accumulate_cate_feat(start_days, train_end_date, all_actions)</div><div class="line">    <span class="keyword">print</span> <span class="string">'get_accumulate_cate_feat finsihed'</span></div><div class="line">    comment_acc = get_comments_product_feat(train_end_date)</div><div class="line"></div><div class="line">    actions = <span class="keyword">None</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">30</span>):</div><div class="line">        start_days = datetime.strptime(train_end_date, <span class="string">'%Y-%m-%d'</span>) - timedelta(days=i)</div><div class="line">        start_days = start_days.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">        <span class="keyword">if</span> actions <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            actions = get_action_feat(start_days, train_end_date, all_actions,i)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            actions = pd.merge(actions, get_action_feat(start_days, train_end_date,all_actions,i), how=<span class="string">'left'</span>,</div><div class="line">                               on=[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line"></div><div class="line">    actions = pd.merge(actions, user, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_acc, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    actions = pd.merge(actions, user_cate, how=<span class="string">'left'</span>, on=<span class="string">'user_id'</span>)</div><div class="line">    <span class="comment"># 注意这里的拼接key</span></div><div class="line">    actions = pd.merge(actions, product, how=<span class="string">'left'</span>, on=[<span class="string">'sku_id'</span>, <span class="string">'cate'</span>])</div><div class="line">    actions = pd.merge(actions, product_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line">    actions = pd.merge(actions, cate_acc, how=<span class="string">'left'</span>, on=<span class="string">'cate'</span>)</div><div class="line">    actions = pd.merge(actions, comment_acc, how=<span class="string">'left'</span>, on=<span class="string">'sku_id'</span>)</div><div class="line"></div><div class="line">    actions = actions.fillna(<span class="number">0</span>)</div><div class="line">    </div><div class="line"></div><div class="line">    actions.to_csv(<span class="string">"test_set.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>4.13~4.16这三天的评论记录似乎并不存在为0的情况，导致构建测试集时出错</p>
<p><code>KeyError: &quot;[&#39;comment_num_0&#39;] not in index&quot;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测结果</span></div><div class="line">sub_start_date = <span class="string">'2016-04-13'</span></div><div class="line">sub_end_date = <span class="string">'2016-04-16'</span></div><div class="line">make_test_set(sub_start_date, sub_end_date)</div></pre></td></tr></table></figure>
<h2 id="模型设计和评估"><a href="#模型设计和评估" class="headerlink" title="模型设计和评估"></a>模型设计和评估</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">import</span> operator</div><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pylab <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># import gc</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_record</span><span class="params">()</span>:</span></div><div class="line">    train = pd.read_csv(<span class="string">'train_set.csv'</span>)</div><div class="line"><span class="comment">#     valid = pd.read_csv('val_set.csv')</span></div><div class="line"><span class="comment">#     label_val = pd.read_csv('label_val_set.csv')</span></div><div class="line">    valid1 = pd.read_csv(<span class="string">'val_1.csv'</span>)</div><div class="line">    valid2 = pd.read_csv(<span class="string">'val_2.csv'</span>)</div><div class="line">    valid3 = pd.read_csv(<span class="string">'val_3.csv'</span>)</div><div class="line"><span class="comment">#     test = pd.read_csv('test_set.csv')</span></div><div class="line">    <span class="keyword">print</span> train.shape</div><div class="line"><span class="comment">#     print valid.shape</span></div><div class="line"><span class="comment">#     print label_val.shape</span></div><div class="line"><span class="comment">#     print test.shape</span></div><div class="line">    <span class="keyword">print</span> valid1.shape</div><div class="line">    <span class="keyword">print</span> valid2.shape</div><div class="line">    <span class="keyword">print</span> valid3.shape</div><div class="line"></div><div class="line"><span class="comment"># show_record()</span></div><div class="line"><span class="comment"># del train, valid, test</span></div><div class="line"><span class="comment"># gc.collect()</span></div></pre></td></tr></table></figure>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><ul>
<li>返回训练后的模型</li>
<li>生成特征map文件作为后续特征重要性之用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_feature_map</span><span class="params">(features)</span>:</span></div><div class="line">    outfile = open(<span class="string">r'xgb.fmap'</span>, <span class="string">'w'</span>)</div><div class="line">    i = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> feat <span class="keyword">in</span> features:</div><div class="line">        outfile.write(<span class="string">'&#123;0&#125;\t&#123;1&#125;\tq\n'</span>.format(i, feat))</div><div class="line">        i = i + <span class="number">1</span></div><div class="line">    outfile.close()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xgb_model</span><span class="params">(train_set)</span>:</span></div><div class="line">    actions = pd.read_csv(train_set)             <span class="comment">#read train_set</span></div><div class="line">    <span class="comment"># 单纯的删掉模型前一遍训练认为无用的特征（根据特征重要性中不存在的特征）</span></div><div class="line">    lst_useless = [<span class="string">'brand'</span>]</div><div class="line">    </div><div class="line">    actions.drop(lst_useless, inplace=<span class="keyword">True</span>, axis=<span class="number">1</span>)</div><div class="line">    </div><div class="line">    users = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>]].copy()</div><div class="line">    labels = actions[<span class="string">'label'</span>].copy()</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'user_id'</span>]</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'sku_id'</span>]</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'label'</span>]</div><div class="line">    <span class="comment"># 尝试通过设置scale_pos_weight来调整政府比例不均的问题，但是经过采样的正负比为1:10，训练结果反而不如设置为1</span></div><div class="line"><span class="comment">#     ratio = float(np.sum(labels==0)) / np.sum(labels==1)</span></div><div class="line"><span class="comment">#     print ratio</span></div><div class="line">    </div><div class="line">    <span class="comment"># write to feature map</span></div><div class="line">    features = list(actions.columns[:])</div><div class="line">    <span class="keyword">print</span> <span class="string">'total features: '</span>, len(features)</div><div class="line">    create_feature_map(features)</div><div class="line">    <span class="comment"># 训练时即传入特征名</span></div><div class="line"><span class="comment">#     features = list(actions.columns.values)</span></div><div class="line">    </div><div class="line">    user_index=users</div><div class="line">    training_data=actions</div><div class="line">    label=labels</div><div class="line">    X_train, X_valid, y_train, y_valid = train_test_split(training_data.values, label.values, test_size=<span class="number">0.2</span>, </div><div class="line">                                                          random_state=<span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 尝试通过提前设置传入训练的正负例的权重来改善正负比例不均的问题</span></div><div class="line"><span class="comment">#     weights = np.zeros(len(y_train))</span></div><div class="line"><span class="comment">#     weights[y_train==0] = 1</span></div><div class="line"><span class="comment">#     weights[y_train==1] = 10</span></div><div class="line">    </div><div class="line"><span class="comment">#     dtrain = xgb.DMatrix(X_train, label=y_train, weight=weights)</span></div><div class="line">    dtrain = xgb.DMatrix(X_train, label=y_train)</div><div class="line">    dvalid = xgb.DMatrix(X_valid, label=y_valid)</div><div class="line"><span class="comment">#     dtrain = xgb.DMatrix(X_train, label=y_train, feature_names=features)</span></div><div class="line"><span class="comment">#     dvalid = xgb.DMatrix(X_valid, label=y_valid, feature_names=features)</span></div><div class="line"><span class="comment">#     dtrain = xgb.DMatrix(training_data.values, label.values)</span></div><div class="line">    param = &#123;<span class="string">'n_estimators'</span>: <span class="number">4000</span>, <span class="string">'max_depth'</span>: <span class="number">3</span>, <span class="string">'min_child_weight'</span>: <span class="number">5</span>, <span class="string">'gamma'</span>: <span class="number">0</span>, <span class="string">'subsample'</span>: <span class="number">1.0</span>, </div><div class="line">             <span class="string">'colsample_bytree'</span>: <span class="number">0.8</span>, <span class="string">'scale_pos_weight'</span>:<span class="number">10</span>, <span class="string">'eta'</span>: <span class="number">0.1</span>, <span class="string">'silent'</span>: <span class="number">1</span>, <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>,</div><div class="line">             <span class="string">'eval_metric'</span>:<span class="string">'auc'</span>&#125;</div><div class="line"><span class="comment">#     param = &#123;'n_estimators': 4000, 'max_depth': 6, 'seed': 7, 'min_child_weight': 5, 'gamma': 0, 'subsample': 1.0, </span></div><div class="line"><span class="comment">#              'colsample_bytree': 0.8, 'scale_pos_weight': 1, 'eta': 0.09, 'silent': 1, 'objective': 'binary:logistic',</span></div><div class="line"><span class="comment">#              'eval_metric':'auc'&#125;</span></div><div class="line">    </div><div class="line">    num_round = param[<span class="string">'n_estimators'</span>]</div><div class="line"><span class="comment">#     param['nthread'] = 4</span></div><div class="line">    <span class="comment"># param['eval_metric'] = "auc"</span></div><div class="line">    plst = param.items()</div><div class="line">    evallist = [(dtrain, <span class="string">'train'</span>), (dvalid, <span class="string">'eval'</span>)]</div><div class="line"><span class="comment">#     evallist = [(dvalid, 'eval'), (dtrain, 'train')]</span></div><div class="line"><span class="comment">#     evallist = [(dtrain, 'train')]</span></div><div class="line">    bst = xgb.train(plst, dtrain, num_round, evallist, early_stopping_rounds=<span class="number">10</span>)</div><div class="line">    bst.save_model(<span class="string">'bst.model'</span>)</div><div class="line">    <span class="keyword">return</span> bst, features</div><div class="line"></div><div class="line">bst_xgb, features = xgb_model(<span class="string">'train_set.csv'</span>)</div></pre></td></tr></table></figure>
<pre><code>total features:  301
[0]    train-auc:0.913108    eval-auc:0.911621
Multiple eval metrics have been passed: &apos;eval-auc&apos; will be used for early stopping.

Will train until eval-auc hasn&apos;t improved in 10 rounds.
[1]    train-auc:0.932872    eval-auc:0.930423
[2]    train-auc:0.936241    eval-auc:0.93338
...
[416]    train-auc:0.982069    eval-auc:0.976755
[417]    train-auc:0.982076    eval-auc:0.976751
[418]    train-auc:0.982087    eval-auc:0.976753
Stopping. Best iteration:
[408]    train-auc:0.981964    eval-auc:0.976777
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> bst_xgb.attributes()</div></pre></td></tr></table></figure>
<pre><code>{&apos;best_iteration&apos;: &apos;408&apos;, &apos;best_msg&apos;: &apos;[408]\ttrain-auc:0.981964\teval-auc:0.976777&apos;, &apos;best_score&apos;: &apos;0.976777&apos;}
</code></pre><h3 id="对验证集进行线下测试"><a href="#对验证集进行线下测试" class="headerlink" title="对验证集进行线下测试"></a>对验证集进行线下测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(pred, label)</span>:</span></div><div class="line"></div><div class="line">    actions = label</div><div class="line">    result = pred</div><div class="line"></div><div class="line">    <span class="comment"># 所有实际用户商品对</span></div><div class="line">    all_user_item_pair = actions[<span class="string">'user_id'</span>].map(str) + <span class="string">'-'</span> + actions[<span class="string">'sku_id'</span>].map(str)</div><div class="line">    all_user_item_pair = np.array(all_user_item_pair)</div><div class="line">    <span class="comment"># 所有购买用户</span></div><div class="line">    all_user_set = actions[<span class="string">'user_id'</span>].unique()</div><div class="line"></div><div class="line">    <span class="comment"># 所有预测购买的用户</span></div><div class="line">    all_user_test_set = result[<span class="string">'user_id'</span>].unique()</div><div class="line">    all_user_test_item_pair = result[<span class="string">'user_id'</span>].map(str) + <span class="string">'-'</span> + result[<span class="string">'sku_id'</span>].map(str)</div><div class="line">    all_user_test_item_pair = np.array(all_user_test_item_pair)</div><div class="line"></div><div class="line">    <span class="comment"># 计算所有用户购买评价指标</span></div><div class="line">    pos, neg = <span class="number">0</span>,<span class="number">0</span></div><div class="line">    <span class="keyword">for</span> user_id <span class="keyword">in</span> all_user_test_set:</div><div class="line">        <span class="keyword">if</span> user_id <span class="keyword">in</span> all_user_set:</div><div class="line">            pos += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            neg += <span class="number">1</span></div><div class="line">    all_user_acc = <span class="number">1.0</span> * pos / ( pos + neg)</div><div class="line">    all_user_recall = <span class="number">1.0</span> * pos / len(all_user_set)</div><div class="line">    <span class="keyword">print</span> <span class="string">'所有用户中预测购买用户的准确率为 '</span> + str(all_user_acc)</div><div class="line">    <span class="keyword">print</span> <span class="string">'所有用户中预测购买用户的召回率'</span> + str(all_user_recall)</div><div class="line"></div><div class="line">    pos, neg = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> user_item_pair <span class="keyword">in</span> all_user_test_item_pair:</div><div class="line">        <span class="keyword">if</span> user_item_pair <span class="keyword">in</span> all_user_item_pair:</div><div class="line">            pos += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            neg += <span class="number">1</span></div><div class="line">    all_item_acc = <span class="number">1.0</span> * pos / ( pos + neg)</div><div class="line">    all_item_recall = <span class="number">1.0</span> * pos / len(all_user_item_pair)</div><div class="line">    <span class="keyword">print</span> <span class="string">'所有用户中预测购买商品的准确率为 '</span> + str(all_item_acc)</div><div class="line">    <span class="keyword">print</span> <span class="string">'所有用户中预测购买商品的召回率'</span> + str(all_item_recall)</div><div class="line">    F11 = <span class="number">6.0</span> * all_user_recall * all_user_acc / (<span class="number">5.0</span> * all_user_recall + all_user_acc)</div><div class="line">    F12 = <span class="number">5.0</span> * all_item_acc * all_item_recall / (<span class="number">2.0</span> * all_item_recall + <span class="number">3</span> * all_item_acc)</div><div class="line">    score = <span class="number">0.4</span> * F11 + <span class="number">0.6</span> * F12</div><div class="line">    <span class="keyword">print</span> <span class="string">'F11='</span> + str(F11)</div><div class="line">    <span class="keyword">print</span> <span class="string">'F12='</span> + str(F12)</div><div class="line">    <span class="keyword">print</span> <span class="string">'score='</span> + str(score)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> all_user_acc, all_user_recall, F11, all_item_acc, all_item_recall, F12, score</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(valid_set, val_label, model)</span>:</span></div><div class="line">    actions = pd.read_csv(valid_set)                <span class="comment">#read test_set        </span></div><div class="line"><span class="comment">#     users = actions[['user_id', 'sku_id']].copy()</span></div><div class="line">    <span class="comment"># 避免预测到非8类商品，所以最后还是再筛一遍的好        </span></div><div class="line">    users = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>]].copy()</div><div class="line">    </div><div class="line">    actions[<span class="string">'user_id'</span>] = actions[<span class="string">'user_id'</span>].astype(np.int64)</div><div class="line"><span class="comment">#     test_label= actions[actions['label'] == 1]</span></div><div class="line"></div><div class="line"><span class="comment">#     test_label= actions[(actions['label']==1) &amp; (actions['cate']==8)]</span></div><div class="line">    test_label = pd.read_csv(val_label)</div><div class="line">    </div><div class="line">    lst_useless = [<span class="string">'brand'</span>]</div><div class="line">    </div><div class="line">    actions.drop(lst_useless, inplace=<span class="keyword">True</span>, axis=<span class="number">1</span>)</div><div class="line">    </div><div class="line"><span class="comment">#     test_label = test_label[['user_id','sku_id','label']]</span></div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'user_id'</span>]</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'sku_id'</span>]</div><div class="line">    </div><div class="line"><span class="comment">#     features = list(actions.columns.values)</span></div><div class="line">    </div><div class="line"><span class="comment">#     del actions['label']</span></div><div class="line">    sub_user_index = users</div><div class="line"><span class="comment">#     sub_trainning_data = xgb.DMatrix(actions.values, feature_names=features)</span></div><div class="line">    sub_trainning_data = xgb.DMatrix(actions.values)</div><div class="line"><span class="comment">#     y = model.predict(sub_trainning_data,ntree_limit=model.best_iteration)</span></div><div class="line">    y = model.predict(sub_trainning_data, ntree_limit=model.best_ntree_limit)</div><div class="line">    sub_user_index[<span class="string">'label'</span>] = y</div><div class="line">    </div><div class="line">    sub_user_index.to_csv(<span class="string">'result_'</span> + valid_set, index=<span class="keyword">False</span>)</div><div class="line">    </div><div class="line"><span class="comment">#     sub_user_index = sub_user_index[sub_user_index['cate']==8]</span></div><div class="line"><span class="comment">#     del sub_user_index['cate']</span></div><div class="line">    rank = <span class="number">1000</span></div><div class="line">    pred = sub_user_index.sort_values(by=<span class="string">'label'</span>, ascending=<span class="keyword">False</span>)[:rank]</div><div class="line"><span class="comment">#     pred = sub_user_index[sub_user_index['label'] &gt;= 0.05]</span></div><div class="line">    </div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of raw pred users: '</span>, len(pred[<span class="string">'user_id'</span>].unique())</div><div class="line">    pred = pred[pred[<span class="string">'cate'</span>]==<span class="number">8</span>]</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of pred users bought cate 8: '</span>, len(pred[<span class="string">'user_id'</span>].unique())</div><div class="line">    </div><div class="line"><span class="comment">#     pred = pred[['user_id', 'sku_id']]</span></div><div class="line">    pred = pred[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'label'</span>]]</div><div class="line">    pred = pred.groupby(<span class="string">'user_id'</span>).first().reset_index()</div><div class="line">    pred[<span class="string">'user_id'</span>] = pred[<span class="string">'user_id'</span>].astype(int)</div><div class="line">    pred[<span class="string">'sku_id'</span>] = pred[<span class="string">'sku_id'</span>].astype(int)</div><div class="line">    </div><div class="line"><span class="comment">#     print 'No. of pred users after deduplicates: ', len(pred['user_id'].unique())</span></div><div class="line">    true_user = len(test_label[<span class="string">'user_id'</span>])   </div><div class="line">    pred_ui = len(pred[<span class="string">'user_id'</span>].unique())</div><div class="line">    <span class="keyword">print</span> <span class="string">'pred item: '</span>, len(pred[<span class="string">'sku_id'</span>].unique())</div><div class="line">    <span class="keyword">print</span> <span class="string">'true users: '</span>, true_user</div><div class="line">    <span class="keyword">print</span> <span class="string">'pred users: '</span>, pred_ui</div><div class="line">    test_label[<span class="string">'user_id'</span>] = test_label[<span class="string">'user_id'</span>].astype(int)</div><div class="line">    test_label[<span class="string">'sku_id'</span>] = test_label[<span class="string">'sku_id'</span>].astype(int)</div><div class="line"></div><div class="line">    all_user_acc, all_user_recall, F11, all_item_acc, all_item_recall, F12, score = report(pred, test_label)   </div><div class="line">    </div><div class="line">    f_name = <span class="string">'pred_'</span> + str(rank) + <span class="string">'_'</span> + valid_set</div><div class="line">    pred.to_csv(f_name, index=<span class="keyword">False</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> rank, true_user, pred_ui, all_user_acc, all_user_recall, F11, all_item_acc, all_item_recall, F12, score</div><div class="line"></div><div class="line"><span class="comment"># validate('val_set.csv', bst_xgb)</span></div></pre></td></tr></table></figure>
<p>评分文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg_score</span><span class="params">()</span>:</span></div><div class="line">    rank1, true_user1, pred_ui1, user_acc1, user_recall1, F11_1, item_acc1, item_recall1, F12_1, score1 = validate(<span class="string">'val_1.csv'</span>, <span class="string">'label_val_1.csv'</span>, bst_xgb)</div><div class="line">    <span class="keyword">print</span> <span class="string">'-------------------------------------------'</span></div><div class="line">    rank2, true_user2, pred_ui2, user_acc2, user_recall2, F11_2, item_acc2, item_recall2, F12_2, score2 = validate(<span class="string">'val_2.csv'</span>, <span class="string">'label_val_2.csv'</span>, bst_xgb)</div><div class="line">    <span class="keyword">print</span> <span class="string">'-------------------------------------------'</span></div><div class="line">    rank3, true_user3, pred_ui3, user_acc3, user_recall3, F11_3, item_acc3, item_recall3, F12_3, score3 = validate(<span class="string">'val_3.csv'</span>, <span class="string">'label_val_3.csv'</span>, bst_xgb)</div><div class="line">    <span class="keyword">print</span> <span class="string">'==========================================='</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg user acc: '</span>, (user_acc1+user_acc2+user_acc3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg user recall: '</span>, (user_recall1+user_recall2+user_recall3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg item acc: '</span>, (item_acc1+item_acc2+item_acc3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg item recall: '</span>, (item_recall1+item_recall2+item_recall3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg F11: '</span>, (F11_1+F11_2+F11_3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg F12: '</span>, (F12_1+F12_2+F12_3)/<span class="number">3</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'avg score: '</span>, (score1+score2+score3)/<span class="number">3</span></div><div class="line">    <span class="comment"># make the csv file</span></div><div class="line">    dct_score = &#123;&#125;</div><div class="line">    dct_score[<span class="string">'rank'</span>] = [rank1, rank2, rank3]</div><div class="line">    dct_score[<span class="string">'true_user'</span>] = [true_user1, true_user2, true_user3]</div><div class="line">    dct_score[<span class="string">'pred_ui'</span>] = [pred_ui1, pred_ui2, pred_ui3]</div><div class="line">    dct_score[<span class="string">'user_acc'</span>] = [user_acc1, user_acc2, user_acc3]</div><div class="line">    dct_score[<span class="string">'user_recall'</span>] = [user_recall1, user_recall2, user_recall3]</div><div class="line">    dct_score[<span class="string">'F11'</span>] = [F11_1, F11_2, F11_3]</div><div class="line">    dct_score[<span class="string">'item_acc'</span>] = [item_acc1, item_acc2, item_acc3]</div><div class="line">    dct_score[<span class="string">'item_recall'</span>] = [item_recall1, item_recall2, item_recall3]</div><div class="line">    dct_score[<span class="string">'F12'</span>] = [F12_1, F12_2, F12_3]</div><div class="line">    dct_score[<span class="string">'score'</span>] = [score1, score2, score3]</div><div class="line">    column_order = [<span class="string">'rank'</span>, <span class="string">'true_user'</span>, <span class="string">'pred_ui'</span>, <span class="string">'user_acc'</span>, <span class="string">'user_recall'</span>, <span class="string">'item_acc'</span>, <span class="string">'item_recall'</span>, <span class="string">'F11'</span>, <span class="string">'F12'</span>, </div><div class="line">                    <span class="string">'score'</span>]</div><div class="line">    df_score = pd.DataFrame(dct_score)</div><div class="line">    file_name = <span class="string">'score_'</span> + str(datetime.now().date())[<span class="number">5</span>:] +<span class="string">'_'</span>+ str(rank1) + <span class="string">'.csv'</span></div><div class="line">    df_score[column_order].to_csv(file_name, index=<span class="keyword">False</span>)</div><div class="line">avg_score()</div></pre></td></tr></table></figure>
<pre><code>No. of raw pred users:  950
No. of pred users bought cate 8:  950
pred item:  220
true users:  1211
pred users:  950
所有用户中预测购买用户的准确率为 0.147368421053
所有用户中预测购买用户的召回率0.116569525396
所有用户中预测购买商品的准确率为 0.108421052632
所有用户中预测购买商品的召回率0.0850536746491
F11=0.141152747437
F12=0.0930778962588
score=0.11230783673
-------------------------------------------
No. of raw pred users:  950
No. of pred users bought cate 8:  950
pred item:  203
true users:  1259
pred users:  950
所有用户中预测购买用户的准确率为 0.163157894737
所有用户中预测购买用户的召回率0.12360446571
所有用户中预测购买商品的准确率为 0.116842105263
所有用户中预测购买商品的召回率0.0881652104845
F11=0.15489673551
F12=0.0977629029417
score=0.120616435969
-------------------------------------------
No. of raw pred users:  960
No. of pred users bought cate 8:  960
pred item:  219
true users:  1385
pred users:  960
所有用户中预测购买用户的准确率为 0.161458333333
所有用户中预测购买用户的召回率0.11231884058
所有用户中预测购买商品的准确率为 0.120833333333
所有用户中预测购买商品的召回率0.0837545126354
F11=0.150485436893
F12=0.0954732510288
score=0.117478125375
===========================================
avg user acc:  0.157328216374
avg user recall:  0.117497610562
avg item acc:  0.115365497076
avg item recall:  0.0856577992563
avg F11:  0.14884497328
avg F12:  0.0954380167431
avg score:  0.116800799358
</code></pre><h3 id="输出特征重要性"><a href="#输出特征重要性" class="headerlink" title="输出特征重要性"></a>输出特征重要性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_importance</span><span class="params">(bst_xgb)</span>:</span></div><div class="line">    importance = bst_xgb.get_fscore(fmap=<span class="string">r'xgb.fmap'</span>)</div><div class="line">    importance = sorted(importance.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    df = pd.DataFrame(importance, columns=[<span class="string">'feature'</span>, <span class="string">'fscore'</span>])</div><div class="line">    df[<span class="string">'fscore'</span>] = df[<span class="string">'fscore'</span>] / df[<span class="string">'fscore'</span>].sum()</div><div class="line">    file_name = <span class="string">'feature_importance_'</span> + str(datetime.now().date())[<span class="number">5</span>:] + <span class="string">'.csv'</span></div><div class="line">    df.to_csv(file_name)</div><div class="line"></div><div class="line">feature_importance(bst_xgb)</div></pre></td></tr></table></figure>
<h3 id="生成提交结果"><a href="#生成提交结果" class="headerlink" title="生成提交结果"></a>生成提交结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sub_file</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(pred_set, model)</span>:</span></div><div class="line">    actions = pd.read_csv(pred_set)                <span class="comment">#read test_set</span></div><div class="line">    </div><div class="line"><span class="comment">#     print 'total user before: ', len(actions['user_id'].unique())</span></div><div class="line"><span class="comment">#     potential = pd.read_csv('potential_user_04-28.csv')</span></div><div class="line"><span class="comment">#     lst_user = potential['user_id'].unique().tolist()</span></div><div class="line"><span class="comment">#     actions = actions[actions['user_id'].isin(lst_user)]</span></div><div class="line"><span class="comment">#     print 'total user after: ', len(actions['user_id'].unique())</span></div><div class="line">    <span class="comment"># 提前去掉部分特征</span></div><div class="line">    lst_useless = [<span class="string">'brand'</span>]</div><div class="line">    </div><div class="line">    actions.drop(lst_useless, inplace=<span class="keyword">True</span>, axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">    </div><div class="line">    users = actions[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>, <span class="string">'cate'</span>]].copy()</div><div class="line"><span class="comment">#     users = actions[['user_id', 'sku_id']].copy()</span></div><div class="line">    </div><div class="line">    actions[<span class="string">'user_id'</span>] = actions[<span class="string">'user_id'</span>].astype(np.int64)</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'user_id'</span>]</div><div class="line">    <span class="keyword">del</span> actions[<span class="string">'sku_id'</span>]</div><div class="line">    sub_user_index = users</div><div class="line">    sub_trainning_data = xgb.DMatrix(actions.values)</div><div class="line">    y = model.predict(sub_trainning_data, ntree_limit=model.best_ntree_limit)</div><div class="line">    sub_user_index[<span class="string">'label'</span>] = y</div><div class="line">    </div><div class="line"><span class="comment">#     sub_user_index = sub_user_index[sub_user_index['cate']==8]</span></div><div class="line"><span class="comment">#     del sub_user_index['cate']</span></div><div class="line">    rank = <span class="number">1200</span></div><div class="line">    pred = sub_user_index.sort_values(by=<span class="string">'label'</span>, ascending=<span class="keyword">False</span>)[:rank]</div><div class="line"><span class="comment">#     pred = sub_user_index[sub_user_index['label'] &gt;= 0.05]</span></div><div class="line"><span class="comment">#     pred = pred[['user_id', 'sku_id', 'label']]</span></div><div class="line"><span class="comment">#     pred = pred[pred['label']&gt;0.45]</span></div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of raw pred users: '</span>, len(pred[<span class="string">'user_id'</span>].unique())</div><div class="line">    pred = pred[pred[<span class="string">'cate'</span>]==<span class="number">8</span>]</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of pred users bought cate 8: '</span>, len(pred[<span class="string">'user_id'</span>].unique())</div><div class="line"></div><div class="line">    pred = pred[[<span class="string">'user_id'</span>, <span class="string">'sku_id'</span>]]</div><div class="line"><span class="comment">#     print </span></div><div class="line">    pred = pred.groupby(<span class="string">'user_id'</span>).first().reset_index()</div><div class="line">    pred[<span class="string">'user_id'</span>] = pred[<span class="string">'user_id'</span>].astype(int)</div><div class="line">    pred[<span class="string">'sku_id'</span>] = pred[<span class="string">'sku_id'</span>].astype(int)</div><div class="line">    sub_file = <span class="string">'submission_'</span> + str(rank) + <span class="string">'_'</span> + str(datetime.now().date())[<span class="number">5</span>:] + <span class="string">'.csv'</span></div><div class="line"><span class="comment">#     sub_file = 'submission_detail_' + str(datetime.now().date())[5:] + '.csv'</span></div><div class="line">    pred.to_csv(sub_file, index=<span class="keyword">False</span>, index_label=<span class="keyword">False</span>)  </div><div class="line"></div><div class="line">submit(<span class="string">'test_set.csv'</span>, bst_xgb)</div></pre></td></tr></table></figure>
<pre><code>No. of raw pred users:  1142
No. of pred users bought cate 8:  1142
</code></pre><h3 id="提交结果除重（可选）"><a href="#提交结果除重（可选）" class="headerlink" title="提交结果除重（可选）"></a>提交结果除重（可选）</h3><p>除去最后临近三天的发生购买行为的用户商品对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_improv</span><span class="params">(action, sub_file)</span>:</span></div><div class="line">    <span class="comment"># 获取4月最近三天的目标用户商品对</span></div><div class="line">    action_4 = pd.read_csv(action)</div><div class="line">    action_4[<span class="string">'time'</span>] = pd.to_datetime(action_4[<span class="string">'time'</span>]).apply(<span class="keyword">lambda</span> x: x.date())</div><div class="line">    aim_date = [datetime.strptime(s, <span class="string">'%Y-%m-%d'</span>).date() <span class="keyword">for</span> s <span class="keyword">in</span> [<span class="string">'2016-04-09'</span>, <span class="string">'2016-04-10'</span>, <span class="string">'2016-04-11'</span> ,</div><div class="line">                                                                  <span class="string">'2016-04-12'</span>, <span class="string">'2016-04-13'</span>, <span class="string">'2016-04-14'</span>, </div><div class="line">                                                                  <span class="string">'2016-04-15'</span>]]</div><div class="line">    aim_action = action_4[(action_4[<span class="string">'type'</span>]==<span class="number">4</span>) &amp; (action_4[<span class="string">'cate'</span>]==<span class="number">8</span>) &amp; (action_4[<span class="string">'time'</span>].isin(aim_date))]</div><div class="line">    aim_ui = aim_action[<span class="string">'user_id'</span>].map(int).map(str) + <span class="string">'-'</span> + aim_action[<span class="string">'sku_id'</span>].map(str)</div><div class="line">    <span class="comment"># 拼接提交数据的用户商品</span></div><div class="line">    sub = pd.read_csv(sub_file)</div><div class="line">    before = sub.shape[<span class="number">0</span>]</div><div class="line">    sub_ui = sub[<span class="string">'user_id'</span>].map(str) + <span class="string">'-'</span> + sub[<span class="string">'sku_id'</span>].map(str)</div><div class="line">    <span class="comment"># 交集</span></div><div class="line">    lst_aim = aim_ui.unique().tolist()</div><div class="line">    lst_sub = sub_ui.unique().tolist()</div><div class="line">    lst_common = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst_aim <span class="keyword">if</span> i <span class="keyword">in</span> lst_sub]</div><div class="line">    dct_ui = &#123;i.split(<span class="string">'-'</span>)[<span class="number">0</span>]: i.split(<span class="string">'-'</span>)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> lst_common&#125;</div><div class="line">    <span class="comment"># 从提交结果除掉交集部分</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> dct_ui:</div><div class="line">        sub.drop(sub[(sub[<span class="string">'user_id'</span>]==int(k)) &amp; (sub[<span class="string">'sku_id'</span>]==int(dct_ui[k]))].index, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of records after remove dup: '</span>, sub.shape[<span class="number">0</span>]</div><div class="line">    <span class="keyword">print</span> <span class="string">'No. of dup: '</span>, before - sub.shape[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (before - sub.shape[<span class="number">0</span>])!=<span class="number">0</span>:</div><div class="line">        file_name = <span class="string">'submission_'</span> + str(datetime.now().date())[<span class="number">5</span>:] + <span class="string">'_improv.csv'</span></div><div class="line">        sub.to_csv(file_name, index=<span class="keyword">False</span>, index_label=<span class="keyword">False</span>)</div><div class="line">    </div><div class="line">sub_improv(<span class="string">'data/JData_Action_201604.csv'</span>, <span class="string">'submission_1200_05-25.csv'</span>)</div></pre></td></tr></table></figure>
<pre><code>No. of records after remove dup:  1142
No. of dup:  0
</code></pre><h2 id="比赛过程中遇到和解决的问题"><a href="#比赛过程中遇到和解决的问题" class="headerlink" title="比赛过程中遇到和解决的问题"></a>比赛过程中遇到和解决的问题</h2><h3 id="线上线下测试的分相差悬殊问题"><a href="#线上线下测试的分相差悬殊问题" class="headerlink" title="线上线下测试的分相差悬殊问题"></a>线上线下测试的分相差悬殊问题</h3><p>传入report的真实预测用户商品对有问题，之前使用滑动窗口时仅用前三天预测后五天，对后五天发生了购买(类别8)行为的用户打上标签，生成训练集、验证集，这里隐式的划定了前三天有交互的用户群体，但是事实在后五天发生购买行为的用户应该理论上不小于这个数目(存在用户前三天并无交互但是在后五天发生购买行为的情况)，所以在计算report中的callback等值时传入的应该是这5天实际购买的用户行为记录，修改后，线上线下测试误差控制在0.01左右</p>
<h3 id="线下测试集组数"><a href="#线下测试集组数" class="headerlink" title="线下测试集组数"></a>线下测试集组数</h3><p>开始只设定了一组，导致有时候线下线上的变化不一致，后期设定了三组并结合三组的输出以及均值判断，基本能保证线上线下成绩同步</p>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>文件本身是gbk编码，其中的年龄属性就是中文的，导致转换时经常出现编码错误，后来修改了独热编码部分的代码，一开始对年龄这类含有中文的特征进行独热编码前，先将文本转化为数值（用数字表示类别）LabelEncoder + get_dummies()<a href="https://ask.hellobi.com/blog/DataMiner/4897" target="_blank" rel="external">来源</a></p>
<h3 id="feature-importance列未对应，导致一段时间分析的特征重要性文件存在问题，产生误导"><a href="#feature-importance列未对应，导致一段时间分析的特征重要性文件存在问题，产生误导" class="headerlink" title="feature_importance列未对应，导致一段时间分析的特征重要性文件存在问题，产生误导"></a>feature_importance列未对应，导致一段时间分析的特征重要性文件存在问题，产生误导</h3><h3 id="合并数据集时产生空值，由数据不一致造成"><a href="#合并数据集时产生空值，由数据不一致造成" class="headerlink" title="合并数据集时产生空值，由数据不一致造成"></a>合并数据集时产生空值，由数据不一致造成</h3><p>手动添加一些特征列并填充缺失值，此外注意拼接的键</p>
<h3 id="除零出现无限值"><a href="#除零出现无限值" class="headerlink" title="除零出现无限值"></a>除零出现无限值</h3><p>平滑部分除零特征</p>
<h3 id="优化时间计算效率"><a href="#优化时间计算效率" class="headerlink" title="优化时间计算效率"></a>优化时间计算效率</h3><p>开始时，构建时间差的地方用到了日期和字符串转换等操作，apply等比较费时，后面不使用apply而且一次性全部计算所有时间差并优先存储到数据中直接读入，提升了特征构建的速度</p>
<h2 id="失败的尝试以及未尝试的"><a href="#失败的尝试以及未尝试的" class="headerlink" title="失败的尝试以及未尝试的"></a>失败的尝试以及未尝试的</h2><ul>
<li>是否自定义衡量标准，而不使用roc-auc? <a href="https://github.com/dmlc/xgboost/blob/master/demo/guide-python/custom_objective.py" target="_blank" rel="external">参照</a></li>
<li>正负例比例不均的问题是否使用权重来矫正？<a href="https://github.com/dmlc/xgboost/blob/master/demo/guide-python/cross_validation.py" target="_blank" rel="external">参照</a><ul>
<li>参数：scale_pos_weight</li>
<li>DMatrix中的weight</li>
<li>尝试设置正负比例的参数，特别分阶段而且没有采样的条件下，不同阶段模型里的正负例是不一样的，尝试过，可能是提前随机欠抽样导致本身数据的随机性而再修改该属性反而没有效果；但是考虑到本身使用滑窗会产生大量数据，若不采样则机器内存不足以承受，而且后面尝试另一种滑窗的方法并不采样使用scale_pos_weight却也并无改善，可能需要参考《机器学习》使用EasyEnsemble的方法</li>
</ul>
</li>
<li>分阶段预测<br>第一阶段预测用户，第二阶段预测前一阶段预测出的用户可能购买的商品<br>设计特征如何分割和构建的问题以及标签的问题没有解决，导致失败</li>
<li>打标签方式的尝试<br>差别不大</li>
<li>时间窗的修改<br>最后是要预测五天内的购买，我们可以先随机取几个五天发生购买的用户，看看这些用户与所购买商品的交互时间周期覆盖率较大的一个值，然后反过来取另外的时间周期的交互用户商品对，看看这些里面有多少在时间周期后五天发生了购买行为，主要是交互周期的一个覆盖率问题<br>将对这三个月购买过的类别8商品后五天之前14天有过交互的所有用户商品对提取出来，而这里面根据前面所分析的，可以涵盖所有存在交互的用户商品对的80%的用户<br>但实际上虽然这14天能覆盖到80%的用户商品对，但是其实这部分用户商品对在不少交互其实只是在这14天的前面的某几天出现过，而后续并未进一步交互，虽然最后发生了购买行为，但是对于我们通过统计交互行为来构建特征的方法并没有什么帮助，反而扩大的时间窗囊括进了大量的噪声数据致使结果变糟</li>
<li>平滑特征</li>
<li>去重</li>
<li>填充空值</li>
<li>优化问题，如何加速训练</li>
<li>时间窗口构造上避开统计结果中的高峰、低谷时间区间<br>效果反而变差</li>
<li>其他模型以及模型融合<br>尝试过lightgbm,randomforest,gbdt，以及averaging但是效果不佳</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上大概是本次比赛的一个简要的流程，完整的代码可以到我的<a href="https://github.com/LancelotHolmes/JData" target="_blank" rel="external">github</a>查看，下面简要回顾下本次比赛的收获和有待进一步改进的地方</p>
<ul>
<li>团队合作很重要，特别是队员之间工作协调好，此外code review非常重要</li>
<li>对数据的分析是很关键的，只有通过统计分析才能说明你对数据的了解，你以为的常识是靠不住的</li>
<li>有想法在分析过后的基础上最好马上实践来验证，并做好相应的记录</li>
<li>做好分析记录很重要，无论是过程中的数据分析、特征尝试还是模型的参数调整；另外后面线下验证的过程也有必要做记录，毕竟线上测试机会有限，线下测试做的好、记录完备可以提高成绩</li>
<li>如开头所述，如何选取恰当的时间区间来预测用户商品对以及最近一段时间没有交互记录的用户商品对该如何挖掘出来是个难题</li>
<li>本次最终只提交了xgboost单模型的预测，后期也有尝试lightgbm、RandomForest、GBDT等模型，但是效果不是很好，而且时间仓促，模型集成这块也来不及做，尝试了bagging但是效果不是很好</li>
<li>数据本身存在正负比例不均的问题，查阅过一些资料，最后使用的是随机欠采样负例按与正例1：10的比例构建训练集，但是这种方法随机性较大，造成结果不稳定，对训练集敏感性较强，应该还有更好的方法</li>
<li>特征筛选问题，中间为了快速提高成绩，一味的添加特征，对于特征却没有进行适当的筛选，后期聚集了上百个特征却难以筛选，尝试过方差法、通过xgboost模型本身输出的特征重要性来筛选，但是效果不佳，这一块应该还有很多提升空间</li>
<li>关于分步预测的问题，也有尝试过按照群里大神提到的分阶段预测，即第一阶段仅预测未来可能会购买的用户，第二阶段预测这部分用户可能购买的商品，然而中间尝试很长一段时间效果不好，主要是不同阶段之间特征的取舍和冲突，最终效果不好而作罢，但是不失为一种思路</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> JData </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[概率统计小记]]></title>
      <url>/2017/06/22/Statistics/</url>
      <content type="html"><![CDATA[<ul>
<li>似然函数<br><a href="https://www.zhihu.com/question/54082000" target="_blank" rel="external">知乎上的一些理解</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0" target="_blank" rel="external">wiki</a></li>
<li>最大似然估计<br><a href="https://www.zhihu.com/question/20447622" target="_blank" rel="external">知乎</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1" target="_blank" rel="external">wiki</a></li>
<li>最大后验概率<br><a href="http://blog.csdn.net/upon_the_yun/article/details/8915283" target="_blank" rel="external">最大似然估计 vs 最大后验概率</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Note </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(五) —— 决策树]]></title>
      <url>/2017/06/19/Decision-Tree/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<ul>
<li>决策树是一种基本的分类与回归方法，其模型呈树形结构，在分类问题中表示基于特征对实例进行分类的过程，可以认为是<strong>if-then规则的集合</strong>，也可以认为是定义在特征空间与类空间上的<strong>条件概率分布</strong>；</li>
<li>其主要优点是模型具有可读性，分类速度快；</li>
<li>学习时，利用训练数据，根据<strong>损失函数最小化</strong>的原则建立决策树模型，预测时，对新的数据，利用决策树模型进行分类；</li>
<li>决策树学习的三个主要步骤<ul>
<li>特征选择</li>
<li>决策树的生成</li>
<li>决策树的剪枝</li>
</ul>
</li>
<li>常用决策树算法<ul>
<li>ID3</li>
<li>C4.5</li>
<li>CART<a id="more"></a>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Notes:关于损失函数最小化可以回顾<a href="/2017/06/02/Note-StatisticalML/" title="第一章节">第一章节</a>的模型选择部分的内容。</em></p>
<h2 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分类决策树模型是一种描述对实例进行分类的树形结构，其中包含两种类型的节点</p>
<ul>
<li>内部节点：表示一个特征（属性）</li>
<li>叶节点：表示一个类</li>
</ul>
<p><em>Notes:</em><br>一般决策树可以根据以下四个方面划分</p>
<ul>
<li>分支数</li>
<li>划分策略</li>
<li>终止策略</li>
<li>基分类器</li>
</ul>
<h3 id="if-then规则集合"><a href="#if-then规则集合" class="headerlink" title="if-then规则集合"></a>if-then规则集合</h3><ul>
<li>一条由根节点到叶节点的路径 –&gt; 一条规则</li>
<li>路径上内部节点的特征 –&gt; 规则的条件</li>
<li>叶节点的类 –&gt; 规则的结论</li>
<li>性质：互斥且完备</li>
</ul>
<h3 id="条件概率分布"><a href="#条件概率分布" class="headerlink" title="条件概率分布"></a>条件概率分布</h3><p>给定特征条件下类的条件概率分布</p>
<h2 id="决策树的学习"><a href="#决策树的学习" class="headerlink" title="决策树的学习"></a>决策树的学习</h2><blockquote>
<p>决策树学习本质上是从训练数据集中归纳出一组分类规则，另一个角度，学习是由训练数据集估计条件概率模型</p>
</blockquote>
<ul>
<li>目的：得到一个与训练数据矛盾较小的决策树，同时具有很好的泛化能力</li>
<li>策略：以损失函数（通常为正则化的极大似然函数）为目标函数的最小化，并在损失函数确定后，选择最优决策树</li>
<li>学习算法：<ul>
<li><del>理论上：从所有可能的决策树中选取最优决策树，NP完全问题</del></li>
<li>实际中：采用启发式方法，近似求解（得到次最优决策树）–&gt; 递归的选择最优特征，并根据该最优特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。</li>
<li>主要步骤：<ul>
<li>特征选择</li>
<li>决策树的生成</li>
<li>决策树的剪枝</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>Notes: 决策树的生成对应于模型的局部选择，决策树的剪枝对应于模型的全局选择。</em></p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><ul>
<li>实质：选取对于训练数据具有分类能力的特征（决定用哪个特征来划分特征空间）</li>
<li>常用准则<ul>
<li>信息增益  –&gt;  ID3</li>
<li>信息增益比  –&gt;  C4.5</li>
<li>基尼指数  –&gt;  CART</li>
</ul>
</li>
</ul>
<p><em>Notes:</em></p>
<ul>
<li>分类能力强即表示给定一个特征使得实例能较准确地被分类，及减少了实例的不确定性，掌握了更多的信息（信息增益角度的理解）</li>
<li>每次挑一个特征（列），根据该特征下各记录的不同取值来划分实例点（过程让我联想起k-nn中kd树的构建）–&gt; 所以一般要求特征值为离散值，或者事先对特征进行离散化处理</li>
</ul>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>$$g(D, A)=H(D)-H(D|A)$$</p>
<ul>
<li>$g(D, A)$即信息增益，表示得知特征$A$的信息而使得类$D$的信息的<strong>不确定性</strong>减少的程度</li>
<li>$H(D)$为集合$D$的经验熵<ul>
<li>其中假设$D$是一个取有限个值的离散随机变量，概率分布为$P(X=x_i)=p_i, i=1, 2,…,n$</li>
<li>熵是表示随机变量不确定性的度量，定义$H(D)=- \sum_{i=1}^n p_ilogp_i$，熵越大，随机变量的不确定性就越大，$0 \leq H(D) \leq logn$</li>
</ul>
</li>
<li>$H(D|A)$即经验条件熵表示在已知随机变量$A$（特征）的条件下随机变量$D$的不确定性$H(D|A)= \sum_{i=1}^{n}p_iH(D|A=a_i)$</li>
<li>一般将熵$H(D)$与条件熵$H(D|A)$之差称为<strong>互信息</strong>，决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</li>
</ul>
<p>小结</p>
<blockquote>
<ul>
<li>给定训练数据集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性，而经验条件熵$H(D|A)$表示在特征$A$给定的条件下对数据集进行分类的不确定性，因此两者之差即信息增益表示由于特征$A$而使得数据集$D$的分类的不确定性减少的程度。</li>
<li>对于数据集$D$而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益，信息增益大的特征具有更强的分类能力（也就是我们需要挑选的目标）</li>
</ul>
</blockquote>
<h4 id="算法——特征选择"><a href="#算法——特征选择" class="headerlink" title="算法——特征选择"></a>算法——特征选择</h4><blockquote>
<ul>
<li>输入：训练数据集$D$和特征$A$；</li>
<li>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$</li>
<li>(1) 计算数据集$D$的经验熵$H(D)$，<br>$$H(D)=- \sum_{k=1}^{K}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$$</li>
<li>(2) 计算特征$A$对数据集$D$的经验条件熵$H(D|A)$,<br>$$H(D|A)= \sum_{i=1}^{n} \frac{|D_i|}{|D|}H(D_i)=- \sum_{i=1}^{n} \frac{|D_i|}{|D|} \sum_{k=1}^{K} \frac{|D_{ik}|}{|D_i|}log_2 \frac{|D_{ik}|}{|D_i|}$$</li>
<li>(3) 计算信息增益$g(D, A)$,<br>$$g(D|A)=H(D)-H(D|A)$$<br>其中假设训练数据集$D$，$|D|$表示样本个数，设有$K$个类$C_k$, $|C_k|$表示属于类$C_k$的样本个数，根据特征$A$的$n$个不同的取值将训练数据集$D$划分为$n$个子集$D_1, D_2,…,D_n$，其中$|D_i|$表示子集$D_i$中的样本数，记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$</li>
</ul>
</blockquote>
<p><em>Notes:上述过程是一次特征挑选的过程，首先计算原始数据的经验熵，然后对每一个特征（轮流判断），首先根据该特征的所有不同取值将原始数据进行划分，得到的数据子集分别计算该子集的经验熵，然后按照该子集本身样本占比加权（按概率）加和起来作为经验条件熵，两相作差即为该特征对应的信息增益值，而在计算所有特征对应的信息增益之后，我们选出其中信息增益最大的特征作为分割的特征对数据集进行划分，而且后面涉及到决策树的生成过程就是一个递归的对子数据集挑选最佳特征然后划分数据集的过程。</em></p>
<p>如果觉得抽象可以参照原书P62的例子，或者参考《机器学习实战》中决策树章节的ID3算法的实现就能大概知道是什么情况了。</p>
<h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><blockquote>
<p>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题，使用信息增益比可以对这一问题进行校正。</p>
</blockquote>
<h4 id="信息增益比定义"><a href="#信息增益比定义" class="headerlink" title="信息增益比定义"></a>信息增益比定义</h4><p>特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比：<br>$$g_R(D,A)= \frac{g(D,A)}{H_A(D)}$$<br>其中<br>$$H_A(D)=- \sum_{i=1}^{n} \frac{|D_{i}|}{|D|}log_2 \frac{|D_{i}|}{|D|}$$<br>$n$为特征$A$的取值个数，$D_i$表示据特征$A$的取值将$D$分成的子集</p>
<h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul>
<li>在决策树的各个结点上应用<strong>信息增益</strong>准则选择特征，<strong>递归</strong>地构建决策树。</li>
<li>递归终止条件：所有特征的信息增益（设置信息增益的阈值来判断是否进一步划分）均很小或没有特征可以选择（每选择一个特征则后期划分子树不再使用前面使用过的特征，因为子树已经是在该特征下属于同一取值的实例集合）为止。</li>
<li>ID3相当于用<strong>极大似然法</strong>进行概率模型的选择。</li>
</ul>
<h4 id="算法-决策树生成"><a href="#算法-决策树生成" class="headerlink" title="算法-决策树生成"></a>算法-决策树生成</h4><blockquote>
<ul>
<li>输入：训练数据集$D$和特征集$A$，阈值$\varepsilon$；</li>
<li>输出：决策树$T$</li>
<li>(1) （叶子结点）若$D$中所有实例属于同一类$C_k$,则$T$为单节点树，并将类$C_k$作为该结点的类标记，返回$T$</li>
<li>(2) (终止条件之没有特征可供选择)若$A= \emptyset$,则$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记（多数表决规则），返回$T$</li>
<li>(3) 否则计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$</li>
<li>(4) (终止条件之阈值)若$A_g$的信息增益小于阈值$\varepsilon$，则置$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$</li>
<li>(5) 否则，对$A_g$的<strong>每一可能值$a_i$</strong>，依$A_g=a_i$将$D$划分为若干非空子集$D_i$，并将$D_i$中实例数最大的类作为标记构建子节点，返回$T_i$</li>
<li>(6) 对第$i$个子节点，以$D_i$为训练集，$A- \lbrace A_g \rbrace$为特征集，递归地调用(1)~(5)得到子树$T_i$并返回。</li>
</ul>
</blockquote>
<h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h3><p>C4.5算法与ID3算法类似，不同之处在于，C4.5在生成的过程中，用<strong>信息增益比</strong>来选择特征。</p>
<p><em>Notes:上述决策树的生成算法只有树的生成，而且是针对训练集构造的树，容易产生过拟合。</em></p>
<h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><blockquote>
<p>过拟合产生的原因在于学习时过多地考虑如何提高对<strong>训练数据</strong>的正确分类，从而构建出<strong>过于复杂的决策树</strong>，解决该问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。</p>
</blockquote>
<p><em>Notes:决策树模型的复杂度主要受到叶子节点数目和树的深度的影响</em></p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>在决策树学习中将已生成的树进行简化的过程</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>决策树的剪枝往往通过极小化决策树<strong>整体</strong>的损失函数或代价函数来实现</p>
<ul>
<li>决策树的损失函数<br>$$C_\alpha(T)= \sum_{t=1}^{|T|}|N_t|H_t(T)+ \alpha|T|$$<br>其中，树$T$的叶节点数为$|T|$，叶节点$t$有$|N_t|$个样本点，其中属于$k$类的数目为$|N_{tk}|$个</li>
<li>其中经验熵$H_t(T)$为<br>$$H_t(T)=- \sum_{k=1}^{K} \frac{|N_{tk}|}{|N_t|}log_2 \frac{|N_{tk}|}{|N_t|}$$</li>
<li>令$C(T)=\sum_{t=1}^{|T|}|N_t|H_t(T)$，则损失函数可表示为<br>$$C_\alpha(T)=C(T)+\alpha|T|$$<br>$C(T)$表示模型对训练数据的预测误差（个人理解为叶节点的经验熵与该叶节点的样本点数之积的加和，类似一种叶节点的总体的不确定性），即模型与训练数据的拟合程度，$|T|$表示模型的复杂度（叶节点数），参数$\alpha$控制两者之间的影响</li>
</ul>
<p><em>Notes:</em></p>
<ul>
<li>剪枝就是当$\alpha$确定时，选择损失函数最小的模型，及损失函数最小的子树。</li>
<li>利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。</li>
</ul>
<h4 id="算法-决策树剪枝"><a href="#算法-决策树剪枝" class="headerlink" title="算法-决策树剪枝"></a>算法-决策树剪枝</h4><blockquote>
<ul>
<li>输入：生成算法产生的整棵树$T$，参数$\alpha$</li>
<li>输出：修剪后的子树$T\alpha$</li>
<li>(1)计算每个结点的经验熵</li>
<li>(2)递归地从叶节点向上回缩:设叶节点回缩到其父节点之前与之后的整体树分别为$T_B$和$T_A$，如果其对应的损失函数有：<br>$$C_{\alpha}(T_A) \leq C_{\alpha}(T_B)$$<br>则进行剪枝，即将父节点变为新的叶结点(关于这里叶节点的类别标记应该仍是以多数表决的方法)。</li>
<li>(3)返回(2)直至不能继续，得到损失函数最小的子树$T\alpha$。</li>
</ul>
</blockquote>
<p><em>Notes:在向上回缩过程中判断损失函数值大小时，计算可以在局部进行，所以决策树的剪枝算法可以由一种<strong>动态规划</strong>的算法实现</em></p>
<h2 id="CART-classification-and-regression-tree-算法"><a href="#CART-classification-and-regression-tree-算法" class="headerlink" title="CART(classification and regression tree)算法"></a>CART(classification and regression tree)算法</h2><h3 id="与ID3-C4-5的区别"><a href="#与ID3-C4-5的区别" class="headerlink" title="与ID3,C4.5的区别"></a>与ID3,C4.5的区别</h3><ul>
<li>CART假设决策树是二叉树，而ID3,C4.5生成的过程中并无此假设，这也导致了两者的根本不同，ID3,C4.5每次选择出最佳特征之后，是按照该特征的每一个取值划分子树；而CART则是对每一个特征、每一个特征的每一个取值计算基尼指数（分类树）然后从所有特征、所有特征对应的取值计算所得的基尼指数中最小的特征及特征值作为切分点来划分子树，而划分依据则是判断实例对应特征的值是否等于该选定的特征值</li>
<li>子树划分（特征选择）的准则不同<ul>
<li>回归树，平方误差最小化准则</li>
<li>分类树，基尼指数最小化准则</li>
</ul>
</li>
</ul>
<h3 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h3><h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>设$X, Y$分别为输入和输出变量，其中$Y$为连续变量，给定训练数据集$D= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $</p>
<ul>
<li>一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值，所以我们的主要目的是要构建回归树，也就是<strong>如何划分输入空间</strong>，因为一旦划分好输入空间，如将输入空间划分为$M$个单元$R_1, R_2,…,R_M$,并且在每个单元$R_m$上有一个固定的输出值$c_m$，那么回归树的模型就可以表示为<br>$$f(x)=\sum_{m=1}^Mc_mI(x \in R_m)$$</li>
<li>如何划分输入空间？<br>仍然是采用启发式的方法（尝试），假设我们取$j$的某个值$s$来划分实例点，就可以根据各实例点对应该特征$j$的取值与选定的特征值$s$比较大小来划分，即<br>$$R_1(j, s)= \lbrace x|x^{(j)} \leq s \rbrace$$<br>$$R_2(j, s)= \lbrace x|x^{(j)} &gt; s \rbrace$$</li>
<li>如何选择最优切分点$s$和对应的切分变量$j$?<br>逐一计算和比较，比较的标准是平方误差最小化，即<br>$$min_{j,s} \left[ min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i-c_1)^2 + min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i-c_2)^2 \right]$$<br>,这里的$c_1, c_2$就是各个区域的输出，那么各个区域的输出又是怎么得到的呢？</li>
<li>如何得到各区域的输出？<br>仍然是依照平方误差最小准则，计算$\sum_{x_i \in R_m}(y_i-f(x_i))^2$，所以计算得到的单元$R_m$上的$c_m$的最优值刚好是$R_m$上所有输入实例$x_i$对应的输出$y_i$的均值，即<br>$$\hat{c_m}=ave(y_i|x_i \in R_m)$$</li>
<li>小结一下，通过计算各区域的实例对应的输出的均值可以得到当前尝试的划分点和划分变量划分的各区域的输出，从而可以计算和比较不同的切分点和切分变量下的误差，并进一步根据平方误差最小化准则从中选取出最优的切分点和切分变量，而确定了切分点和切分变量就相当于确定了区域的一个划分，接下来针对已划分的区域进一步根据需求进行划分或者停止划分就最终将输入空间划分为多个区域，而每个区域对应有一个确定的输出值，也就是构建好了一颗回归树</li>
</ul>
<h5 id="算法-CART回归树"><a href="#算法-CART回归树" class="headerlink" title="算法-CART回归树"></a>算法-CART回归树</h5><blockquote>
<ul>
<li>输入：训练数据集$D$</li>
<li>输出：回归树$f(x)$<br>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树</li>
<li>(1) 选择最优切分点$s$和切分变量$j$，求解<br>$$min_{j,s} \left[ min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i-c_1)^2 + min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i-c_2)^2 \right]$$<br>遍历变量$j$，对固定的切分变量$j$扫描切分点$s$，选择使上式达到最小的$s, j$</li>
<li>(2) 用选定的$s, j$划分区域并决定相应的输出值：<br>$$R_1(j, s)= \lbrace x|x^{(j)} \leq s \rbrace;  R_2(j, s)= \lbrace x|x^{(j)} &gt; s \rbrace$$<br>$$\hat{c_m}=ave(y_i|x_i \in R_m)$$</li>
<li>(3) 继续对两个子区域调用步骤(1),(2)直至满足停止条件</li>
<li>(4) 将输入空间划分为$M$个区域$R_1, R_2,…,R_M$，生成决策树<br>$$f(x)=\sum_{m=1}^Mc_mI(x \in R_m)$$</li>
</ul>
</blockquote>
<h4 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h4><p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点</p>
<h5 id="基尼指数-不纯度"><a href="#基尼指数-不纯度" class="headerlink" title="基尼指数(不纯度)"></a>基尼指数(不纯度)</h5><p><em>Notes:基尼指数是一种比较流行的选择，此外也可以用分类错误来计算(参考机器学习技法)</em></p>
<ul>
<li>定义<br>分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$,则概率分布的基尼指数定义为<br>$$Gini(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum_{k=1}^Kp_k^2$$<br>对于给定的样本集合$D$,其基尼指数为<br>$$Gini(D)=1-\sum_{k=1}^{K}\left(\frac{|C_k|}{|D|}\right)^2$$,<br>其中，$C_k$为$D$中属于第$k$类的样本子集，$K$是类的个数</li>
<li>特征$A$的条件下，集合$D$的基尼指数<br>$$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$<br>，其中样本集合$D$根据特征$A$<strong>是否取某一可能值</strong>$a$被分割成$D_1, D_2$两部分<br>$$D_1=\lbrace (x, y) \in D|A(x)=a \rbrace;    D_2=D-D_1$$</li>
<li>基尼指数$Gini(D)$表示集合$D$的不确定性，基尼指数$Gini(D,A)$表示经$A=a$分割后集合$D$的不确定性，基尼指数值越大，样本集合的不确定性也就越大。</li>
</ul>
<h5 id="算法-CART分类树"><a href="#算法-CART分类树" class="headerlink" title="算法-CART分类树"></a>算法-CART分类树</h5><blockquote>
<ul>
<li>输入：训练数据集$D$，停止计算的条件（如结点中样本个数小于预定阈值，或样本集的基尼指数小于预定阈值(样本基本属于同一类)，或者没有更多的特征）</li>
<li>输出：CART决策树<br>从根结点开始，递归地对每个结点进行以下操作：</li>
<li>(1) 设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数，对每一个特征$A$，对其可能的每一个取值$a$，根据样本点对$A=a$的测试为“是”或“否”将$D$分割成$D_1$和$D_2$两部分，计算$A=a$时的基尼指数。</li>
<li>(2) 在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</li>
<li>(3) 对两个节点递归地调用(1),(2)直至满足停止条件</li>
<li>(4) 生成CART决策树</li>
</ul>
</blockquote>
<h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根节点，形成一个子树序列$\lbrace T_0,T_1,…,T_n \rbrace$</li>
<li>然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树</li>
</ul>
<h4 id="剪枝过程理解"><a href="#剪枝过程理解" class="headerlink" title="剪枝过程理解"></a>剪枝过程理解</h4><ul>
<li>基本原理如上所述，就是由先前生成的CART决策树开始逆向剪枝得到一系列不同的子树集合，然后使用另一份验证集来对上述子树测试选出其中损失函数最小的子树</li>
<li>而由于我们根据损失函数最小来选取决策树，而由损失函数的定义<br>$$C_\alpha(T)= \sum_{t=1}^{|T|}|N_t|H_t(T)+ \alpha|T|$$<br>而我们主要是通过调整$\alpha$的值来权衡模型对训练集的预测能力和模型复杂度，因此对于固定的$\alpha$必然存在使损失函数$C_\alpha(T)$最小的子树，而极端情况下，前面根据CART生成算法得到的决策树$T_0$可认为是模型复杂度最大时的树，即此时可认为$\alpha=0$，而当$\alpha=+\infty$时对应的是以根结点为单节点树的简单模型</li>
<li>如此一来对于每一个$\alpha$的值，存在一个不同的子树模型，我们可以通过慢慢的从原始生成树中剪去叶节点并收集新得到的决策树，最后可以得到一个决策树的集合，而这个修剪和收集的过程，为了保证<strong>收集到完备的决策树序列</strong>，我们每次在原始生成树的基础上比较每个结点的剪枝前后的损失函数减少程度（即比较以该节点为根的节点的模型的损失与以该节点为单节点的模型的损失之差），并选取损失函数减少程度最小的一个子树部分，从原始生成树中剪去该子树得到新的子树保存到子树序列，并作为进一步剪枝的起始子树，直到最后得到以根节点为单节点模型。</li>
</ul>
<p><em>Notes:机器学习技法中的CART剪枝过程似乎有所不同，不是穷尽所有决策树，而是从完全决策树逆向剪枝，每次减去某个叶子然后得到这‘一层’间之后的决策树的模型中误差最小的，然后进行下一次剪枝，最后从这些决策树中根据泛化误差来选出最佳决策树。</em></p>
<h4 id="算法-CART剪枝"><a href="#算法-CART剪枝" class="headerlink" title="算法-CART剪枝"></a>算法-CART剪枝</h4><blockquote>
<ul>
<li>输入：CART算法生成的决策树$T_0$</li>
<li>输出：最优决策树$T_{\alpha}$</li>
<li>(1) 设$k=0, T=T_0$</li>
<li>(2) 设$\alpha = +\infty $</li>
<li>(3) 自下而上对各内部结点$t$计算$C(T_t), |T_t|$，以及<br>$$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$$<br>$$\alpha=min(\alpha,g(t))$$<br>其中$T_t$表示以$t$为根节点的子树，$C(T_t)$是对训练数据的预测误差，$|T_t|$是$T_t$的叶节点个数</li>
<li>(4) 对$g(t)=\alpha$的内部节点$t$进行剪枝，剪去$g(t)$最小的子树，并对叶节点$t$以多数表决法决定其类，得到树$T$</li>
<li>(5) 设$k=k+1, \alpha_k=\alpha, T_k=T$</li>
<li>(6) 若$T_k$不是由根结点及两个叶结点构成的树，就返回(3)，否则令$T_k=T_n$(即最后一次剪枝得到根结点为单节点模型)</li>
<li>(7) 采用交叉验证在剪枝得到的子树序列$T_0,T_1,…,T_n$中选取最优子树$T_{\alpha}$</li>
</ul>
</blockquote>
<h2 id="决策树算法对比"><a href="#决策树算法对比" class="headerlink" title="决策树算法对比"></a>决策树算法对比</h2><p>如果按照特征选择、决策树生成和决策树剪枝三个步骤来比较的话</p>
<ul>
<li>在特征选择上，三个决策树算法的选择标准都不一样：ID3(信息增益)、C4.5(信息增益比)、CART(分类：基尼指数，回归：最小二乘法)；此外就分类而言，ID3和C4.5分别是选择是信息增益、信息增益比最大的特征而CART则选择基尼指数最小的特征；</li>
<li>在决策树生成时：三者的终止条件大致类似（预设阈值、特征集合非空等），但是ID3和C4.5生成过程中是根据每一个特征值来生成一个对应子树，而CART则是根据特征值是否等于选定的特征值来进行二分（回归中则是根据大于小于某选定值划分区域）；也就是说前两者是树，而CART是二叉树（而这也大概决定了为什么原始的CART可以用来做回归，而前两者不行）</li>
<li>决策树剪枝方面：标准都是判断决策树整体的损失函数（预测误差+正则化项（模型复杂度））；不同的是，ID3,C4.5是局部的对比叶节点删除前后的损失来决定是否剪枝，而CART则是自下而上从最复杂的完整二叉树一直剪枝到最简单的单节点决策树得到一系列决策树，并最后在验证集上验证选择其中最佳的决策树（每次剪枝为了保证最后得到的决策树序列尽可能完备，每次选择前后损失函数减少最小的一种剪枝策略）</li>
</ul>
<h2 id="决策树生成算法ID3的实现"><a href="#决策树生成算法ID3的实现" class="headerlink" title="决策树生成算法ID3的实现"></a>决策树生成算法ID3的实现</h2><p>按照机器学习实战第三章节的内容实现了简单的ID3算法</p>
<ul>
<li>特征选择<ul>
<li>计算熵</li>
<li>计算条件熵</li>
<li>计算信息增益</li>
</ul>
</li>
<li>递归构建决策树并使用matplotlib实现决策树的可视化</li>
<li>使用pickle序列化保存生成的决策树模型</li>
<li>实例：使用决策树模型预测隐形眼镜的类型<br>具体实验代码见<a href="https://github.com/LancelotHolmes/MLinAction/blob/master/Decision_Tree.ipynb" target="_blank" rel="external">github</a></li>
</ul>
<h2 id="决策树模型的优缺点"><a href="#决策树模型的优缺点" class="headerlink" title="决策树模型的优缺点"></a>决策树模型的优缺点</h2><p><em>参考机器学习技法</em></p>
<ul>
<li>优点<ul>
<li>可解释性–模拟人类决策过程</li>
<li>训练、预测效率较高–关于其切分方式，每次是在一个条件下的局部空间划分样本，而类似Adaboost则是每次在整个空间划分样本，所以就决策树而言相对高效</li>
<li>适用于类别类型数据–decision set(穷举类别特征值然后按照特征值的子集集合来划分样本)</li>
<li>能够很方便的由二分类模型转换为多分类模型–主要修改不纯度计算以及返回值的设置</li>
<li>能够处理缺失特征值–用其他的特征值来替代进行划分(一般要求替代特征划分结果接近缺失特征值)</li>
<li>易于实现</li>
</ul>
</li>
<li>缺点<ul>
<li>经验多于理论，大多数决策树模型是根据经验来判断的，效果好坏尚无较好的理论支撑</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《统计学习方法》</li>
<li>《机器学习实战》</li>
<li>机器学习技法</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> decision tree </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(四) —— 朴素贝叶斯法]]></title>
      <url>/2017/06/09/naive-bayes/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>朴素贝叶斯法是基于<strong>贝叶斯定理</strong>和<strong>特征条件独立假设</strong>的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的<em>联合概率分布</em>，然后基于此模型，对给定的输入$x$，利用<em>贝叶斯定理</em>求出后验概率最大的输出$y$。</p>
</blockquote>
<p><em>关键词：贝叶斯定理、特征条件独立假设、实现简单、学习预测效率高、生成学习方法</em><br><a id="more"></a></p>
<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ul>
<li>贝叶斯定理</li>
<li>特征条件独立假设</li>
</ul>
<h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>若$X$是定义在输入空间$R^n$上的随机向量，$Y$是定义在输出空间$\lbrace c_1, c_2,…, c_K \rbrace$上的随机变量，$P(X, Y)$是$X$和$Y$的<strong>联合概率分布</strong>，训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $由$P(X, Y)$独立同分布产生。</p>
<ul>
<li>后验概率<br>现对于实例$x$需要判断其所属分类，即我们需要知道x属于哪个分类的概率最大，用公式表示就是求取<br>$$argmax_{c_k} P(Y=c_k | X=x)$$<br>即后验概率，其中$k=1, 2,…, K$表示所有可能分类，而对于求解$P(Y=c_k | X=x)$，根据贝叶斯定理，我们需要知道训练数据的：</li>
<li>先验概率分布<br>$$P(Y=c_k),  k = 1,2,…,K$$</li>
<li>条件概率分布，即每种分类下各个实例特征取不同值的概率<!-- $$P(X=x|Y=c_k) = P(X^1=x^1,...,X^n=x^n|Y=c_k)$$ -->
$$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k)$$<br>然后根据贝叶斯定理进行计算求得后验概率</li>
<li>贝叶斯定理<br>$$P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X|Y)P(Y)}{\sum P(Y)P(X|Y)}$$<br>即<br>$$P(Y=c_k|X=x)=\frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_k P(Y=c_k)P(X=x|Y=c_k)}$$<br>但是如果直接这么求解，由于条件概率分布涉及到大量的参数，所以其估计在实际中是不可行的，所以我们在这里进行了一个大胆的假设</li>
</ul>
<h3 id="条件独立性假设"><a href="#条件独立性假设" class="headerlink" title="条件独立性假设"></a>条件独立性假设</h3><p>假设用于分类的特征在类确定的条件下都是条件独立的，所以对于条件分布，我们有<br>$$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)} | Y=c_k)=\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$<br>这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率</p>
<p>如此一来我们就可以得到最终的朴素贝叶斯分类器<br>$$y=argmax_{c_k}P(Y=c_k) \prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$</p>
<h3 id="后验概率最大化"><a href="#后验概率最大化" class="headerlink" title="后验概率最大化"></a>后验概率最大化</h3><p>后验概率最大化等价于期望风险最小化，证明如下<br><img src="/materials/img/Naive_Bayes/post_prob.jpg" alt="post_prob"></p>
<h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>学习意味着估计先验概率和条件概率</p>
<ul>
<li>先验概率的极大似然估计<br>$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)}{N}$$</li>
<li>条件概率的极大似然估计<br>$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl}, y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)}$$<br>其中假设第$j$个特征$x^{(j)}$可能取值的集合为$\lbrace a_{j1}, a_{j2},…,a_{jS_j}$，$j=1, 2,…,n;  l=1, 2,…,S_j;  k=1,2,…,K;   x_i^{(j)}$是第$i$个样本的第$j$个特征；$a_{jl}$为第$j$个特征可能取的第$l$个值，$I$为指示函数</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<ul>
<li>输入：训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $，其中$x_i=(x_i^{(1)}, x_i^{(2)},…,x_i^{(n)})^T,  x_i^{(j)}$是第$i$个样本的第$j$个特征，$x_i^{(j)} \in \lbrace a_{j1}, a_{j2},…,a_{jS_j}$，$a_{jl}$为第$j$个特征可能取的第$l$个值，$j=1, 2,…,n;  l=1, 2,…,S_j;  y_i \in \lbrace c_1, c_2,…, c_K \rbrace $; 实例$x$；</li>
<li>输出：实例$x$的分类</li>
<li>(1) 计算先验概率<br>$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)}{N},  k = 1,2,…,K$$<br>计算条件概率<br>$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl}, y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)}$$</li>
<li>(2) 对于给定的实例$x=(x^{(1)}, x^{(2)},…,x^{(n)})^T$，计算<br>$$P(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$</li>
<li>(3) 确定实例$x$的类<br>$$y=argmax_{c_k}P(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$</li>
</ul>
</blockquote>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>由于用极大似然估计可能会出现索要估计的概率值为0的情况(条件概率的某种取值的统计量为0)，会影响到后验概率的计算结果，使分类产生偏差，我们可以采取的做法是在随机变量各个取值的<strong>频数</strong>上赋予一个正数$\lambda$，即贝叶斯估计，此时</p>
<ul>
<li>条件概率的贝叶斯估计为<br>$$P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl}, y_i=c_k)+ \lambda}{\sum_{i=1}^{N}I(y_i=c_k)+S_j \lambda}$$</li>
<li>先验概率的贝叶斯估计<br>$$P_{\lambda}(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)+\lambda}{N+K\lambda}$$<br>常取$\lambda=1$称为拉普拉斯平滑</li>
</ul>
<p><em>Note:朴素贝叶斯法中假设输入变量都是条件独立的，如果假设他们之间存在概率依存关系，模型就变成了<strong>贝叶斯网络</strong>。</em></p>
<h3 id="实现——机器学习实战"><a href="#实现——机器学习实战" class="headerlink" title="实现——机器学习实战"></a>实现——机器学习实战</h3><p>按照机器学习实战第四章节的内容实现了基础的朴素贝叶斯分类器<br>不同于k-nn和感知机将实力硬性的划分到某一类别，朴素贝叶斯分类器是返回某一实例属于某类别的概率，此外，朴素贝叶斯分类器是一种生成模型，在数据较为缺少的情况下依然有效。</p>
<ul>
<li>本实验主要是针对文档的分类<ul>
<li>根据文档中的词构建词集、词袋子</li>
<li>涉及文档的词向量的解析、提取</li>
<li>将文档中每一个词作为特征，计算先验概率、条件概率</li>
<li>实际应用中使用对数处理了下溢出等问题</li>
</ul>
</li>
<li>实例<ul>
<li>使用朴素贝叶斯分类器过滤侮辱性留言</li>
<li>使用朴素贝叶斯分类器过滤垃圾邮件</li>
<li>使用朴素贝叶斯分类器从个人广告中获取地域倾向<br>具体实验代码见<a href="https://github.com/LancelotHolmes/MLinAction/blob/master/Naive_Bayes.ipynb" target="_blank" rel="external">github</a></li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> k-NN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer阅读笔记]]></title>
      <url>/2017/06/09/offer/</url>
      <content type="html"><![CDATA[<p><em>本文主要是个人针对《剑指offer》一书的一些笔记，并不涉及具体的题目或者方法，只是作为一个整体的知识点框架梳理，便于查缺补漏。</em></p>
<h2 id="辅助网站"><a href="#辅助网站" class="headerlink" title="辅助网站"></a>辅助网站</h2><ul>
<li><a href="https://github.com/zhedahht/CodingInterviewChinese2" target="_blank" rel="external">剑指offer第二版作者源代码（C++实现）</a></li>
<li><a href="http://blog.csdn.net/derrantcm/article/details/46887821" target="_blank" rel="external">第一版面试题Java实现</a></li>
<li><a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">牛客网上配套练习</a><a id="more"></a>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="面试形式-amp-流程"><a href="#面试形式-amp-流程" class="headerlink" title="面试形式&amp;流程"></a>面试形式&amp;流程</h3></li>
<li>电面 ——&gt; 远程 ——&gt; 现场</li>
<li>尽可能用形象化的语言把细节描述清楚</li>
<li>不确定问题时，主动提问</li>
</ul>
<h3 id="编程习惯-amp-调试能力"><a href="#编程习惯-amp-调试能力" class="headerlink" title="编程习惯&amp;调试能力"></a>编程习惯&amp;调试能力</h3><ul>
<li>编程前理清思路</li>
<li>命名、缩进习惯</li>
<li>测试在前、开发在后(编程前尽可能考虑多个测试用例)</li>
</ul>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><ul>
<li>STAR模型 —— 简短项目背景，突出自己所做的工作和成绩</li>
</ul>
<h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><h4 id="5种素质"><a href="#5种素质" class="headerlink" title="5种素质"></a>5种素质</h4><ul>
<li>扎实的基础知识</li>
<li>高质量代码</li>
<li>分析问题时思路清晰</li>
<li>能优化时间、空间效率</li>
<li>学习、沟通能力</li>
</ul>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>编程语言——熟悉程度</li>
<li>数据结构：<strong>链表、树</strong>、栈、队列、哈希表</li>
<li>算法：<ul>
<li>查找、排序：<strong>二分查找、归并排序、快排</strong></li>
<li>动态规划、贪心</li>
</ul>
</li>
</ul>
<h4 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h4><ul>
<li>鲁棒性——<strong>检查空指针</strong></li>
<li>特殊输入</li>
<li>边界条件</li>
<li>异常处理</li>
</ul>
<p><em>Note:</em></p>
<ul>
<li>考虑本身结构的取值范围</li>
<li>输入变量的可能取值</li>
<li>开发之前多想一些测试用例</li>
</ul>
<h4 id="分析-amp-思路——针对复杂问题"><a href="#分析-amp-思路——针对复杂问题" class="headerlink" title="分析&amp;思路——针对复杂问题"></a>分析&amp;思路——针对复杂问题</h4><ul>
<li>画图使抽象问题形象化</li>
<li>举例使抽象问题具体化</li>
<li>分解使复杂问题简单化</li>
</ul>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><ul>
<li>首先要知道如何分析效率</li>
<li>数值各种数据结构的优缺点、并能选择合适的数据结构解决问题</li>
<li>熟练掌握常用的算法</li>
</ul>
<h4 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h4><ul>
<li>沟通能力——思路、逻辑、合作</li>
<li>学习能力：读书、新概念</li>
<li>知识迁移能力</li>
<li>抽象建模能力</li>
<li>发散思维能力</li>
</ul>
<h4 id="关于提问（技术面）"><a href="#关于提问（技术面）" class="headerlink" title="关于提问（技术面）"></a>关于提问（技术面）</h4><ul>
<li>忌<ul>
<li>不要问与自己职位无关的问题</li>
<li>不要问薪水（HR面再详谈）</li>
<li>不要打听面试结果</li>
</ul>
</li>
<li>荐<ul>
<li>问与应聘职位或项目相关的问题</li>
<li>事先搜集应聘职位、项目背景相关信息</li>
<li>面试中留心面试官说过的话</li>
</ul>
</li>
</ul>
<h2 id="第二章-——-基础知识"><a href="#第二章-——-基础知识" class="headerlink" title="第二章 —— 基础知识"></a>第二章 —— 基础知识</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>语言面试的3种类型</p>
<ul>
<li>概念的理解：eg:关键字（特点及使用场合）</li>
<li>分析代码运行结果</li>
<li>写代码</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>数组&amp;字符串 —— 基本</li>
<li><strong>链表&amp;树 —— 常考</strong>，代码鲁棒性</li>
<li>栈 —— 递归</li>
<li>队列 —— 广度优先搜索</li>
</ul>
<h3 id="算法与数据操作"><a href="#算法与数据操作" class="headerlink" title="算法与数据操作"></a>算法与数据操作</h3><ul>
<li>实现方式：循环或递归</li>
<li><strong>排序&amp;查找：重点（重中之重：二分查找、归并排序、快速排序）</strong></li>
<li>回溯法 —— 递归、栈、二维数组（矩阵）、迷宫问题</li>
<li>动态规划<ul>
<li>分析：自上而下 ——&gt; 递归</li>
<li>实现：自下而上 ——&gt; 循环</li>
<li>涉及动态规划求解问题的四个特点<ul>
<li>问题目标是求其<strong>最优解</strong></li>
<li>整体问题的最优解<strong>依赖</strong>于各个<strong>子问题</strong>的最优解</li>
<li>将大问题分解为若干小问题之后，小问题之间还存在相互重叠的更小的<strong>公共子问题</strong></li>
<li>自上而下分析问题，自下而上求解问题</li>
</ul>
</li>
</ul>
</li>
<li>贪婪<ul>
<li>分解子问题时存在特殊选择</li>
<li>证明是最优解——需要较强的数学功底</li>
</ul>
</li>
<li>位运算：与、或、异或、左移、右移<ul>
<li>重要结论：将一个整数减去1后再与原来的整数做位与运算，得到的结果相当于把原整数的二进制表示中的最右边的1变成0</li>
<li>常考点：涉及统计二进制表示中1的个数</li>
</ul>
</li>
</ul>
<h2 id="第三章——高质量的代码"><a href="#第三章——高质量的代码" class="headerlink" title="第三章——高质量的代码"></a>第三章——高质量的代码</h2><h3 id="代码的规范性"><a href="#代码的规范性" class="headerlink" title="代码的规范性"></a>代码的规范性</h3><ul>
<li>书写——白板编程</li>
<li>布局——缩进</li>
<li>命名——表明用途、意图</li>
</ul>
<h3 id="代码的完整性"><a href="#代码的完整性" class="headerlink" title="代码的完整性"></a>代码的完整性</h3><ul>
<li>功能测试</li>
<li>边界测试</li>
<li>负面测试</li>
</ul>
<p>###代码的鲁棒性</p>
<ul>
<li>容错性</li>
<li>防御性编程<ul>
<li>在函数入口添加代码以验证用户输入是否符合要求</li>
<li>突破思维局限，多问几个“如果不…那么…”</li>
</ul>
</li>
<li>处理无效的输入</li>
</ul>
<p><em>小技巧：链表——双指针，当用一个指针遍历链表不能解决问题时，尝试用两个指针遍历链表，一种思路让两个指针速率不等；另一种思路让一个指针先遍历一段距离。</em></p>
<h2 id="第四章——解决面试题的思路"><a href="#第四章——解决面试题的思路" class="headerlink" title="第四章——解决面试题的思路"></a>第四章——解决面试题的思路</h2><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>分治法/动态规划等</p>
<h2 id="第五章——优化时间和空间效率"><a href="#第五章——优化时间和空间效率" class="headerlink" title="第五章——优化时间和空间效率"></a>第五章——优化时间和空间效率</h2><h3 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h3><ul>
<li>编程习惯、细节</li>
<li>循环vs.递归</li>
<li>数据结构&amp;算法功底<ul>
<li>知识点：快速排序(partition)、红黑树、最大堆、最小堆</li>
</ul>
</li>
<li>思维能力&amp;激情</li>
</ul>
<h3 id="时间效率与空间效率的平衡"><a href="#时间效率与空间效率的平衡" class="headerlink" title="时间效率与空间效率的平衡"></a>时间效率与空间效率的平衡</h3><ul>
<li>以空间换时间</li>
<li>权衡：可以与面试官探讨<ul>
<li>对于Java需要回顾集合相关的知识点</li>
</ul>
</li>
</ul>
<h3 id="小结——如何降低时间复杂度"><a href="#小结——如何降低时间复杂度" class="headerlink" title="小结——如何降低时间复杂度"></a>小结——如何降低时间复杂度</h3><ul>
<li>改用更高效的算法</li>
<li>空间换时间<ul>
<li>用数组实现简单的哈希表</li>
<li>创建缓存保存中间的计算结果</li>
<li>递归–&gt; 保存求解子问题的结果避免重复计算</li>
<li>例外：针对嵌入式开发，空间换时间不一定可行</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Coding </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(三) —— K近邻]]></title>
      <url>/2017/06/06/knn/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h2 id="k近邻算法"><a href="#k近邻算法" class="headerlink" title="k近邻算法"></a>k近邻算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类<br><a id="more"></a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>输入：训练数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $，其中$x_i \in R^n$为实例的<strong>特征向量</strong>,$y_i \in \lbrace c_1, c_2,…, c_K \rbrace$ 为实例的<strong>类别</strong>,$i=1, 2, 3…, N$；<ul>
<li>输出：实例$x$所属的类$y$</li>
<li>根据所给的<strong>距离度量</strong>，在训练集中找到与$x$最近的k个点，涵盖这k个点的$x$的邻域记作$N_k(x)$；</li>
<li>$N_k(x)$中根据<strong>分类决策规则</strong>（常用多数表决）决定$x$的类别$y$</li>
</ul>
</li>
</ul>
<p>$$y = argmax_{c_j} \sum_{x_i \in N_k(x)} I(y_i = c_j), i=1, 2,…, N; j=1, 2,…, K$$</p>
<p> 其中$I$为指示函数，当$y_i = c_j$时$I$为1，否则为0</p>
</blockquote>
<p><em>Note:</em></p>
<ul>
<li>k近邻法实际上利用训练数据集<strong>对特征向量空间进行划分</strong>，并作为其分类的“模型”</li>
<li>k=1时称为最近邻算法</li>
<li>k近邻法没有显式的学习过程</li>
</ul>
<h2 id="k近邻模型——对特征空间的划分"><a href="#k近邻模型——对特征空间的划分" class="headerlink" title="k近邻模型——对特征空间的划分"></a>k近邻模型——对特征空间的划分</h2><blockquote>
<p>k近邻法中，当训练集、<strong>距离度量、k值以及分类决策规则</strong>确定后，对于任何一个新的输入实例，它所属的类唯一地确定，这相当于根据上述要素将特征空间划分为一些子空间，确定子空间里的每个点所属的类。</p>
</blockquote>
<h2 id="k近邻法的三个基本要素"><a href="#k近邻法的三个基本要素" class="headerlink" title="k近邻法的三个基本要素"></a>k近邻法的三个基本要素</h2><h3 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h3><table>
<thead>
<tr>
<th>k值</th>
<th>学习的近似误差</th>
<th>估计误差</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>较小</td>
<td>下降</td>
<td>上升</td>
<td>整体模型变得复杂，对紧邻的实例点变得非常敏感，容易发生过拟合</td>
</tr>
<tr>
<td>较大</td>
<td>上升</td>
<td>下降</td>
<td>模型变得简单，但与输入实例较远的点也会对输入实例点产生影响</td>
</tr>
</tbody>
</table>
<p><em>Note: 实际应用中，k值一般取一个比较小的数值，通常采用交叉验证法来选取最优的k值。</em></p>
<p>另外关于近似误差和估计误差，网上没有找到让我满意的答案，目前的一点理解如下：</p>
<blockquote>
<p>k值越小，学习的近似误差(approximation error)越小，估计误差(estimation error)越大，反之则相反</p>
</blockquote>
<p>个人感觉这里有点像偏差和方差的区别，是否可以理解为近似误差即偏差，在k值较小时，选择的邻域范围较小，所以在空间内切割的“比较细”，但与此同时导致模型更加复杂，对于近邻的实例点非常敏感，而估计误差理解为方差，也就是说划分的邻域范围较大，所以平均下来根据分类决策规则可以减小邻域内的噪音点的影响，但是范围大的同时也会产生较远的点对于实例点也产生影响</p>
<p>搜索到的一些结果比如<a href="http://blog.csdn.net/linian8123654/article/details/53301207" target="_blank" rel="external">linian2763的博客</a></p>
<blockquote>
<p>估计误差（estimation error）:度量预测结果与最优结果的相近程度<br>近似误差（approximation error）:度量与最优误差之间的相近程度</p>
</blockquote>
<p>此外还有<a href="https://stats.stackexchange.com/a/149922/152084" target="_blank" rel="external">stackexchange</a>上的讨论，但是看得更加迷糊。</p>
<h3 id="距离度量——实例点相似程度的反应"><a href="#距离度量——实例点相似程度的反应" class="headerlink" title="距离度量——实例点相似程度的反应"></a>距离度量——实例点相似程度的反应</h3><p>常用距离度量</p>
<ul>
<li>欧氏距离</li>
<li>$L_p$距离</li>
<li>Minkowski距离</li>
</ul>
<p>其中对于$L_p$距离，设特征空间为n维实数向量空间$R^n$，$x_i, x_j \in R^n$，$x_i = (x_i^{(1)}, x_i^{(2)},…, x_i^{(n)})^T, x_j = (x_j^{(1)}, x_j^{(2)},…, x_j^{(n)})^T$，则$x_i, x_j$的$L_p$距离定义为</p>
<p>$$L_p(x_i,x_j)=(\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|^p)^{\frac{1}{p}}$$</p>
<p>其中$p \geq 1$，且当$p=2$时转化为欧氏距离，$p=1$时转化为曼哈顿距离</p>
<p><em>Note: 不同的距离度量所确定的最近邻点是不同的</em></p>
<h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>常用多数表决，即由输入实例的k个邻近的训练实例中的多数类决定输入实例的类，<strong>多数表决规则等价于经验风险最小化</strong></p>
<h2 id="实现方法——kd树-k维树"><a href="#实现方法——kd树-k维树" class="headerlink" title="实现方法——kd树(k维树)"></a>实现方法——kd树(k维树)</h2><ul>
<li>特征空间维数大</li>
<li>训练数据容量大<br>如何对训练数据进行快速k近邻搜索</li>
<li><del>线性扫描：耗时，不可行</del></li>
<li>使用特殊的结构存储训练数据，以减少计算距离的次数——kd树</li>
</ul>
<h3 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a>构造kd树</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构</p>
</blockquote>
<p><em>Note:</em></p>
<ul>
<li>kd树是二叉树</li>
<li>kd树的每个结点对应于一个k维超矩形区域，而各实例点存在于不同的超矩形区域内，即在kd树的不同结点里</li>
<li>一般这个k维就是数据实例点的维度，即特征数，每次选定一个特征，然后根据范围内的实例点（记录）的该特征的值来进行二分，过程有点像快排里的分割</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><blockquote>
<ul>
<li>输入：k维空间数据集$T= \lbrace x_1, x_2,…, x_N \rbrace $，其中$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(k)})^T, i=1,2,…,N$；</li>
<li>输出：kd树</li>
<li>（1）开始：构造根结点，根结点对应于包含T的k维空间的超矩形区域。 选择$x^{(1)}$为坐标轴，以T中所有实例的$x^{(1)}$坐标的<strong>中位数</strong>为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。由根结点生成深度为1的左、右结点，左子结点区域的$x^{(1)}$坐标对应的值小于切分点的子区域；右子结点区域的$x^{(1)}$坐标对应的值大于切分点的子区域。将落在切分超平面上的实例点保存在根结点。</li>
<li>（2）重复：对于深度为j的结点，选择$x^{(1)}$为切分的坐标轴，$l=(j \mod k) + 1$，以该结点区域中所有实例的$x^{(1)}$坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。由该结点生成深度为j+1的左、右结点，左子结点区域的$x^{(1)}$坐标对应的值小于切分点的子区域；右子结点区域的$x^{(1)}$坐标对应的值大于切分点的子区域。将落在切分超平面上的实例点保存在该结点。</li>
<li>（3）直到两个区域没有实例存在时停止。</li>
</ul>
</blockquote>
<p><em>Note:</em></p>
<ul>
<li>书中的方法是轮流按每个维度对某结点进行切分，各个维度（特征）可能会被重复利用来进行切分，当然此时的实例点范围不同，切分点也不同（中位数发生变化）</li>
</ul>
<p>对于kd构造的实例，其一书中的例子比较直观，如下<br><img src="/materials/img/kNN/kd_tree.png" alt="kd_tree"><br>此外，在<a href="https://zh.wikipedia.org/wiki/K-d%E6%A0%91" target="_blank" rel="external">wiki</a>里的一幅三维空间的配图也是非常直观<br><img src="/materials/img/kNN/kd_tree2.png" alt="kd_tree2"></p>
<blockquote>
<p>一个三维k-d树。第一次划分（红色）把根节点（白色）划分成两个节点，然后它们分别再次被划分（绿色）为两个子节点。最后这四个子节点的每一个都被划分（蓝色）为两个子节点。因为没有更进一步的划分，最后得到的八个节点称为叶子节点。</p>
</blockquote>
<h3 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a>搜索kd树</h3><blockquote>
<p>利用kd树可以省去对大部分的数据点的搜索，从而减少搜索的计算量</p>
</blockquote>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><blockquote>
<ul>
<li>输入：已构造的kd树；目标点x；</li>
<li>输出：x的最近邻</li>
<li>（1）在kd树中找到包含目标点x的叶结点：思想有点像<strong>二分查找</strong>，从根节点出发，递归地向下访问kd树，若目标点x当前维的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点，直到子节点为叶节点为止</li>
<li>（2）以此叶节点为“当前最近点”</li>
<li>（3）递归地向上回退，在每个节点执行以下操作：<ul>
<li>（a）如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”</li>
<li>（b）当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。即以目标点为球心，以目标点与当前最近点间的距离为半径的球体是否与另一子结点对应的区域相交。如果相交，可能在另一个子结点对应的区域中存在更近的点。移动到另一个子结点，接着递归地进行最邻近搜索。如果不相交，则向上回退。</li>
</ul>
</li>
<li>（4）当回退到根结点，搜索结束，此时的当前最近结点即为x的最邻近点。</li>
</ul>
</blockquote>
<p><em>Note:</em></p>
<ul>
<li>若实例点随机分布，kd树搜索的平均计算复杂度是<em>O(log N)</em>，<em>N</em>为训练实例数</li>
<li>kd树更适用于训练实例数远大于空间维数时的k近邻搜索</li>
</ul>
<p>关于这个算法的理解最好还是看书上的例子3.3，基本思路是一个重复二分查找和回溯的过程，另外关于kd树的搜索，有一篇很不错的文章，详见<a href="https://zhuanlan.zhihu.com/p/23966698" target="_blank" rel="external">kd树的细致图文讲解</a></p>
<h2 id="实现——机器学习实战"><a href="#实现——机器学习实战" class="headerlink" title="实现——机器学习实战"></a>实现——机器学习实战</h2><p>按照机器学习实战关于k-NN的章节实现了原始的k-NN分类器，并做了几个小实例：</p>
<ul>
<li>首先是一个基础的原理理解，对于二维空间的点按照坐标之间的距离进行分类，意图是理解k-NN的基本原理，即基于实例的学习算法，按照距离分类</li>
<li>在实现了原始分类器的基础上构建小应用，使用约会网站的异性数据，针对三项特征来判断新输入的异性是否有魅力</li>
<li>同样基于原始分类器，针对二进制点阵构成的数字图像文本文件进行识别和分类</li>
<li>上述三个例子都是使用的同一个原始分类器，不同之处仅仅是输入的数据有所改变，此外为了使输入数据能够被原始分类器处理，针对不同数据的特征进行了不同的处理：<ul>
<li>针对约会网站数据由于各项特征的取值范围不同可能对于距离计算产生影响所以进行了归一化操作</li>
<li>对于图像文本文件将其由32*32的二进制点阵转换为1*1024的向量便于分类器处理</li>
<li>此外还有一些基础的文件格式化为矩阵以及可视化操作</li>
</ul>
</li>
</ul>
<p>原始的Jupyter Notebook可以参考我的<a href="https://github.com/LancelotHolmes/MLinAction/blob/master/k-NN.ipynb" target="_blank" rel="external">github</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> k-NN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(二) —— 感知机]]></title>
      <url>/2017/06/03/Perceptron/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>感知机（perceptron）是<strong>二类分类的线性分类模型</strong>，其输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间中将实例划分为正负两类的<strong>分离超平面</strong>，属于<strong>判别模型</strong>。感知机学习旨在求出将训练数据进行线性划分的分离超平面，为此导入了<strong>基于误分类的损失函数</strong>，利用<strong>梯度下降法</strong>对损失函数进行极小化，求得感知机模型。感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知基模型对新的输入实例进行分类。<em>感知机是神经网络与支持向量机的基础</em>。<br><a id="more"></a><br><strong>关键字：二分类，线性分类模型，分离超平面，判别模型，基于误分类的损失函数，随机梯度下降法</strong></p>
</blockquote>
<h2 id="感知机模型——分离超平面"><a href="#感知机模型——分离超平面" class="headerlink" title="感知机模型——分离超平面"></a>感知机模型——<strong>分离超平面</strong></h2><h3 id="数学表达"><a href="#数学表达" class="headerlink" title="数学表达"></a>数学表达</h3><p>$$f(x) = sign(w \cdot x + b)$$</p>
<ul>
<li>输入空间：$R^n$</li>
<li>输出空间：$\lbrace+1, -1 \rbrace$</li>
<li>假设空间：$\lbrace f|f(x) = w \cdot x + b\rbrace$，表示定义在特征空间中的所有线性分类模型或线性分类器</li>
<li>$w \in R^n$，其中$w$表示权值向量，几何意义为<em>超平面的法向量</em></li>
<li>$b \in R$，$b$表示偏置，几何意义为超平面的截距</li>
</ul>
<p><em>Note:模型学习的目的在于通过训练集求得模型的参数$w$和$b$</em></p>
<h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><blockquote>
<p>感知机的几何解释：线性方程$w \cdot x + b = 0$ 对应特征空间$R^n$中的一个超平面$S$,其中$w$是超平面的法向量，$b$是超平面的截距，这个超平面将特征空间划分为两个部分，位于两部分的点（特征向量）分别被分为正、负两类，因此，超平面$S$称为分离超平面。</p>
</blockquote>
<h2 id="感知机的学习策略"><a href="#感知机的学习策略" class="headerlink" title="感知机的学习策略"></a>感知机的学习策略</h2><h3 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h3><p>给定一个数据集$T={(x_1, y_1), (x_2, y_2),…,(x_N, y_N)}$,其中$x_i \in R^n$,$y_i \in \lbrace+1, -1 \rbrace$,$i=1, 2, 3…, N$，若存在超平面$S$设为$w \cdot x + b = 0$将数据集的正实例点和负实例点完全正确地划分到$S$两侧，则称数据集$T$为线性可分数据集</p>
<h3 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h3><ul>
<li><p>目标：求得一个能将训练集正实例点和负实例点完全正确分开的分类超平面——&gt;确定$w, b$</p>
</li>
<li><p>转化：经验损失函数最小化——基于误分类</p>
<ul>
<li>直观思路：<del>误分类点总数，非$w, b$的连续可导函数，不易优化</del></li>
<li>修改：误分类点到超平面$S$的总距离$$L(w, b)=-\sum_{x_i \in M} y_i(w \cdot x_i + b)$$,其中$M$为误分类点的集合，损失函数$L(w, b)$是$w, b$的连续可导函数。(简单的解释一下，此处计算误差取的是所有误分类点的集合，所以式中$y_i(w\cdot x_i+b)$符号为负，这是前面的负号的由来，另外表示点到平面的距离的主要是$w\cdot x_i+b$这部分，其中$x_i$为平面外一点，$w,b$分别为平面的法向量和截距，这里的计算省略了绝对值符号（原因同负号的由来），另外省略了分子法向量的平方和，应该是求解最小化误差时，该项不影响所以简化了计算，具体的推导可以参见下面的链接)</li>
</ul>
</li>
</ul>
<p><em>Note:</em></p>
<ul>
<li>感知机的学习策略是在假设空间中选取使损失函数最小的模型参数$w, b$，即感知机模型。</li>
<li><a href="http://www.cnblogs.com/graphics/archive/2010/07/10/1774809.html" target="_blank" rel="external">点到平面的距离推导</a></li>
<li><a href="https://www.zhihu.com/question/20473040" target="_blank" rel="external">范数的通俗解释</a></li>
<li>另外关于范数、规范化的理解，这篇<a href="http://blog.csdn.net/zouxy09/article/details/24971995/" target="_blank" rel="external">博文</a>写的深入浅出</li>
</ul>
<h2 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h2><h3 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>随机梯度下降法</p>
<blockquote>
<p>输入：训练集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $，其中$x_i \in R^n$,$y_i \in \lbrace+1, -1 \rbrace$,$i=1, 2, 3…, N$，学习率$\eta (0&lt; \eta \leq 1)$<br>  输出：$w, b$;感知机模型$f(x) = sign(w \cdot x + b)$<br>  (1) 选取初值$w_0, b_0$<br>  (2) 在训练集中选取数据$(x_i, y_i)$<br>  (3) if $y_i(w \cdot x_i + b) \leq 0$即为误分类点<br>    $w \leftarrow  w + \eta y_i x_i$<br>    $b \leftarrow  b + \eta y_i  $<br>  (4) 转至(2)，直至训练集中没有误分类点</p>
</blockquote>
<h4 id="几何解释-1"><a href="#几何解释-1" class="headerlink" title="几何解释"></a>几何解释</h4><p>当一个实例点被误分类，即位于分离超平面的错误的一侧时，则调整$w, b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直至超平面越过该误分类点使其被正确分类。</p>
<h4 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h4><ul>
<li>首先任意选取一个超平面$w_0, b_0$，然后用随机梯度下降法不断地极小化目标函数</li>
</ul>
<p>$$L(w, b)= - \sum_{x_i \in M} y_i(w \cdot x_i + b)$$</p>
<ul>
<li>极小化过程中不是一次使$M$中的所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降<ul>
<li>若误分类点集合M固定，损失函数的梯度计算<ul>
<li>$$\frac{\partial L(w,b)}{\partial w}=- \sum_{x_i \in M}y_i x_i$$</li>
<li>$$\frac{\partial L(w,b)}{\partial b}=- \sum_{x_i \in M}y_i$$</li>
</ul>
</li>
<li>随机选取一个误分类点$(x_i, y_i)$对$w, b$进行更新：    <ul>
<li>$$w \leftarrow  w + \eta y_i x_i$$</li>
<li>$$b \leftarrow  b + \eta y_i $$</li>
</ul>
</li>
</ul>
</li>
<li>通过迭代可使损失函数$L(w, b)$不断减小，直到为0。</li>
</ul>
<h3 id="算法的收敛性"><a href="#算法的收敛性" class="headerlink" title="算法的收敛性"></a>算法的收敛性</h3><p>证明如下<br><img src="/materials/img/Perceptron/Convergence_1.JPG" alt="convergence_1"><br><img src="/materials/img/Perceptron/Convergence_2.JPG" alt="convergence_2"><br><img src="/materials/img/Perceptron/Convergence_3.JPG" alt="convergence_3"><br><img src="/materials/img/Perceptron/Convergence_4.JPG" alt="convergence_4"></p>
<p>另外可以看看其他人写的<a href="http://www.cs.columbia.edu/~mcollins/courses/6998-2012/notes/perc.converge.pdf" target="_blank" rel="external">证明过程</a></p>
<p><em>Note: 当训练数据集线性可分时，感知机学习算法存在无穷多个解，其解由于不同的初值或不同的迭代顺序而可能有所不同。相对的，线性可分支持向量机则克服了这一点，根据间隔最大化从无穷多个超平面中唯一确定了一个</em></p>
<h3 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>将$w$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w, b$。</p>
<ul>
<li>假设初始值$w_0, b_0$均为0，对误分类点$(x_i, y_i)$，通过<ul>
<li>$$w \leftarrow  w + \eta y_i x_i$$</li>
<li>$$b \leftarrow  b + \eta y_i $$</li>
</ul>
</li>
<li>逐步修改$w, b$，假设修改$n$次，则$w, b$可分别表示为：<ul>
<li>$$w= \sum_{i=1}^{N} \alpha_i y_i x_i$$</li>
<li>$$b= \sum_{i=1}^{N} \alpha_i y_i$$</li>
</ul>
</li>
<li>每个实例点对应有一个$\alpha_i$满足$\alpha_i \geq 0$且当$\eta = 1$时，$\alpha_i$就表示第$i$个实例点由于误分类而进行更新的次数。</li>
<li>实例点更新次数越多，意味着它距离分离超平面越接近，也就越难以正确分类，换言之，这种实例对学习结果影响最大（有点支持向量机中的支持向量的意思）。</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><blockquote>
<p>输入：线性可分的数据集$T= \lbrace (x_1, y_1), (x_2, y_2),…,(x_N, y_N) \rbrace $，其中$x_i \in R^n$,$y_i \in \lbrace +1, -1 \rbrace$,$i=1, 2, 3…, N$，学习率$\eta (0&lt; \eta \leq 1)$</p>
<p>输出：$\alpha, b$；感知机模型$f(x) = sign(\sum_{j=1}^{N} \alpha_j y_j x_j \cdot x + b)$,其中$\alpha=(alpla_1, alpla_2,…,alpla_N)^T$<br>(1): $\alpha \leftarrow 0$, $b \leftarrow 0$<br>(2): 计算所有样本内积形成的Gram矩阵$G$，</p>
<p>$$G=[x_i \cdot x_j ]_{N \times N}$$</p>
<p>(3): 在训练集中选取数据$(x_i, y_i)$，若</p>
<p>$$y_i (\sum_{j=1}^{N} \alpha_j y_j x_j \cdot x_i + b) \leq 0$$</p>
<p>（计算过程中可通过查$G$的值来提高效率）则更新：</p>
<p>$$\alpha_i \leftarrow \alpha_i + \eta$$</p>
<p>$$b \leftarrow b + \eta y_i$$<br>(4): 转至(3)直至没有误分类数据</p>
</blockquote>
<p><em>Note:为什么要引入对偶形式？</em></p>
<ul>
<li><p>首先原始形式中，书中为何要使用随机梯度下降而非批量梯度下降法，个人搜索到的一篇博文里感觉说的有点道理，<a href="http://www.cnblogs.com/pinard/p/6042320.html" target="_blank" rel="external">引用</a>如下</p>
<blockquote>
<p>用普通的基于所有样本的梯度和的均值的批量梯度下降法（BGD）是行不通的，原因在于我们的损失函数里面有限定，只有误分类的M集合里面的样本才能参与损失函数的优化。所以我们不能用最普通的批量梯度下降,只能采用随机梯度下降（SGD）或者小批量梯度下降（MBGD）。 </p>
</blockquote>
</li>
<li><p>此外，关于对偶形式的优势，<a href="https://www.zhihu.com/question/26526858" target="_blank" rel="external">小结</a>一下：</p>
<ul>
<li>对偶形式将权重向量$w$转化为实例$x_i$和标记$y_i$的线性组合形式，且在原书中也提到，对偶形式中的训练实例仅以内积的形式出现，所以可以预先使用Gram矩阵存储，也就是空间换时间的方法提高计算效率</li>
<li>书中这里应该也有点为后续介绍支持向量机做铺垫，所以这里为核函数的引入埋一个伏笔，毕竟感知机是神经网络与支持向量机的基础，而且后面书中在支持向量机部分的讲解也多次使用对偶形式的求解</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>李航《统计学习方法》</li>
<li><a href="http://www.cnblogs.com/graphics/archive/2010/07/10/1774809.html" target="_blank" rel="external">点到平面的距离推导</a></li>
<li><a href="https://www.zhihu.com/question/20473040" target="_blank" rel="external">范数的通俗解释</a></li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/24971995/" target="_blank" rel="external">关于范数、规范化的理解</a></li>
<li><a href="http://www.cs.columbia.edu/~mcollins/courses/6998-2012/notes/perc.converge.pdf" target="_blank" rel="external">http://www.cs.columbia.edu/~mcollins/courses/6998-2012/notes/perc.converge.pdf</a></li>
<li><a href="http://www.cnblogs.com/pinard/p/6042320.html" target="_blank" rel="external">http://www.cnblogs.com/pinard/p/6042320.html</a></li>
<li><a href="https://www.zhihu.com/question/26526858" target="_blank" rel="external">https://www.zhihu.com/question/26526858</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
            <tag> Perceptron </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法笔记(一)]]></title>
      <url>/2017/06/02/Note-StatisticalML/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p><em>本系列文章是个人根据阅读李航博士的《统计学习方法》一书，辅以《机器学习实战》、<a href="http://scikit-learn.org/" target="_blank" rel="external">scikit-learn官方文档</a>等材料整理出来的笔记。</em></p>
<h2 id="统计学习相关概念"><a href="#统计学习相关概念" class="headerlink" title="统计学习相关概念"></a>统计学习相关概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>统计学习(statistical learning)是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测和分析的一门学科</p>
</blockquote>
<a id="more"></a>
<h3 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h3><p>数据</p>
<h3 id="研究目的"><a href="#研究目的" class="headerlink" title="研究目的"></a>研究目的</h3><p>对数据进行预测和分析：学习什么样的模型和如何学习模型（准确、效率）</p>
<h3 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h3><p>构建模型并应用模型进行预测和分析（统计学习方法三要素）</p>
<ul>
<li>模型：模型的假设空间，即学习模型的集合</li>
<li>策略：模型选择的准则</li>
<li>算法：模型学习的算法，求解最优模型的算法</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>监督学习</li>
<li>非监督学习</li>
<li>半监督学习</li>
<li>强化学习</li>
</ul>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="/materials/img/Note_StatisticalML_1/overview.jpg" alt="overview"></p>
<ul>
<li>输入空间：输入所有可能取值的集合</li>
<li>输出空间：输出所有可能取值的集合</li>
<li>特征空间：<ul>
<li>每个具体的输入是一个实例，通常由特征向量表示，所有特征向量存在的空间称为特征空间</li>
<li>有时输入空间与特征空间为相同的空间，不予区分，有时为不同的空间，需要将实例从输入空间映射到特征空间，<strong>模型实际上都是定义在特征空间上</strong></li>
</ul>
</li>
<li>假设空间：学习模型的集合（假设要学习的模型属于某个函数集合），模型属于由输入空间到输出空间的映射的集合，这个集合即假设空间，假设空间的确定意味着学习范围的确定。<ul>
<li>监督学习的模型<ul>
<li>概率模型：条件概率分布$P(Y|X)$</li>
<li>非概率模型：决策函数$Y=f(X)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="联合概率分布"><a href="#联合概率分布" class="headerlink" title="联合概率分布"></a>联合概率分布</h3><p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布$P(X, Y)$(<strong>监督学习关于数据的基本假设</strong>)</p>
<h3 id="监督学习分类"><a href="#监督学习分类" class="headerlink" title="监督学习分类"></a>监督学习分类</h3><ul>
<li>回归问题：输入变量与输出变量均为连续变量的预测问题。</li>
<li>分类问题：输出变量为有限个离散变量的预测问题。</li>
<li>标注问题：输入变量和输出变量均为变量序列的预测问题。</li>
</ul>
<h3 id="问题形式化"><a href="#问题形式化" class="headerlink" title="问题形式化"></a>问题形式化</h3><p>学习与预测——训练与测试</p>
<ul>
<li>学习：利用给定的训练数据集，通过学习（训练）得到一个模型；</li>
<li>预测：对于给定的测试样本中的输入，由所得到的模型给出相应的输出。</li>
</ul>
<h2 id="统计学习方法三要素-针对监督学习"><a href="#统计学习方法三要素-针对监督学习" class="headerlink" title="统计学习方法三要素(针对监督学习)"></a>统计学习方法三要素(针对监督学习)</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>学习什么样的模型，在监督学习过程中，模型指的就是所要学习的条件概率分布或决策函数。</p>
<h3 id="策略（评价标准）"><a href="#策略（评价标准）" class="headerlink" title="策略（评价标准）"></a>策略（评价标准）</h3><p>模型选择的准则：按照什么样的准则学习或选择最优的模型</p>
<ul>
<li>损失函数（代价函数）：一次预测的好坏的度量，常用的包括0-1损失函数、平方损失函数、绝对损失函数、对数(似然)损失函数</li>
<li>风险函数（期望损失）：度量平均意义下模型预测的好坏<ul>
<li>经验风险，用来描述模型与训练数据的契合程度，</li>
<li>结构风险，用来描述模型的某些性质，表示了我们希望获得具有何种性质的模型（比如复杂度较小的模型）<ul>
<li>为引入领域知识和用户意图提供了途径</li>
<li>有助于削减假设空间，从而降低了最小化训练误差的过拟和风险，所以可以被视为<strong>正则化项</strong>，从贝叶斯的角度来看，可认为是提供了模型的<strong>先验概率</strong>，常用的正则化项为$L_p$范数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><del><strong>将监督学习的问题转化为经验风险或结构风险函数的最优化问题（结构风险最小的模型即最优模型）</strong></del></p>
<p><em>《统计学习方法》与《机器学习》上对于结构风险似乎有点区别</em></p>
<p><em>Note:</em></p>
<ul>
<li>在模型选择中，理论上应该使用<code>期望风险</code>函数作为标准，但是由于输入，输出的基本假设$P(X, Y)$联合分布未知（若已知则可直接求解P(Y|X)，不用学习），所以试图使用<code>经验风险</code>（平均损失）来替代，但又由于现实中限于样本容量不会很大，所以要对<code>经验风险</code>进行矫正，于是有了<code>结构风险</code>，在<code>经验风险</code>的基础上添加<code>正则化项</code>来防止过拟合。</li>
<li>最大似然（MLE），最大后验（MAP）都是构造目标函数的方法</li>
<li>在软间隔SVM中，表示最大间隔的部分对应结构风险，而罚项、松弛变量的部分则对应经验风险，参见周志华《机器学习》6.4</li>
</ul>
<h3 id="算法（求解-amp-优化）"><a href="#算法（求解-amp-优化）" class="headerlink" title="算法（求解&amp;优化）"></a>算法（求解&amp;优化）</h3><p>模型学习的算法，即学习模型的具体计算方法</p>
<ul>
<li>用什么样的计算方法求解最优模型（寻找全局最优解）</li>
<li>如何高效实现</li>
</ul>
<p><em>Note:</em></p>
<ul>
<li>一句话小结：针对某一问题，我们提出了一种假设（模型），然后制订了解决该问题的目标（策略/损失函数）；接下来就是采取某种方式来达成这一目标（算法/优化）</li>
<li>常用优化方法大致可以分为两类，一类使用函数的梯度信息，包括一阶的方法，例如梯度下降，以及二阶的方法，例如牛顿法等。当然，还有和梯度无关的方法，例如 fixed point iteration，坐标下降等等</li>
</ul>
<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><h4 id="训练误差-amp-测试误差"><a href="#训练误差-amp-测试误差" class="headerlink" title="训练误差&amp;测试误差"></a>训练误差&amp;测试误差</h4><ul>
<li>训练误差：对判断给定的问题是不是一个容易学习的问题是有意义的，但若一味追求减小训练误差，会出现过拟合的情况（所选模型的复杂度比真模型高）</li>
<li>测试误差：反映了学习方法对未知的测试数据集的预测能力，<strong>测试误差小的方法具有更好的预测能力</strong><br><img src="/materials/img/Note_StatisticalML_1/loss.jpg" alt="loss"><br>所以需要选择复杂度适当的模型，而模型选择常用的两种方法分别是<strong>正则化</strong>和<strong>交叉验证</strong>。</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>结构风险最小化策略的实现，在经验风险的基础上加一个正则化项/罚项</p>
<p>$$ R_{srm}(f)=\frac{1}{N}\sum L(y_i,f(x_i))+\lambda J(f) $$</p>
<p>作用是为了选择经验风险和模型复杂度同时较小的模型(在所有可能选择的模型中，能够很好地解释已知数据并且十分简单的，才是最好的模型)</p>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>重复的使用数据</p>
<h4 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h4><ul>
<li>训练集：训练模型，通过输入数据学习函数中的参数值，得到拟合了数据的“分类器/回归器”等</li>
<li>验证集：模型选择，从不同的模型中选择最佳模型<ul>
<li>从不同类的模型中选择（比如从SVM,GBM,决策树里选择模型）</li>
<li>从同类模型不同超参数(hyperparameter)组合里选择最优超参数组合。</li>
</ul>
</li>
<li>测试集：最终对学习方法的评估<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4></li>
<li>简单交叉验证</li>
<li>S折交叉验证</li>
<li>留一交叉验证</li>
</ul>
<p><em>Note:关于数据集划分的一点理解理解可以参看<a href="/2017/06/01/cv/" title="交叉验证">交叉验证</a>，而关于模型选择可以进一步了解<a href="/2017/06/01/parameter-hyperparameter/" title="参数与超参数">参数与超参数</a></em></p>
<h3 id="学习的泛化能力"><a href="#学习的泛化能力" class="headerlink" title="学习的泛化能力"></a>学习的泛化能力</h3><h4 id="定义：学习方法的泛化能力-generalization-ability-是指由该方法学习到的模型对未知数据的预测能力。"><a href="#定义：学习方法的泛化能力-generalization-ability-是指由该方法学习到的模型对未知数据的预测能力。" class="headerlink" title="定义：学习方法的泛化能力(generalization ability)是指由该方法学习到的模型对未知数据的预测能力。"></a>定义：学习方法的泛化能力(generalization ability)是指由该方法学习到的模型对未知数据的预测能力。</h4><h4 id="评价方法"><a href="#评价方法" class="headerlink" title="评价方法"></a>评价方法</h4><ul>
<li>理论上：泛化误差即期望风险<br>$$ R_{exp}(f)=E_p[L(Y, f(X))]=\int L(y,f(x))P(x,y)dxdy $$</li>
<li>实际应用中：常常用测试误差衡量</li>
</ul>
<h4 id="泛化误差上界"><a href="#泛化误差上界" class="headerlink" title="泛化误差上界"></a>泛化误差上界</h4><p>通过比较两种学习方法的泛化误差上界来比较其优劣（越小越好）</p>
<ul>
<li>样本容量越大，泛化误差上界越小</li>
<li>假设空间越大，泛化误差上界越大</li>
</ul>
<p><strong>训练误差小的模型，其泛化误差也会小</strong></p>
<h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><h3 id="监督学习模型的一般形式"><a href="#监督学习模型的一般形式" class="headerlink" title="监督学习模型的一般形式"></a>监督学习模型的一般形式</h3><ul>
<li>概率模型：条件概率分布$P(Y|X)$</li>
<li>非概率模型：决策函数$Y=f(X)$</li>
</ul>
<h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><table>
<thead>
<tr>
<th>-</th>
<th>生成方法</th>
<th>判别方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>由数据学习联合概率分布$P(X, Y)$,然后求出$P(Y&#124;X)$作为预测的模型,$P(Y&#124;X)=\frac{P(X,Y)}{P(X)}$</td>
<td>由数据直接学习决策函数$f(x)$或条件概率分布$P(Y&#124;X)$作为预测模型</td>
</tr>
<tr>
<td>特点</td>
<td>1.可还原出$P(X, Y)$；<br>2.学习收敛速度更快；<br>3.存在隐变量时仍可用</td>
<td>1.直接面对预测，准确率更高；<br>2.便于数据抽象，特征定义和使用，可简化学习问题</td>
</tr>
<tr>
<td>典型模型</td>
<td>朴素贝叶斯法、隐马尔可夫模型</td>
<td>k-近邻、感知机、决策树、逻辑斯谛回归模型、最大熵模型、SVM、提升方法、条件随机场等</td>
</tr>
<tr>
<td>Note</td>
<td>模型表示了给定输入X产生输出Y的生成关系</td>
<td>判别方法关心的是对给定的输入X，应该预测什么样的输出Y</td>
</tr>
</tbody>
</table>
<h2 id="监督学习方法的应用"><a href="#监督学习方法的应用" class="headerlink" title="监督学习方法的应用"></a>监督学习方法的应用</h2><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>在监督学习中，当输入变量Y取有限个离散值时，预测问题便成为分类问题</p>
<ul>
<li>多类分类问题，包括二分类</li>
<li>评价指标<ul>
<li>分类准确率</li>
<li>精确率&amp;召回率（二分类）——正类、负类、F1值</li>
</ul>
</li>
</ul>
<h3 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h3><p>可以认为是分类问题的一种推广，输入观测序列，输出标记序列(状态序列)</p>
<ul>
<li>学习&amp;标注——条件概率分布</li>
<li>评价指标<ul>
<li>标注准确率</li>
<li>精确率、召回率</li>
</ul>
</li>
<li>常用统计学习方法<ul>
<li>隐马尔可夫模型</li>
<li>条件随机场</li>
</ul>
</li>
<li>应用领域<ul>
<li>信息抽取</li>
<li>自然语言处理</li>
</ul>
</li>
</ul>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系——函数拟合</p>
<ul>
<li>学习&amp;预测<ul>
<li>一元回归 vs 多元回归</li>
<li>线性回归 vs 非线性回归</li>
<li>损失函数：常用平方损失函数—— <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="external">最小二乘法</a></li>
</ul>
</li>
</ul>
<p>参考资料</p>
<ul>
<li>李航《统计学习方法》</li>
<li>周志华《机器学习》</li>
<li><a href="https://www.zhihu.com/question/24900876" target="_blank" rel="external">知乎-最小二乘、极大似然、梯度下降有何区别？</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习方法 </tag>
            
            <tag> Note </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于交叉验证和模型选择的一点思考]]></title>
      <url>/2017/06/01/cv/</url>
      <content type="html"><![CDATA[<p> 首先按照《统计学习方法》第一章的内容，常用的模型选择方法有两种，按照结构风险最小化思想的具体实现即<strong>正则化</strong>以及数据驱动的<strong>交叉验证方法</strong>。</p>
<ul>
<li>CV是用于模型的(评估)挑选和<strong>超参数</strong>(关于超参数和参数的区别请见另一篇<a href="/2017/06/01/parameter-hyperparameter/" title="memo">memo</a>)调整的，首先明确一点，所谓模型，指的是我们用来描述输入数据与最终需要预测的输出数据之间的关联的方法，而不是不同数据拟合的模型得到的实例，比如我们可以说一个<strong>线性回归模型</strong>，但是不会说用不同数据拟合的<strong>线性回归器</strong>为不同的模型；<a id="more"></a></li>
<li>为什么要用CV，这涉及到数据划分的问题，首先我们训练好一个模型后需要评估这个模型的效果，但是如果把全部数据都投入训练就没有数据来进行验证了，常规而言，可以将数据集划分为训练集和验证集比如80%训练、20%验证，但是这样会有一些问题，首先有可能你很不巧的将一些特殊数据划分到这20%的验证集里了(要么效果很好、要么效果很糟糕)，这样的话仅仅这么一组验证集的评估效果就很不稳定也不确切；此外我们划分训练集和验证集就减少了训练数据，而一般而言数据越多训练出的模型方差是越小的，从这个角度来看数据越多一般我们训练的效果更好；</li>
<li>那么有没有方法既可以用上所有数据进行验证和评估、最后又可以用所有数据进行训练呢？所以我们就需要交叉验证，比如五折交叉验证，假设我们仍将数据集8-2划分（80%-20%），对于五折交叉验证，我们就是针对模型进行了五次训练，每次取80%训练数据、20%验证数据，并最终保证每个数据都曾在这五次训练验证中作为20%的验证集对模型进行过评估，这样我们就可以确保我们使用了所有数据对我们的模型进行评估</li>
<li>为什么不用CV中得到的预测器进行预测？一般而言，在做交叉验证时确实可能出现某一组交叉验证的得分较高，我们会试图用这一组数据进行模型的拟合和最终预测，但是这种得分高只是一种表面现象，首先数据量少了，其次这一组验证集并非独立的，是在整个交叉验证中随机生成的，所以这个预测器的结果到底好不好还需要在对额外的数据进行测试，如果数据充足也许你可以用<a href="https://stats.stackexchange.com/a/52312/152084" target="_blank" rel="external">嵌套式的交叉验证</a>进行实验，即第一步用常规内层交叉验证确定最佳模型，然后采用数据驱动的方式(外层交叉验证)拟合最佳的一组预测器</li>
<li>所以CV的作用是用来对不同模型（SVM和生成树等）或者不同(超)参数组合的模型中评估各个模型的效果，而得到最佳(超)参数组合的模型；接下来将所有训练集投入进去拟合预测得到拟合好的预测器最后对测试集进行预测</li>
<li>那么把所有训练集放到模型中会不会导致过拟合呢？答案是不会，过拟合产生的原因是模型过于复杂（模型的参数），而不是数据增加导致，（而不是传入参数的值），增加数据一般而言更有利于训练集的训练，因为一般而言，训练数据越充足，越能反映出真实数据的分布情况，得到一种近似无偏估计的结果</li>
<li><p>补充：关于生成树模型中的early_stopping，按照《统计学习方法》一书的第12章总结部分P213所述</p>
<blockquote>
<p>提升方法没有显示的正则化项，通常通过早停止(early stopping)的方法达到正则化的效果</p>
</blockquote>
<p>所以early_stopping属于正则化的范畴，是另一种模型选择的具体方法。</p>
<p>参考资料<br><a href="https://stats.stackexchange.com/a/52277/152084" target="_blank" rel="external">https://stats.stackexchange.com/a/52277/152084</a><br><a href="http://scikit-learn.org/stable/modules/cross_validation.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/cross_validation.html</a><br><a href="https://stats.stackexchange.com/a/52312/152084" target="_blank" rel="external">https://stats.stackexchange.com/a/52312/152084</a></p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> CV </tag>
            
            <tag> model selection </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习中模型的参数和超参数]]></title>
      <url>/2017/06/01/parameter-hyperparameter/</url>
      <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p>一直以来对于机器学习中的模型训练和模型选择存在一个误区，首先机器学习力的模型通俗来说就是一个函数关系，表明输入数据到输出数据的映射，基本的假设前提是输入数据和输出数据符合某种联合概率分布，而模型训练的过程其实就是在确定函数式的具体参数值的过程，比如假设你要做一个多项式回归分析的模型，比如$f(x)=w_1x_1+w_2x_2+w_3x_3$，那么模型训练的过程中其实就是在学习对应的<code>w</code>的值，那么问题来了，实战中所谓的模型调参来选择模型又指的是什么呢？<a id="more"></a>既然训练已经把参数都确定下来了，那我们调整的参数又是什么？原来这里有个误区在于模型中的<code>parameter</code>和<code>hyperparameter</code>的区别，按照搜集到的资料来看，其实模型中可以分为两种参数，一种是在<strong>训练过程中学习到的参数，即<code>parameter</code></strong>也就是上面公式里的<code>w</code>，而另一种参数则是<code>hyperparameter</code>，这种参数是模型中学习不到的，是我们预先定义的，而模型的调参其实指的是调整<code>hyperparameter</code>，而且不同类型的模型的<code>hyperparameter</code>也不尽相同，比如SVM中的C,树模型中的深度、叶子数以及比较常规的学习率等等，这种参数是在模型训练之前预先定义的，所以关于模型的选择其实更多的指的是选择最佳的<code>hyperparameter</code>组合。</p>
<p>参考资料<br><a href="https://datascience.stackexchange.com/a/14234/31117" target="_blank" rel="external">https://datascience.stackexchange.com/a/14234/31117</a><br><a href="https://www.quora.com/What-are-hyperparameters-in-machine-learning" target="_blank" rel="external">https://www.quora.com/What-are-hyperparameters-in-machine-learning</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> memo </tag>
            
            <tag> parameter </tag>
            
            <tag> hyperparameter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机与生活]]></title>
      <url>/2017/05/30/computer-life/</url>
      <content type="html"><![CDATA[<p>阅读完吴军的《浪潮之巅》，给人的感觉颇有点当初看纪录片《互联网时代》的感觉，简单而言就是你透过作者的眼睛快速浏览了一遍计算机这个行业的发展历程；手头的这本是第二版，看出版时间也是2012年了，到现在算算有点老了，不过对于12年以前发生的一些事情还是能有一个大致的梳理；<br>    这本书上册主要讲述了一些在历史中唱过主角的公司，关于这些公司的兴衰以及作者自己的一些分析判断，下册则更宽泛一点，除了谈谈部分公司，还科普了一些计算机工业界以及商业方面的概念，比如谈信息产业的一些规律，一些公司的商业模式甚至风险投资，金融风暴等等；<br>    下面我想简单谈一谈自己读过这本书的一点点体会，关于计算机和人类的生活。<br><a id="more"></a><br>    我粗略的将计算机的发展历程划分为四个大的阶段，分别是计算时代—自动化时代—互联网时代—数据时代；计算时代比较有代表性的是计算机ENIAC，那个时候还主要用作军事用途，用来计算导弹轨迹之类的，离走进我们的生活还比较远，第二阶段自动化时代比较有代表性的就是微机了（当然这里跳过了面向企业的工作站，主要谈与个人生活相关的），按照作者的说法，这一阶段最有代表性的是三个公司，苹果的个人电脑（一体化）和微软与Intel的联盟（WinTel体系），这一阶段计算机真正开始走入普通人的家庭生活，主要是用于协助处理一些日常的办公工作，属于单机阶段；然后是大家比较熟悉的互联网时代，这一阶段的强大之处在于将计算机连接起来，于是每个用户都不再是孤立的，随着因特网的出现，有一部分人将本地的内容放到了网上，这个时候网上的内容不多，但是比较杂乱无序，所以随之诞生了门户网站比如雅虎等等，他们将互联网上的内容分门别类从而使用户便于查看和获取信息；而随着建立网站的门槛降低，互联网上的内容越来越多，单纯靠人工分类的的门户网站已经满足不了人们的需求了，于是搜索引擎（代表是Google）应运而生，帮助用户在浩瀚的互联网中快速找到自己所需的信息；<br>    如果说互联网时代的关键词是‘内容’；那么数据时代的关键词就是平台了。这个时候，人们已经不满足于只是从互联网上获取信息了，就像不满足于只是从电视接受固定的节目一样，用户开始有‘发出自己的声音’的诉求，也就是创作；于是各个平台相继出现，最有代表性的，早期的Blog可以允许用户自己在网上发布自己的文章，然后是Facebook、Twitter不仅为用户构建了虚拟的社交圈，而且让用户可以在这个圈子里随时随地发出自己的声音并与其他人互动，还有YouTube把平台交给用户，让用户自己去发布自己的视频和收看其他用户的视频；这一阶段的特点是‘平台’ ，比较有代表性的公司并不提供内容，而是让用户自己来做内容的创造者。<br>    而随之而来的是数据的爆发，互联网上的信息变得更加庞杂，在不断炒来炒去的概念‘云计算’，‘大数据’的驱动下，计算机的同学们纷纷投身到数据分析/数据挖掘的工作中，希望能够从庞杂的数据中挖掘出与实际业务相关的有价值的信息；那么，下一步人们的需求在哪呢？是通过数据挖掘对一个人建立画像从而实现对每个人的私人定制服务？还是现在炙手可热的基于VR/AR的虚拟社交？按照前段时间看到的一个关于区块链的演讲，在未来每个人都可以被“数字化”，真实世界的你可以投影到虚拟世界成为一个数字化的、独一无二的你，这大概是一种趋势吧。<br>    最后还是推荐下这本书，作为科普类的读物挺不错的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Reading </tag>
            
            <tag> IT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[来来来，我教你搭个博客好不好哇]]></title>
      <url>/2017/05/30/my-blog/</url>
      <content type="html"><![CDATA[<p>先把我的博客贴一下<a href="izhaoyi.top">Lancelot’s Desert</a></p>
<p>端午节两天时间宅实验室把自己搭建一个博客这么个‘历史遗留问题’解决了下，其实之前也用Hugo搭建过，最后给弄崩了，这次尝试下<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a>，发现倒是异常的顺利，一方面Hexo的整体生态比较完备，另一方面网上找到的教程也很靠谱，下面就把我搭建过程中的一些步骤和踩过的坑记录下。<br><a id="more"></a></p>
<h2 id="基础博客搭建"><a href="#基础博客搭建" class="headerlink" title="基础博客搭建"></a>基础博客搭建</h2><p>首先声明下，基础博客搭建基本上和我所参照的<a href="https://zhuanlan.zhihu.com/p/25471760" target="_blank" rel="external">崔斯特</a>的教程是一致的，只是在顺序和语言上重新组织了一下，因为原博主写的教程已经很简明扼要了。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">git下载</a></li>
<li><a href="https://github.com/" target="_blank" rel="external">github账号</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></li>
</ul>
<p>另外的话写博客最好熟悉一点<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#lists" target="_blank" rel="external">markdown</a>的基本语法，常用的指令不多而且很简单，用的熟练是非常不错的工具，这里也推荐一个markdown的不错的在线编辑器<a href="https://www.zybuluo.com/mdeditor#323984" target="_blank" rel="external">Cmd markdown</a>即时预览的，此外，类似简书、SegmentFault这些网站也是支持MarkDown编辑的，所以如果熟悉这个语法的话还是很方便的。</p>
<h4 id="下载和注册"><a href="#下载和注册" class="headerlink" title="下载和注册"></a>下载和注册</h4><p>基础搭建的话首先需要下载git和node.js(npm)来进行控制台命令的一些输入，以及需要一个github账号，因为我们的博客是挂载在github上的。</p>
<p>在下载好<code>git</code>和<code>node.js</code>并注册好一个<code>github账号</code>后，首先新建一个repository，名称和你的账户名一致，后面添加<code>.github.io</code>域名，比如我的用户名是<code>LancelotHolmes</code>,那么我的repository命名就是<code>LancelotHolmes.github.io</code></p>
<p><img src="/materials/img/my_blog/github.jpg" alt="github"></p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>在完成上述操作并安装好<code>git</code>和<code>node.js</code>之后，我们选择一个路径新建一个文件夹比如我是在D盘的MyBlog，然后执行<code>git bash</code>，可以在开始里搜索，也可以右键然后选择<code>git bash here</code>,在出现的<code>git</code>控制台中输入之前注册的github账号相对应信息，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --<span class="keyword">global</span> user.name <span class="string">"你的账户名"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --<span class="keyword">global</span> user.email <span class="string">"注册github账号时的邮箱"</span></div></pre></td></tr></table></figure>
<p>如图</p>
<p><img src="/materials/img/my_blog/git.jpg" alt="git"></p>
<p>然后是安装Hexo,直接输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h4 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h4><p>同样在MyBlog(或者你命名的目录下)，仍然是刚刚的控制台界面，输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init blog</div></pre></td></tr></table></figure></p>
<p>成功的时候会显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INFO  Start blogging <span class="keyword">with</span> Hexo!</div></pre></td></tr></table></figure>
<p>接下来进入blog目录下，输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<p>或者你也可以新建一个<code>generate.sh</code>脚本文件将上面三条语句写入,因为后面线下测试会多次用到，可以直接在控制台输入<code>./generate.sh</code>，然后在浏览器里输入<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>,这个时候你就可以看到一个网页的基本雏形，这是由于你的<code>\blog\source\_posts</code>路径下已经有一个基本的markdown文件了，而且本身下载的Hexo带了一个<code>landscape</code>的主题文件，在路径<code>\blog\themes</code>下可以看到</p>
<p><img src="/materials/img/my_blog/hello.jpg" alt="hello"></p>
<h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>回到控制台，现在我们需要生成SSH，仍然是在<code>git</code>控制台里，输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"Github的注册邮箱地址"</span></div></pre></td></tr></table></figure>
<p>基本是一直回车，到出现信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/user/.ssh/id_rsa.pub.</div></pre></td></tr></table></figure></p>
<p>在信息对应的路径下找到这个文件，打开它(我是用sublime text打开的)，在你的github界面，右上角头像里选择<code>Settings</code>,左侧选择<code>SSH and GPG keys</code>然后新建一个<code>SSH key</code>,名称随你定，比如我是设置的blog,内容的话把刚刚<code>id_rsa.pub</code>里的内容全选复制进去就好了。</p>
<p><img src="/materials/img/my_blog/ssh.jpg" alt="ssh"></p>
<h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>在blog目录下，用sublime或者其他编辑器打开<code>_config.yml</code>文件，找到对应的字段修改下面的基本参数信息，这里需要注意一下存在多个<code>_config.yml</code>文件，一个是在blog目录下，作为站点配置文件，一般用来做一些常规的配置，另外在各个主题的目录下还有一个<code>_config.yml</code>文件用来进行特定主体的一些个性化设置，后面会经常用到这两个文件，另外就是下面的配置<strong>注意:之后的空格</strong></p>
<p>博客基本信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 博客名称</div><div class="line">subtitle: 副标题</div><div class="line">description: 网页描述</div><div class="line">author: 作者名</div></pre></td></tr></table></figure></p>
<p>推送设置（这里的repo注意修改为自己的github的对应格式）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/LancelotHolmes/LancelotHolmes.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>在控制台输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n <span class="string">"文章名称"</span></div></pre></td></tr></table></figure>
<p><img src="/materials/img/my_blog/new.jpg" alt="new"></p>
<p>这样会在<code>\blog\source\_posts</code>目录下生成对应的markdown文件，你可以通过编辑器打开它并书写你的文章，比如<br><img src="/materials/img/my_blog/computer.jpg" alt="computer"><br>保存后同样的执行<code>./generate.sh</code>然后打开<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>就可以看到你刚刚写好的的文章了。</p>
<p><img src="/materials/img/my_blog/show.jpg" alt="show"></p>
<p>当然我这里展示的界面略有不同，因为我这里设置主题，后面会具体介绍。</p>
<h3 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a>推送到github</h3><p>线下测试发现没有什么问题我们就可以推送到github了，输入如下命令，或者保存为脚本文件<code>deploy.sh</code>然后执行<code>./deploy.sh</code><br>第一次部署到github时可能会出错<code>error deployer not found:github</code>，可以在控制台输入,注意<code>--save</code>必不可少<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<p>过程中会让你输入你的github账号和密码，推送成功后，你就可以通过在浏览器输入你的静态站点名称访问你的博客了，比如<code>LancelotHolmes.github.io</code>,至此一个基本的博客就搭好了，接下来你每次需要写文章只需要经过如下步骤</p>
<ul>
<li>在blog路径下打开<code>git bash</code>控制台然后输入<code>hexo n &quot;文章名&quot;</code></li>
<li>在路径<code>\blog\source\_posts</code>中编辑对应的markdown，编辑好后保存</li>
<li>执行generate.sh进行线下预览（可选）</li>
<li>执行deploy.sh推送到github就可以通过你的站点访问啦</li>
</ul>
<hr>
<h2 id="配置yilia主题"><a href="#配置yilia主题" class="headerlink" title="配置yilia主题"></a>配置yilia主题</h2><p>前面也给大家看到了我的博客的截图，这里我使用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a>主题，目前Hexo主题里面比较热门的两大主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next</a>和<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a>,这里我就我所配置的一些功能和踩过的坑记录一下。主要包括一些基本的配置以及优化</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>基本的主题下载和安装可以直接参照yilia的github对应的<a href="https://github.com/litten/hexo-theme-yilia#配置" target="_blank" rel="external">教程</a>，同样在blog目录下执行<code>git bash</code>控制台，输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div></pre></td></tr></table></figure></p>
<p>然后修改站点配置文件，Hexo根目录下(即blog目录的)的 <code>_config.yml</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: yilia</div></pre></td></tr></table></figure></p>
<p>然后再该文件末尾添加如下语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">jsonContent:</div><div class="line">  meta: false</div><div class="line">  pages: false</div><div class="line">  posts:</div><div class="line">    title: true</div><div class="line">    date: true</div><div class="line">    path: true</div><div class="line">    text: true</div><div class="line">    raw: false</div><div class="line">    content: false</div><div class="line">    slug: false</div><div class="line">    updated: false</div><div class="line">    comments: false</div><div class="line">    link: false</div><div class="line">    permalink: false</div><div class="line">    excerpt: false</div><div class="line">    categories: false</div><div class="line">    tags: true</div></pre></td></tr></table></figure></p>
<h3 id="添加disqus评论"><a href="#添加disqus评论" class="headerlink" title="添加disqus评论"></a>添加disqus评论</h3><p>目前使用的评论比较多，我早期Hugo时使用过<a href="https://disqus.com/" target="_blank" rel="external">disqus</a>也就还是用这个了，主要是需要注册一个disque账号，然后修改<strong>主题目录下的<code>_config.yml</code> 文件</strong>，特别注意这里的路径是<code>\blog\themes\yilia</code>,不再是blog下的文件，后面大部分配置都是针对这个文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disqus: LancelotHolmes</div></pre></td></tr></table></figure></p>
<p>这里的修改为你注册的disqus的<code>short-name</code>,yilia主题下的配置会优先覆盖blog下的配置，如果你是使用其他的评论比如多说，顺言之类的应该适时修改相应的字段后面的false为对应的值，效果如下</p>
<p><img src="/materials/img/my_blog/disqus.jpg" alt="disqus"></p>
<h3 id="添加menu"><a href="#添加menu" class="headerlink" title="添加menu"></a>添加menu</h3><p>原始的主题menu是这样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  主页: /</div><div class="line">  随笔: /tags/随笔/</div></pre></td></tr></table></figure></p>
<p>，我们可以修改为我们所需要的‘类别’，注意由于yilia作者没有预先设置类别（category）而是把他当作tags使，所以这里配置时链接到对应的tags下的路径，修改如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  主页: /</div><div class="line">  阅读: /tags/Reading/</div><div class="line">  机器学习: /tags/ML/</div></pre></td></tr></table></figure></p>
<p>可以根据需要在新建文章是设置标签自动生成对应的路径，可以在<code>\blog\public\tags</code>下看到，然后修改<code>menu</code>下的对应字段即可</p>
<h3 id="RSS-amp-Sitemap"><a href="#RSS-amp-Sitemap" class="headerlink" title="RSS &amp; Sitemap"></a>RSS &amp; Sitemap</h3><p>为什么要用RSS,可以看这篇<a href="http://www.ruanyifeng.com/blog/2006/01/rss.html" target="_blank" rel="external">短文</a>，主要是为了方便对你的博客感兴趣的人将你的博客添加到他的订阅列表中，一旦你有更新他可以在第一时间接收到推送。而<code>sitemap</code>则主要是给搜索引擎用的，方便你的站点能够被google收录，当然这里首先需要绑定一个域名，后续我们会具体介绍。<br>这部分主要是参照<a href="http://www.voidking.com/2015/05/31/deve-hexo-theme-optimize/#添加sitemap" target="_blank" rel="external">voidking</a>和<a href="http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#添加rsssitemap多说头像" target="_blank" rel="external">magicwangs</a>的博客，执行如下语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div><div class="line"></div><div class="line">npm install hexo-generator-sitemap --save</div></pre></td></tr></table></figure></p>
<p>然后照常的执行generate.sh，你可以在路径<code>\blog\public</code>下看到生成的文件<code>atom.xml</code>和<code>sitemap.xml</code>,接下来在<strong>主题目录下的<code>_config.yml</code> 文件</strong>，特别注意这里的路径是<code>\blog\themes\yilia</code>里添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SubNav</span></div><div class="line">subnav:</div><div class="line">  github: <span class="string">"#"</span></div><div class="line">  weibo: <span class="string">"#"</span></div><div class="line">  rss: /atom.xml</div><div class="line">  ...</div></pre></td></tr></table></figure></p>
<p>此外在blog目录下的站点配置文件里(这回是在<code>\blog</code>路径下的_config.yml)添加如下语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sitemap</span></div><div class="line">sitemap:</div><div class="line">    path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">    path: baidusitemap.xm</div><div class="line"></div><div class="line"><span class="comment"># RSS</span></div><div class="line">feed:</div><div class="line">    type: atom</div><div class="line">    path: atom.xml</div><div class="line">    limit: <span class="number">100</span></div></pre></td></tr></table></figure></p>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>有采用本地图片的，也有将图片传到网上制成外链的，我就是用后面那种方法，这里给大家推荐一个不错的工具<a href="https://sm.ms/" target="_blank" rel="external">sm.ms</a>，方便你把你的本地图片传到网上制成markdown、html、url等格式的外部链接<br><img src="/materials/img/my_blog/smms.jpg" alt="smms"><br>制作好后，修改<strong>主题目录下的<code>_config.yml</code> 文件</strong>，注意这里的路径是<code>\blog\themes\yilia</code>里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#你的头像url</span></div><div class="line">avatar: https://ooo<span class="number">.0</span>o0.ooo/<span class="number">2017</span>/<span class="number">05</span>/<span class="number">29</span>/<span class="number">592</span>be5c575c4c.jpg</div></pre></td></tr></table></figure>
<p>链接当然是你刚刚生成的url的链接</p>
<h3 id="其他社交外链"><a href="#其他社交外链" class="headerlink" title="其他社交外链"></a>其他社交外链</h3><p>同样是修改<strong>主题目录下的<code>_config.yml</code> 文件</strong>，注意这里的路径是<code>\blog\themes\yilia</code>里，位置与之前的rss的地方差不多，根据你想展示的社交平台设置，注意链接是你的社交平台的主页之类的，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SubNav</span></div><div class="line">subnav:</div><div class="line">  github: <span class="string">"https://github.com/LancelotHolmes/"</span></div><div class="line">  weibo: <span class="string">"http://weibo.com/2925991784/profile?topnav=1&amp;wvr=6"</span></div></pre></td></tr></table></figure></p>
<h3 id="文章截断"><a href="#文章截断" class="headerlink" title="文章截断"></a>文章截断</h3><p>直接生成的文章在主页会全部显示，如果不处理会占据较大的篇幅，我们可以在文章的特定位置设置文章截断，这样主页展示的就是部分文字，首先仍然是修改<strong>主题目录下的<code>_config.yml</code> 文件</strong>，注意这里的路径是<code>\blog\themes\yilia</code>里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Content</span></div><div class="line"></div><div class="line"><span class="comment"># 文章太长，截断按钮文字</span></div><div class="line">excerpt_link: more</div></pre></td></tr></table></figure>
<p>然后在你的文章的md文件里你想要阶段的位置插入语句<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!-- more --&gt;</div></pre></td></tr></table></figure></p>
<p>例如<br><img src="/materials/img/my_blog/cut.jpg" alt="cut"></p>
<p>这样就实现了文章的截断，而需要阅读全文只需要点击相应的按钮或者标题即可</p>
<h3 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h3><p>这个主要是为了好玩，就是你的网页打开后的在浏览器的上面的一个小图标，比如github和我的博客的favicon</p>
<p><img src="/materials/img/my_blog/fav.jpg" alt="fav"></p>
<p>我是在<a href="https://www.freefavicon.com/freefavicons/" target="_blank" rel="external">freefavicon</a>上直接选的一个，如果你有兴趣可以自己制作16<em>16的图片就行了，将图片复制到路径<code>\blog\public</code>下，然后在<em>*主题目录下的<code>_config.yml</code> 文件</em></em>里修改即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">favicon: /favicon.png</div></pre></td></tr></table></figure>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>这个是作者目前没有实现的部分，但是有其他的方法，主要参照的是这个<a href="https://github.com/litten/hexo-theme-yilia/pull/120/files" target="_blank" rel="external">post</a>,修改主要涉及这么两个文件</p>
<ul>
<li><p>在<code>/themes/yilia/layout/_partial/article.ejs</code>文件里18行左右的位置插入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;% if (!index)&#123; %&gt;</div><div class="line">   &lt;% if (toc(post.content))&#123; %&gt;            </div><div class="line">     &lt;div id="toc" class="article-toc"&gt;</div><div class="line">     &lt;h2&gt;目录&lt;/h2&gt;</div><div class="line">      &lt;%- toc(post.content) %&gt;  </div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script type="text/javascript"&gt;</div><div class="line">       var _article = document.getElementsByClassName('article')[0];</div><div class="line">       &lt;!-- setTimeout("_article.style.marginRight = '211px'",0);  --&gt;</div><div class="line">       setTimeout("_article.className += ' article2'",0); </div><div class="line">       setTimeout("document.getElementById('toc').style.right = '15px'", 0);                </div><div class="line">     &lt;/script&gt;</div><div class="line">   &lt;% &#125; %&gt;</div><div class="line"> &lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>\themes\yilia\source-src\css\article.scss</code>文件的末尾添加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@media (max-width: 1099px)&#123;</span></div><div class="line">   <span class="comment">#toc&#123;</span></div><div class="line">     display: none;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="meta">@media (min-width: 1100px) &#123;</span></div><div class="line"> <span class="comment">#toc&#123;</span></div><div class="line">   z-index: <span class="number">999</span>;</div><div class="line">   background-color: <span class="comment">#fff;</span></div><div class="line">   padding: <span class="number">0</span> <span class="number">1</span>em;</div><div class="line">   border:<span class="number">1</span>px solid <span class="comment">#ddd;</span></div><div class="line">   position: fixed;</div><div class="line">   top: <span class="number">100</span>px;</div><div class="line">   right: <span class="number">-180</span>px;</div><div class="line">   transition: right <span class="number">.5</span>s ease-<span class="keyword">in</span>;</div><div class="line">   width: <span class="number">150</span>px;</div><div class="line">   h2&#123;</div><div class="line">     margin-bottom:<span class="number">10</span>px;</div><div class="line">   &#125;</div><div class="line">   ol&#123;</div><div class="line">     padding-left: <span class="number">0</span>!important;</div><div class="line">   &#125;</div><div class="line">   line-height: <span class="number">1.3</span>em;</div><div class="line">   font-size: <span class="number">0.8</span>em;</div><div class="line">   float: right;</div><div class="line">   .toc&#123;</div><div class="line">     padding: <span class="number">0</span>;</div><div class="line">     li&#123;</div><div class="line">       list-style-type: none;</div><div class="line">       margin: <span class="number">.5</span>em <span class="number">0</span> <span class="number">.5</span>em;</div><div class="line">       ol&#123;</div><div class="line">         margin: <span class="number">.5</span>em <span class="number">0</span> <span class="number">.5</span>em <span class="number">1</span>em;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> .article2&#123;</div><div class="line">   margin-right: <span class="number">211</span>px;</div><div class="line">   transition: margin-right <span class="number">.5</span>s ease-<span class="keyword">in</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.toc-item span &#123;</div><div class="line">display: table-cell;</div><div class="line">&#125;</div><div class="line">span.toc-text &#123;</div><div class="line">padding-left: <span class="number">3</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即可实现，如图<br><img src="/materials/img/my_blog/toc.jpg" alt="toc"><br>如果没有效果，可以尝试在需要目录的文章头部添加如下语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: 使用机器学习识别出拍卖场中作弊的机器人用户</div><div class="line">date: <span class="number">2017</span><span class="number">-05</span><span class="number">-29</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">51</span></div><div class="line">tags: [ML, Kaggle, Python]</div><div class="line">toc: true</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>以上内容基本可以搭建起一个还不错的博客了，当然如果你需要其他的一些好玩的功能比如标签云啊，浏览量、动态特效之类的就多多使用搜索引擎咯，另外，遇到什么问题大部分都能在对应的github的<a href="https://github.com/litten/hexo-theme-yilia/issues?page=2&amp;q=%E5%9F%9F%E5%90%8D&amp;utf8=%E2%9C%93" target="_blank" rel="external">issues</a>找到答案。</p>
<hr>
<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>最后就介绍下域名的绑定，如果你也不满足使用github的二级域名，而是想使用专属于你自己的域名，那么这部分就是为你而准备的。</p>
<p>这部分也是参照了不少文章，比如<a href="http://www.isetsuna.com/hexo/domain-dns/" target="_blank" rel="external">Setsuna</a>和<a href="http://www.jianshu.com/p/834d7cc0668d" target="_blank" rel="external">水瓶座IOSer</a>，还有<a href="http://zhaozhiming.github.io/blog/2016/08/20/use-gitpage-to-publis-your-site-with-custom-domain/" target="_blank" rel="external">zhaozhiming</a>下面我就简单的叙述一下。</p>
<h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><ul>
<li><a href="https://www.namesilo.com/account_home.php" target="_blank" rel="external">namesilo</a>: 购买域名的地方，经过一番查阅感觉这个相对靠谱</li>
<li><a href="https://www.dnspod.cn/console/dns/izhaoyi.top" target="_blank" rel="external">DNSPod</a>: 国内的免费DNS服务，后面将域名的dns转移到这个上面</li>
</ul>
<p>首先要绑定域名自然需要购买一个域名，国内的话可以试试阿里云、万网，学生的话好像可以试试腾讯云的云服务器，是会送免费的.cn域名，但是国内购买的话需要去公安局备份好象，感觉比较麻烦我就是用了国外的，比如namesilo，其他的介绍可以看看<a href="http://zhaozhiming.github.io/blog/2016/08/20/use-gitpage-to-publis-your-site-with-custom-domain/" target="_blank" rel="external">zhaozhiming</a>的对应观点，当然他和我一样也是在知乎上的一个地方看到的；</p>
<p>在namesilo上注册的教程可以看<a href="https://www.bbsmax.com/A/n2d9ZDYozD/" target="_blank" rel="external">这个</a>,选择好域名并付款后（支持支付宝）的基本设置可以看<a href="https://www.bbsmax.com/A/ZOJPWNxzvV/" target="_blank" rel="external">这个</a>，接下来：</p>
<h3 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h3><p>在你的本地站点目录里的source目录下添加一个CNAME文件，<strong>不带后缀</strong>，用编辑器打开并输入你购买的域名，<strong>不要http也不要www</strong>,比如我的域名是<code>izhaoyi.top</code>,我就写入<code>izhaoyi.top</code>然后保存以后执行<code>deploy</code>。</p>
<h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><h4 id="namesilo"><a href="#namesilo" class="headerlink" title="namesilo"></a>namesilo</h4><p>登陆namesilo之后，右上角的<code>Manage My Domains</code>点击进入后,选择<br><img src="/materials/img/my_blog/namesilo.jpg" alt="namesilo"><br>然后下拉，选择<br><img src="/materials/img/my_blog/namesilo_dns2.png" alt="namesilo2"><br>在上面手动添加两条记录，如图<br><img src="/materials/img/my_blog/namesilo3.jpg" alt="namesilo3"><br>然后回到域名管理界面，选中域名那一栏最前面的勾选框，然后选择上面的<code>Change Namesevers</code>图标<br><img src="/materials/img/my_blog/namesilo4.png" alt="namesilo4"><br>最后在在<code>NameServer1</code>和<code>NameServer2</code>中填写 <code>DNSPod</code> 的 nameserver 地址<code>f1g1ns1.dnspod.net</code>，<code>f1g1ns2.dnspod.net</code><br><img src="/materials/img/my_blog/namesilo5.png" alt="namesilo5"></p>
<h4 id="DNSPod"><a href="#DNSPod" class="headerlink" title="DNSPod"></a>DNSPod</h4><p>同样完成注册后，在<code>域名注册</code>中需要手动添加你购买的域名，并添加一些记录，最终如图<br><img src="/materials/img/my_blog/dnspod.jpg" alt="dnspod"><br>这里的<code>192.30.252.153</code>是github pages的ip地址，固定设置成这个就好，然后稍微等一段时间（也许不用等）应该就可以通过访问你的域名比如<code>izhaoyi.top</code>或者你之前的github站点名比如<code>LancelotHolmes.github.io</code>访问你的博客啦。</p>
<p>最后，欢迎大家来我的<a href="izhaoyi.top">博客</a>踩踩，也欢迎跟我互加友链啊~</p>
]]></content>
      
        
        <tags>
            
            <tag> Coding </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用机器学习识别出拍卖场中作弊的机器人用户(二)]]></title>
      <url>/2017/05/29/HumenOrRobot2/</url>
      <content type="html"><![CDATA[<p><em>原创文章，首发于<a href="https://segmentfault.com/a/1190000009101577#articleHeader12" target="_blank" rel="external">SegmentFault</a></em><br><!-- 本文承接上一篇文章:[使用机器学习识别出拍卖场中作弊的机器人用户](../HumenOrRobot) --></p>
<p>本文承接上一篇文章:<a href="/2017/05/29/HumenOrRobot/" title="使用机器学习识别出拍卖场中作弊的机器人用户">使用机器学习识别出拍卖场中作弊的机器人用户</a></p>
<p>本项目为kaggle上Facebook举行的一次比赛，地址见数据来源，完整代码见我的<a href="https://github.com/LancelotHolmes/HumanOrRobot" target="_blank" rel="external">github</a>,欢迎来玩~</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>数据探索——Data_Exploration.ipynb</li>
<li>数据预处理&amp;特征工程——Feature_Engineering.ipynb &amp; Feature_Engineering2.ipynb</li>
<li>模型设计及评测——Model_Design.ipynb</li>
</ul>
<a id="more"></a>
<h2 id="项目数据来源"><a href="#项目数据来源" class="headerlink" title="项目数据来源"></a>项目数据来源</h2><ul>
<li><a href="https://www.kaggle.com/c/facebook-recruiting-iv-human-or-bot/data" target="_blank" rel="external">kaggle</a><h2 id="项目所需额外工具包"><a href="#项目所需额外工具包" class="headerlink" title="项目所需额外工具包"></a>项目所需额外工具包</h2></li>
<li><a href="http://www.numpy.org/" target="_blank" rel="external">numpy</a></li>
<li><a href="http://pandas.pydata.org/" target="_blank" rel="external">pandas</a></li>
<li><a href="https://matplotlib.org/index.html" target="_blank" rel="external">matplotlib</a></li>
<li><a href="http://scikit-learn.org/stable/" target="_blank" rel="external">sklearn</a></li>
<li><a href="https://xgboost.readthedocs.io/en/latest//parameter.html#parameters-for-tree-booster" target="_blank" rel="external">xgboost</a></li>
<li><a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">lightgbm</a></li>
<li><a href="https://github.com/rasbt/mlxtend" target="_blank" rel="external">mlxtend</a>: 含有聚和算法Stacking<br>项目整体运行时间预估为60min左右，在Ubuntu系统，8G内存，运行结果见所提交的jupyter notebook文件</li>
</ul>
<hr>
<p>由于文章内容过长，所以分为两篇文章，总共包含四个部分</p>
<ul>
<li>数据探索</li>
<li>数据预处理及特征工程</li>
<li>模型设计</li>
<li>评估及总结</li>
</ul>
<hr>
<h2 id="特征工程-续"><a href="#特征工程-续" class="headerlink" title="特征工程(续)"></a>特征工程(续)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> pickle</div><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bids = pd.read_csv('bids.csv')</span></div><div class="line">bids = pickle.load(open(<span class="string">'bids.pkl'</span>))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> bids.shape</div><div class="line">display(bids.head())</div></pre></td></tr></table></figure>
<pre><code>(7656329, 9)
</code></pre><table>
<thead>
<tr>
<th>bid_id</th>
<th>bidder_id</th>
<th>auction</th>
<th>merchandise</th>
<th>device</th>
<th>time</th>
<th>country</th>
<th>ip</th>
<th>url</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8dac2b259fd1c6d1120e519fb1ac14fbqvax8</td>
<td>ewmzr</td>
<td>jewelry</td>
<td>phone0</td>
<td>9759243157894736</td>
<td>us</td>
<td>69.166.231.58</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>1</td>
<td>668d393e858e8126275433046bbd35c6tywop</td>
<td>aeqok</td>
<td>furniture</td>
<td>phone1</td>
<td>9759243157894736</td>
<td>in</td>
<td>50.201.125.84</td>
<td>jmqlhflrzwuay9c</td>
</tr>
<tr>
<td>2</td>
<td>aa5f360084278b35d746fa6af3a7a1a5ra3xe</td>
<td>wa00e</td>
<td>home goods</td>
<td>phone2</td>
<td>9759243157894736</td>
<td>py</td>
<td>112.54.208.157</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>3</td>
<td>3939ac3ef7d472a59a9c5f893dd3e39fh9ofi</td>
<td>jefix</td>
<td>jewelry</td>
<td>phone4</td>
<td>9759243157894736</td>
<td>in</td>
<td>18.99.175.133</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>4</td>
<td>8393c48eaf4b8fa96886edc7cf27b372dsibi</td>
<td>jefix</td>
<td>jewelry</td>
<td>phone5</td>
<td>9759243157894736</td>
<td>in</td>
<td>145.138.5.37</td>
<td>vasstdc27m7nks3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bidders = bids.groupby(<span class="string">'bidder_id'</span>)</div></pre></td></tr></table></figure>
<h3 id="针对国家、商品单一特征多类别转换为多个独立特征进行统计"><a href="#针对国家、商品单一特征多类别转换为多个独立特征进行统计" class="headerlink" title="针对国家、商品单一特征多类别转换为多个独立特征进行统计"></a>针对国家、商品单一特征多类别转换为多个独立特征进行统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cates = (bids[<span class="string">'merchandise'</span>].unique()).tolist()</div><div class="line">countries = (bids[<span class="string">'country'</span>].unique()).tolist()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy_coun_cate</span><span class="params">(group)</span>:</span></div><div class="line">    coun_cate = dict.fromkeys(cates, <span class="number">0</span>)</div><div class="line">    coun_cate.update(dict.fromkeys(countries, <span class="number">0</span>))</div><div class="line">    <span class="keyword">for</span> cat, value <span class="keyword">in</span> group[<span class="string">'merchandise'</span>].value_counts().iteritems():</div><div class="line">        coun_cate[cat] = value</div><div class="line"></div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> group[<span class="string">'country'</span>].unique():</div><div class="line">        coun_cate[c] = <span class="number">1</span></div><div class="line"></div><div class="line">    coun_cate = pd.Series(coun_cate)</div><div class="line">    <span class="keyword">return</span> coun_cate</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bidder_coun_cate = bidders.apply(dummy_coun_cate)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">display(bidder_coun_cate.describe())</div><div class="line">bidder_coun_cate.to_csv(<span class="string">'coun_cate.csv'</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th>ad</th>
<th>ae</th>
<th>af</th>
<th>ag</th>
<th>al</th>
<th>am</th>
<th>an</th>
<th>ao</th>
<th>ar</th>
<th>at</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>6609.0</td>
<td>…</td>
</tr>
<tr>
<td>mean</td>
<td>0.002724</td>
<td>0.205629</td>
<td>0.054774</td>
<td>0.001059</td>
<td>0.048570</td>
<td>0.023907</td>
<td>0.000303</td>
<td>0.036314</td>
<td>0.120442</td>
<td>0.052655</td>
<td>…</td>
</tr>
<tr>
<td>std</td>
<td>0.052121</td>
<td>0.404191</td>
<td>0.227555</td>
<td>0.032530</td>
<td>0.214984</td>
<td>0.152770</td>
<td>0.017395</td>
<td>0.187085</td>
<td>0.325502</td>
<td>0.223362</td>
<td>…</td>
</tr>
<tr>
<td>min</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>…</td>
</tr>
<tr>
<td>25%</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>…</td>
</tr>
<tr>
<td>50%</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>…</td>
</tr>
<tr>
<td>75%</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>…</td>
</tr>
<tr>
<td>max</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>同样的，对于每个用户需要统计他对于自己每次竞拍行为的时间间隔情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bidder_interval</span><span class="params">(group)</span>:</span></div><div class="line">    time_diff = np.ediff1d(group[<span class="string">'time'</span>])</div><div class="line">    bidder_interval = &#123;&#125;</div><div class="line">    <span class="keyword">if</span> len(time_diff) == <span class="number">0</span>:</div><div class="line">        diff_mean = <span class="number">0</span></div><div class="line">        diff_std = <span class="number">0</span></div><div class="line">        diff_median = <span class="number">0</span></div><div class="line">        diff_zeros = <span class="number">0</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        diff_mean = np.mean(time_diff)</div><div class="line">        diff_std = np.std(time_diff)</div><div class="line">        diff_median = np.median(time_diff)</div><div class="line">        diff_zeros = time_diff.shape[<span class="number">0</span>] - np.count_nonzero(time_diff)</div><div class="line">    bidder_interval[<span class="string">'tmean'</span>] = diff_mean</div><div class="line">    bidder_interval[<span class="string">'tstd'</span>] = diff_std</div><div class="line">    bidder_interval[<span class="string">'tmedian'</span>] = diff_median</div><div class="line">    bidder_interval[<span class="string">'tzeros'</span>] = diff_zeros</div><div class="line">    bidder_interval = pd.Series(bidder_interval)</div><div class="line">    <span class="keyword">return</span> bidder_interval</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bidder_inv = bidders.apply(bidder_interval)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">display(bidder_inv.describe())</div><div class="line">bidder_inv.to_csv(<span class="string">'bidder_inv.csv'</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th>tmean</th>
<th>tmedian</th>
<th>tstd</th>
<th>tzeros</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>6.609000e+03</td>
<td>6.609000e+03</td>
<td>6.609000e+03</td>
<td>6609.0</td>
</tr>
<tr>
<td>mean</td>
<td>2.933038e+12</td>
<td>1.860285e+12</td>
<td>3.440901e+12</td>
<td>122.986231</td>
</tr>
<tr>
<td>std</td>
<td>8.552343e+12</td>
<td>7.993497e+12</td>
<td>6.512992e+12</td>
<td>3190.805229</td>
</tr>
<tr>
<td>min</td>
<td>0.000000e+00</td>
<td>0.000000e+00</td>
<td>0.000000e+00</td>
<td>0.000000</td>
</tr>
<tr>
<td>25%</td>
<td>1.192853e+10</td>
<td>2.578947e+09</td>
<td>1.749995e+09</td>
<td>0.000000</td>
</tr>
<tr>
<td>50%</td>
<td>2.641139e+11</td>
<td>5.726316e+10</td>
<td>5.510107e+11</td>
<td>0.000000</td>
</tr>
<tr>
<td>75%</td>
<td>1.847456e+12</td>
<td>6.339474e+11</td>
<td>2.911282e+12</td>
<td>0.000000</td>
</tr>
<tr>
<td>max</td>
<td>7.610295e+13</td>
<td>7.610295e+13</td>
<td>3.800092e+13</td>
<td>231570.000000</td>
</tr>
</tbody>
</table>
<h3 id="按照用户-拍卖场分组进一步分析"><a href="#按照用户-拍卖场分组进一步分析" class="headerlink" title="按照用户-拍卖场分组进一步分析"></a>按照用户-拍卖场分组进一步分析</h3><p>之前的统计是按照用户进行分组，针对各个用户从整体上针对竞标行为统计其各项特征，下面根据拍卖场来对用户进一步细分，看一看每个用户在不同拍卖场的行为模式,类似上述按照用户分组来统计各个用户的各项特征，针对用户-拍卖场结对分组进行统计以下特征</p>
<ul>
<li>基本计数统计，针对各个用户在各个拍卖场统计设备、国家、ip、url、商品类别、竞标次数等特征的数目作为新的特征</li>
<li>时间间隔统计：统计各个用户在各个拍卖场每次竞拍的时间间隔的 均值、方差、中位数和0值</li>
<li>针对商品类别、国家进一步转化为多类别进行统计</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc_features_count</span><span class="params">(group)</span>:</span></div><div class="line">    time_diff = np.ediff1d(group[<span class="string">'time'</span>])</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> len(time_diff) == <span class="number">0</span>:</div><div class="line">        diff_mean = <span class="number">0</span></div><div class="line">        diff_std = <span class="number">0</span></div><div class="line">        diff_median = <span class="number">0</span></div><div class="line">        diff_zeros = <span class="number">0</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        diff_mean = np.mean(time_diff)</div><div class="line">        diff_std = np.std(time_diff)</div><div class="line">        diff_median = np.median(time_diff)</div><div class="line">        diff_zeros = time_diff.shape[<span class="number">0</span>] - np.count_nonzero(time_diff)</div><div class="line"></div><div class="line">    row = dict.fromkeys(cates, <span class="number">0</span>)</div><div class="line">    row.update(dict.fromkeys(countries, <span class="number">0</span>))</div><div class="line"></div><div class="line">    row[<span class="string">'devices_c'</span>] = group[<span class="string">'device'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    row[<span class="string">'countries_c'</span>] = group[<span class="string">'country'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    row[<span class="string">'ip_c'</span>] = group[<span class="string">'ip'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    row[<span class="string">'url_c'</span>] = group[<span class="string">'url'</span>].unique().shape[<span class="number">0</span>]</div><div class="line"><span class="comment">#     row['merch_c'] = group['merchandise'].unique().shape[0]</span></div><div class="line">    row[<span class="string">'bids_c'</span>] = group.shape[<span class="number">0</span>]</div><div class="line">    row[<span class="string">'tmean'</span>] = diff_mean</div><div class="line">    row[<span class="string">'tstd'</span>] = diff_std</div><div class="line">    row[<span class="string">'tmedian'</span>] = diff_median</div><div class="line">    row[<span class="string">'tzeros'</span>] = diff_zeros</div><div class="line"></div><div class="line">    <span class="keyword">for</span> cat, value <span class="keyword">in</span> group[<span class="string">'merchandise'</span>].value_counts().iteritems():</div><div class="line">        row[cat] = value</div><div class="line"></div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> group[<span class="string">'country'</span>].unique():</div><div class="line">        row[c] = <span class="number">1</span></div><div class="line"></div><div class="line">    row = pd.Series(row)</div><div class="line">    <span class="keyword">return</span> row</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bidder_auc = bids.groupby([<span class="string">'bidder_id'</span>, <span class="string">'auction'</span>]).apply(auc_features_count)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bidder_auc.to_csv(<span class="string">'bids_auc.csv'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> bidder_auc.shape</div></pre></td></tr></table></figure>
<pre><code>(382336, 218)
</code></pre><h2 id="模型设计与参数评估"><a href="#模型设计与参数评估" class="headerlink" title="模型设计与参数评估"></a>模型设计与参数评估</h2><h3 id="合并特征"><a href="#合并特征" class="headerlink" title="合并特征"></a>合并特征</h3><p>对之前生成的各项特征进行合并产生最终的特征空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</div></pre></td></tr></table></figure>
<p>首先将之前根据用户分组的统计特征合并起来，然后将其与按照用户-拍卖场结对分组的特征合并起来，最后加上时间特征，分别于训练集、测试集连接生成后续进行训练和预测的特征数据文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_data</span><span class="params">()</span>:</span>    </div><div class="line">    train = pd.read_csv(<span class="string">'train.csv'</span>)</div><div class="line">    test = pd.read_csv(<span class="string">'test.csv'</span>)</div><div class="line"></div><div class="line">    time_differences = pd.read_csv(<span class="string">'tdiff.csv'</span>, index_col=<span class="number">0</span>)</div><div class="line">    bids_auc = pd.read_csv(<span class="string">'bids_auc.csv'</span>)</div><div class="line"></div><div class="line">    bids_auc = bids_auc.groupby(<span class="string">'bidder_id'</span>).mean()</div><div class="line">    </div><div class="line">    bidders = pd.read_csv(<span class="string">'cnt_bidder.csv'</span>, index_col=<span class="number">0</span>)</div><div class="line">    country_cate = pd.read_csv(<span class="string">'coun_cate.csv'</span>, index_col=<span class="number">0</span>)</div><div class="line">    bidder_inv = pd.read_csv(<span class="string">'bidder_inv.csv'</span>, index_col=<span class="number">0</span>)</div><div class="line">    bidders = bidders.merge(country_cate, right_index=<span class="keyword">True</span>, left_index=<span class="keyword">True</span>)</div><div class="line">    bidders = bidders.merge(bidder_inv, right_index=<span class="keyword">True</span>, left_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    bidders = bidders.merge(bids_auc, right_index=<span class="keyword">True</span>, left_index=<span class="keyword">True</span>)</div><div class="line">    bidders = bidders.merge(time_differences, right_index=<span class="keyword">True</span>,</div><div class="line">                            left_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    train = train.merge(bidders, left_on=<span class="string">'bidder_id'</span>, right_index=<span class="keyword">True</span>)</div><div class="line">    train.to_csv(<span class="string">'train_full.csv'</span>, index=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">    test = test.merge(bidders, left_on=<span class="string">'bidder_id'</span>, right_index=<span class="keyword">True</span>)</div><div class="line">    test.to_csv(<span class="string">'test_full.csv'</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">merge_data()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">train_full = pd.read_csv(<span class="string">'train_full.csv'</span>)</div><div class="line">test_full = pd.read_csv(<span class="string">'test_full.csv'</span>)</div><div class="line"><span class="keyword">print</span> train_full.shape</div><div class="line"><span class="keyword">print</span> test_full.shape</div></pre></td></tr></table></figure>
<pre><code>(1983, 445)
(4626, 444)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">train_full[<span class="string">'outcome'</span>] = train_full[<span class="string">'outcome'</span>].astype(int)</div><div class="line">ytrain = train_full[<span class="string">'outcome'</span>]</div><div class="line">train_full.drop(<span class="string">'outcome'</span>, <span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">test_ids = test_full[<span class="string">'bidder_id'</span>]</div><div class="line"></div><div class="line">labels = [<span class="string">'payment_account'</span>, <span class="string">'address'</span>, <span class="string">'bidder_id'</span>]</div><div class="line">train_full.drop(labels=labels, axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">test_full.drop(labels=labels, axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h3 id="设计交叉验证"><a href="#设计交叉验证" class="headerlink" title="设计交叉验证"></a>设计交叉验证</h3><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>根据之前的分析，由于当前的数据集中存在正负例不均衡的问题，所以考虑选取了RandomForestClassfier, GradientBoostingClassifier, xgboost, lightgbm等四种模型来针对数据及进行训练和预测，确定最终模型的基本思路如下：</p>
<ul>
<li>对四个模型分别使用评价函数roc_auc进行交叉验证并绘制auc曲线，对各个模型的多轮交叉验证得分取平均值并输出</li>
<li>根据得分确定最终选用的一个或多个模型<ul>
<li>若最后发现一个模型的表现大幅度优于其他所有模型，则选择该模型进一步调参</li>
<li>若最后发现多个模型表现都不错，则进行模型的集成，得到聚合模型</li>
<li>使用GridSearchCV来从人为设定的参数列表中选择最佳的参数组合确定最终的模型</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> interp</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line"></div><div class="line"><span class="comment"># from sklearn.cross_validation import StratifiedKFold</span></div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score, roc_curve, auc</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">kfold_plot</span><span class="params">(train, ytrain, model)</span>:</span></div><div class="line"><span class="comment">#     kf = StratifiedKFold(y=ytrain, n_folds=5)</span></div><div class="line">    kf = StratifiedKFold(n_splits=<span class="number">5</span>)</div><div class="line">    scores = []</div><div class="line">    mean_tpr = <span class="number">0.0</span></div><div class="line">    mean_fpr = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</div><div class="line">    exe_time = []</div><div class="line">    </div><div class="line">    colors = cycle([<span class="string">'cyan'</span>, <span class="string">'indigo'</span>, <span class="string">'seagreen'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>])</div><div class="line">    lw = <span class="number">2</span></div><div class="line">    </div><div class="line">    i=<span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (train_index, test_index), color <span class="keyword">in</span> zip(kf.split(train, ytrain), colors):</div><div class="line">        X_train, X_test = train.iloc[train_index], train.iloc[test_index]</div><div class="line">        y_train, y_test = ytrain.iloc[train_index], ytrain.iloc[test_index]</div><div class="line">        begin_t = time.time()</div><div class="line">        predictions = model(X_train, X_test, y_train)</div><div class="line">        end_t = time.time()</div><div class="line">        exe_time.append(round(end_t-begin_t, <span class="number">3</span>))</div><div class="line"><span class="comment">#         model = model</span></div><div class="line"><span class="comment">#         model.fit(X_train, y_train)    </span></div><div class="line"><span class="comment">#         predictions = model.predict_proba(X_test)[:, 1]        </span></div><div class="line">        scores.append(roc_auc_score(y_test.astype(float), predictions))        </div><div class="line">        fpr, tpr, thresholds = roc_curve(y_test, predictions)</div><div class="line">        mean_tpr += interp(mean_fpr, fpr, tpr)</div><div class="line">        mean_tpr[<span class="number">0</span>] = <span class="number">0.0</span></div><div class="line">        roc_auc = auc(fpr, tpr)</div><div class="line">        plt.plot(fpr, tpr, lw=lw, color=color, label=<span class="string">'ROC fold %d (area = %0.2f)'</span> % (i, roc_auc))</div><div class="line">        i += <span class="number">1</span></div><div class="line">    plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], linestyle=<span class="string">'--'</span>, lw=lw, color=<span class="string">'k'</span>, label=<span class="string">'Luck'</span>)</div><div class="line">    </div><div class="line">    mean_tpr /= kf.get_n_splits(train, ytrain)</div><div class="line">    mean_tpr[<span class="number">-1</span>] = <span class="number">1.0</span></div><div class="line">    mean_auc = auc(mean_fpr, mean_tpr)</div><div class="line">    plt.plot(mean_fpr, mean_tpr, color=<span class="string">'g'</span>, linestyle=<span class="string">'--'</span>, label=<span class="string">'Mean ROC (area = %0.2f)'</span> % mean_auc, lw=lw)</div><div class="line">    </div><div class="line">    plt.xlim([<span class="number">-0.05</span>, <span class="number">1.05</span>])</div><div class="line">    plt.ylim([<span class="number">-0.05</span>, <span class="number">1.05</span>])</div><div class="line">    plt.xlabel(<span class="string">'False Positive Rate'</span>)</div><div class="line">    plt.ylabel(<span class="string">'True Positive Rate'</span>)</div><div class="line">    plt.title(<span class="string">'Receiver operating characteristic'</span>)</div><div class="line">    plt.legend(loc=<span class="string">'lower right'</span>)</div><div class="line">    plt.show()</div><div class="line">    </div><div class="line"><span class="comment">#     print 'scores: ', scores</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'mean scores: '</span>, np.mean(scores)</div><div class="line">    <span class="keyword">print</span> <span class="string">'mean model process time: '</span>, np.mean(exe_time), <span class="string">'s'</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> scores, np.mean(scores), np.mean(exe_time)</div></pre></td></tr></table></figure>
<p>收集各个模型进行交叉验证的结果包括每轮交叉验证的auc得分、auc的平均得分以及模型的训练时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dct_scores = &#123;&#125;</div><div class="line">mean_score = &#123;&#125;</div><div class="line">mean_time = &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="RandomForestClassifier"><a href="#RandomForestClassifier" class="headerlink" title="RandomForestClassifier"></a>RandomForestClassifier</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</div><div class="line"><span class="keyword">import</span> time</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forest_model</span><span class="params">(X_train, X_test, y_train)</span>:</span></div><div class="line"><span class="comment">#     begin_t = time.time()</span></div><div class="line">    model = RandomForestClassifier(n_estimators=<span class="number">160</span>, max_features=<span class="number">35</span>, max_depth=<span class="number">8</span>, random_state=<span class="number">7</span>)</div><div class="line">    model.fit(X_train, y_train)    </div><div class="line"><span class="comment">#     end_t = time.time()</span></div><div class="line"><span class="comment">#     print 'train time of forest model: ',round(end_t-begin_t, 3), 's'</span></div><div class="line">    predictions = model.predict_proba(X_test)[:, <span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'forest'</span>], mean_score[<span class="string">'forest'</span>], mean_time[<span class="string">'forest'</span>] = kfold_plot(train_full, ytrain, forest_model)</div><div class="line"><span class="comment"># kfold_plot(train_full, ytrain, model_forest)</span></div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_forest.png" alt="forest_auc"></p>
<pre><code>mean scores:  0.909571935157
mean model process time:  0.643 s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_model</span><span class="params">(X_train, X_test, y_train)</span>:</span></div><div class="line">    model = GradientBoostingClassifier(n_estimators=<span class="number">200</span>, random_state=<span class="number">7</span>, max_depth=<span class="number">5</span>, learning_rate=<span class="number">0.03</span>)</div><div class="line">    model.fit(X_train, y_train)</div><div class="line">    predictions = model.predict_proba(X_test)[:, <span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'gbm'</span>], mean_score[<span class="string">'gbm'</span>], mean_time[<span class="string">'gbm'</span>] = kfold_plot(train_full, ytrain, gradient_model)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_gbm.png" alt="gbm_auc"></p>
<pre><code>mean scores:  0.911847771023
mean model process time:  4.1948 s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xgboost_model</span><span class="params">(X_train, X_test, y_train)</span>:</span></div><div class="line">    X_train = xgb.DMatrix(X_train.values, label=y_train.values)</div><div class="line">    X_test = xgb.DMatrix(X_test.values)</div><div class="line">    params = &#123;<span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>, <span class="string">'eval_metric'</span>: <span class="string">'auc'</span>, <span class="string">'silent'</span>: <span class="number">1</span>, <span class="string">'seed'</span>: <span class="number">7</span>,</div><div class="line">              <span class="string">'max_depth'</span>: <span class="number">6</span>, <span class="string">'eta'</span>: <span class="number">0.01</span>&#125;    </div><div class="line">    model = xgb.train(params, X_train, <span class="number">600</span>)</div><div class="line">    predictions = model.predict(X_test)</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<pre><code>/home/lancelot/anaconda2/envs/udacity/lib/python2.7/site-packages/sklearn/cross_validation.py:44: DeprecationWarning: This module was deprecated in version 0.18 in favor of the model_selection module into which all the refactored classes and functions are moved. Also note that the interface of the new CV iterators are different from that of this module. This module will be removed in 0.20.
  &quot;This module will be removed in 0.20.&quot;, DeprecationWarning)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'xgboost'</span>], mean_score[<span class="string">'xgboost'</span>], mean_time[<span class="string">'xgboost'</span>] = kfold_plot(train_full, ytrain, xgboost_model)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_xgb.png" alt="xgb_auc"></p>
<pre><code>mean scores:  0.915372340426
mean model process time:  3.1482 s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lightgbm_model</span><span class="params">(X_train, X_test, y_train)</span>:</span></div><div class="line">    X_train = lgb.Dataset(X_train.values, y_train.values)</div><div class="line">    params = &#123;<span class="string">'objective'</span>: <span class="string">'binary'</span>, <span class="string">'metric'</span>: &#123;<span class="string">'auc'</span>&#125;, <span class="string">'learning_rate'</span>: <span class="number">0.01</span>, <span class="string">'max_depth'</span>: <span class="number">6</span>, <span class="string">'seed'</span>: <span class="number">7</span>&#125;</div><div class="line">    model = lgb.train(params, X_train, num_boost_round=<span class="number">600</span>)</div><div class="line">    predictions = model.predict(X_test)</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'lgbm'</span>], mean_score[<span class="string">'lgbm'</span>], mean_time[<span class="string">'lgbm'</span>] = kfold_plot(train_full, ytrain, lightgbm_model)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_lgbm.png" alt="lgbm_auc"></p>
<pre><code>mean scores:  0.921512158055
mean model process time:  0.3558 s
</code></pre><h3 id="模型比较"><a href="#模型比较" class="headerlink" title="模型比较"></a>模型比较</h3><p>比较四个模型在交叉验证机上的roc_auc平均得分和模型训练的时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_model_comp</span><span class="params">(title, y_label, dct_result)</span>:</span></div><div class="line">    data_source = dct_result.keys()</div><div class="line">    y_pos = np.arange(len(data_source))</div><div class="line">    <span class="comment"># model_auc = [0.910, 0.912, 0.915, 0.922]</span></div><div class="line">    model_auc = dct_result.values()</div><div class="line">    barlist = plt.bar(y_pos, model_auc, align=<span class="string">'center'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">    <span class="comment"># get the index of highest score</span></div><div class="line">    max_val = max(model_auc)</div><div class="line">    idx = model_auc.index(max_val)</div><div class="line">    barlist[idx].set_color(<span class="string">'r'</span>)</div><div class="line">    plt.xticks(y_pos, data_source)</div><div class="line">    plt.ylabel(y_label)</div><div class="line">    plt.title(title)</div><div class="line">    plt.show()</div><div class="line">    <span class="keyword">print</span> <span class="string">'The highest auc score is &#123;0&#125; of model: &#123;1&#125;'</span>.format(max_val, data_source[idx])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot_model_comp(<span class="string">'Model Performance'</span>, <span class="string">'roc-auc score'</span>, mean_score)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/model_performance.png" alt="model_performance"></p>
<pre><code>The highest auc score is 0.921512158055 of model: lgbm
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_time_comp</span><span class="params">(title, y_label, dct_result)</span>:</span></div><div class="line">    data_source = dct_result.keys()</div><div class="line">    y_pos = np.arange(len(data_source))</div><div class="line">    <span class="comment"># model_auc = [0.910, 0.912, 0.915, 0.922]</span></div><div class="line">    model_auc = dct_result.values()</div><div class="line">    barlist = plt.bar(y_pos, model_auc, align=<span class="string">'center'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">    <span class="comment"># get the index of highest score</span></div><div class="line">    min_val = min(model_auc)</div><div class="line">    idx = model_auc.index(min_val)</div><div class="line">    barlist[idx].set_color(<span class="string">'r'</span>)</div><div class="line">    plt.xticks(y_pos, data_source)</div><div class="line">    plt.ylabel(y_label)</div><div class="line">    plt.title(title)</div><div class="line">    plt.show()</div><div class="line">    <span class="keyword">print</span> <span class="string">'The shortest time is &#123;0&#125; of model: &#123;1&#125;'</span>.format(min_val, data_source[idx])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot_time_comp(<span class="string">'Time of Building Model'</span>, <span class="string">'time(s)'</span>, mean_time)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/time.png" alt="model_time"></p>
<pre><code>The shortest time is 0.3558 of model: lgbm
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">auc_forest = dct_scores[<span class="string">'forest'</span>]</div><div class="line">auc_gb = dct_scores[<span class="string">'gbm'</span>]</div><div class="line">auc_xgb = dct_scores[<span class="string">'xgboost'</span>]</div><div class="line">auc_lgb = dct_scores[<span class="string">'lgbm'</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">'std of forest auc score: '</span>,np.std(auc_forest)</div><div class="line"><span class="keyword">print</span> <span class="string">'std of gbm auc score: '</span>,np.std(auc_gb)</div><div class="line"><span class="keyword">print</span> <span class="string">'std of xgboost auc score: '</span>,np.std(auc_xgb)</div><div class="line"><span class="keyword">print</span> <span class="string">'std of lightgbm auc score: '</span>,np.std(auc_lgb)</div><div class="line">data_source = [<span class="string">'roc-fold-1'</span>, <span class="string">'roc-fold-2'</span>, <span class="string">'roc-fold-3'</span>, <span class="string">'roc-fold-4'</span>, <span class="string">'roc-fold-5'</span>]</div><div class="line">y_pos = np.arange(len(data_source))</div><div class="line">plt.plot(y_pos, auc_forest, <span class="string">'b-'</span>, label=<span class="string">'forest'</span>)</div><div class="line">plt.plot(y_pos, auc_gb, <span class="string">'r-'</span>, label=<span class="string">'gbm'</span>)</div><div class="line">plt.plot(y_pos, auc_xgb, <span class="string">'y-'</span>, label=<span class="string">'xgboost'</span>)</div><div class="line">plt.plot(y_pos, auc_lgb, <span class="string">'g-'</span>, label=<span class="string">'lightgbm'</span>)</div><div class="line">plt.title(<span class="string">'roc-auc score of each epoch'</span>)</div><div class="line">plt.xlabel(<span class="string">'epoch'</span>)</div><div class="line">plt.ylabel(<span class="string">'roc-auc score'</span>)</div><div class="line">plt.legend()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<pre><code>std of forest auc score:  0.0413757504568
std of gbm auc score:  0.027746291638
std of xgboost auc score:  0.0232931322563
std of lightgbm auc score:  0.0287156755513
</code></pre><p><img src="/materials/img/HumenOrRobot2/roc_epoch.png" alt="stability"></p>
<p>单从5次交叉验证的各模型roc-auc得分来看，xgboost的得分相对比较稳定</p>
<h3 id="聚合模型"><a href="#聚合模型" class="headerlink" title="聚合模型"></a>聚合模型</h3><p>由上面的模型比较可以发现，四个模型的经过交叉验证的表现都不错，但是综合而言，xgboost和lightgbm更胜一筹，而且两者的训练时间也相对更短一些，所以接下来考虑进行模型的聚合，思路如下：</p>
<ul>
<li>先通过GridSearchCV分别针对四个模型在整个训练集上进行调参获得最佳的子模型</li>
<li>针对子模型使用<ul>
<li>stacking: 第三方库<a href="https://github.com/rasbt/mlxtend" target="_blank" rel="external">mlxtend</a>里的stacking方法对子模型进行聚合得到聚合模型，并采用之前相同的cv方法对该模型进行打分评价</li>
<li>voting: 使用sklearn内置的VotingClassifier进行四个模型的聚合</li>
</ul>
</li>
<li>最终对聚合模型在一次进行cv验证评分，根据结果确定最终的模型</li>
</ul>
<p>先通过交叉验证针对模型选择参数组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_xgb_model</span><span class="params">(X_train, y_train)</span>:</span> </div><div class="line">    tuned_params = [&#123;<span class="string">'objective'</span>: [<span class="string">'binary:logistic'</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.05</span>], </div><div class="line">                     <span class="string">'n_estimators'</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>], <span class="string">'max_depth'</span>:[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;]</div><div class="line">    begin_t = time.time()</div><div class="line">    clf = GridSearchCV(xgb.XGBClassifier(seed=<span class="number">7</span>), tuned_params, scoring=<span class="string">'roc_auc'</span>)</div><div class="line">    clf.fit(X_train, y_train)</div><div class="line">    end_t = time.time()</div><div class="line">    <span class="keyword">print</span> <span class="string">'train time: '</span>,round(end_t-begin_t, <span class="number">3</span>), <span class="string">'s'</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'current best parameters of xgboost: '</span>,clf.best_params_</div><div class="line">    <span class="keyword">return</span> clf.best_estimator_</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bst_xgb = choose_xgb_model(train_full, ytrain)</div></pre></td></tr></table></figure>
<pre><code>train time:  48.141 s
current best parameters of xgboost:  {&apos;n_estimators&apos;: 150, &apos;objective&apos;: &apos;binary:logistic&apos;, &apos;learning_rate&apos;: 0.05, &apos;max_depth&apos;: 4}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_lgb_model</span><span class="params">(X_train, y_train)</span>:</span> </div><div class="line">    tuned_params = [&#123;<span class="string">'objective'</span>: [<span class="string">'binary'</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.05</span>], </div><div class="line">                     <span class="string">'n_estimators'</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>], <span class="string">'max_depth'</span>:[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;]</div><div class="line">    begin_t = time.time()</div><div class="line">    clf = GridSearchCV(lgb.LGBMClassifier(seed=<span class="number">7</span>), tuned_params, scoring=<span class="string">'roc_auc'</span>)</div><div class="line">    clf.fit(X_train, y_train)</div><div class="line">    end_t = time.time()</div><div class="line">    <span class="keyword">print</span> <span class="string">'train time: '</span>,round(end_t-begin_t, <span class="number">3</span>), <span class="string">'s'</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'current best parameters of lgb: '</span>,clf.best_params_</div><div class="line">    <span class="keyword">return</span> clf.best_estimator_</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bst_lgb = choose_lgb_model(train_full, ytrain)</div></pre></td></tr></table></figure>
<pre><code>train time:  12.543 s
current best parameters of lgb:  {&apos;n_estimators&apos;: 150, &apos;objective&apos;: &apos;binary&apos;, &apos;learning_rate&apos;: 0.05, &apos;max_depth&apos;: 4}
</code></pre><p>先使用stacking集成两个综合表现最佳的模型lgb和xgb，此处元分类器使用较为简单的LR模型来在已经训练好了并且经过参数选择的模型上进一步优化预测结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mlxtend.classifier <span class="keyword">import</span> StackingClassifier</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stacking_model</span><span class="params">(X_train, X_test, y_train)</span>:</span>    </div><div class="line">    lr = linear_model.LogisticRegression(random_state=<span class="number">7</span>)</div><div class="line">    sclf = StackingClassifier(classifiers=[bst_xgb, bst_lgb], use_probas=<span class="keyword">True</span>, average_probas=<span class="keyword">False</span>, </div><div class="line">                              meta_classifier=lr)</div><div class="line">    sclf.fit(X_train, y_train)</div><div class="line">    predictions = sclf.predict_proba(X_test)[:, <span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'stacking_1'</span>], mean_score[<span class="string">'stacking_1'</span>], mean_time[<span class="string">'stacking_1'</span>] = kfold_plot(train_full, ytrain, stacking_model)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_stacking.png" alt="stack_1"></p>
<pre><code>mean scores:  0.92157674772
mean model process time:  0.7022 s
</code></pre><p>可以看到相对之前的得分最高的模型lightgbm，将lightgbm与xgboost经过stacking集成并且使用lr作为元分类器得到的auc得分有轻微的提升，接下来考虑进一步加入另外的RandomForest和GBDT模型看看增加一点模型的差异性使用Stacking是不是会有所提升</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_forest_model</span><span class="params">(X_train, y_train)</span>:</span>    </div><div class="line">    tuned_params = [&#123;<span class="string">'n_estimators'</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>], <span class="string">'max_features'</span>: [<span class="number">8</span>, <span class="number">15</span>, <span class="number">30</span>], <span class="string">'max_depth'</span>:[<span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>]&#125;]</div><div class="line">    begin_t = time.time()</div><div class="line">    clf = GridSearchCV(RandomForestClassifier(random_state=<span class="number">7</span>), tuned_params, scoring=<span class="string">'roc_auc'</span>)</div><div class="line">    clf.fit(X_train, y_train)</div><div class="line">    end_t = time.time()</div><div class="line">    <span class="keyword">print</span> <span class="string">'train time: '</span>,round(end_t-begin_t, <span class="number">3</span>), <span class="string">'s'</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'current best parameters: '</span>,clf.best_params_</div><div class="line">    <span class="keyword">return</span> clf.best_estimator_</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bst_forest = choose_forest_model(train_full, ytrain)</div></pre></td></tr></table></figure>
<pre><code>train time:  42.201 s
current best parameters:  {&apos;max_features&apos;: 15, &apos;n_estimators&apos;: 150, &apos;max_depth&apos;: 8}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_gradient_model</span><span class="params">(X_train, y_train)</span>:</span>    </div><div class="line">    tuned_params = [&#123;<span class="string">'n_estimators'</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.03</span>, <span class="number">0.05</span>, <span class="number">0.07</span>], </div><div class="line">                     <span class="string">'min_samples_leaf'</span>: [<span class="number">8</span>, <span class="number">15</span>, <span class="number">30</span>], <span class="string">'max_depth'</span>:[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;]</div><div class="line">    begin_t = time.time()</div><div class="line">    clf = GridSearchCV(GradientBoostingClassifier(random_state=<span class="number">7</span>), tuned_params, scoring=<span class="string">'roc_auc'</span>)</div><div class="line">    clf.fit(X_train, y_train)</div><div class="line">    end_t = time.time()</div><div class="line">    <span class="keyword">print</span> <span class="string">'train time: '</span>,round(end_t-begin_t, <span class="number">3</span>), <span class="string">'s'</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'current best parameters: '</span>,clf.best_params_</div><div class="line">    <span class="keyword">return</span> clf.best_estimator_</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bst_gradient = choose_gradient_model(train_full, ytrain)</div></pre></td></tr></table></figure>
<pre><code>train time:  641.872 s
current best parameters:  {&apos;n_estimators&apos;: 100, &apos;learning_rate&apos;: 0.03, &apos;max_depth&apos;: 8, &apos;min_samples_leaf&apos;: 30}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stacking_model2</span><span class="params">(X_train, X_test, y_train)</span>:</span>    </div><div class="line">    lr = linear_model.LogisticRegression(random_state=<span class="number">7</span>)</div><div class="line">    sclf = StackingClassifier(classifiers=[bst_xgb, bst_forest, bst_gradient, bst_lgb], use_probas=<span class="keyword">True</span>, </div><div class="line">                              average_probas=<span class="keyword">False</span>, meta_classifier=lr)</div><div class="line">    sclf.fit(X_train, y_train)</div><div class="line">    predictions = sclf.predict_proba(X_test)[:, <span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'stacking_2'</span>], mean_score[<span class="string">'stacking_2'</span>], mean_time[<span class="string">'stacking_2'</span>] = kfold_plot(train_full, ytrain, stacking_model2)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_stacking2.png" alt="stack_2"></p>
<pre><code>mean scores:  0.92686550152
mean model process time:  4.0878 s
</code></pre><p>可以看到四个模型的聚合效果比用两个模型的stacking聚合效果要好不少，接下来尝试使用voting对四个模型进行聚合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">voting_model</span><span class="params">(X_train, X_test, y_train)</span>:</span>    </div><div class="line">    vclf = VotingClassifier(estimators=[(<span class="string">'xgb'</span>, bst_xgb), (<span class="string">'rf'</span>, bst_forest), (<span class="string">'gbm'</span>,bst_gradient),</div><div class="line">                                       (<span class="string">'lgb'</span>, bst_lgb)], voting=<span class="string">'soft'</span>, weights=[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</div><div class="line">    vclf.fit(X_train, y_train)</div><div class="line">    predictions = vclf.predict_proba(X_test)[:, <span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> predictions</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dct_scores[<span class="string">'voting'</span>], mean_score[<span class="string">'voting'</span>], mean_time[<span class="string">'voting'</span>] = kfold_plot(train_full, ytrain, voting_model)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/roc_voting.png" alt="voting"></p>
<pre><code>mean scores:  0.926889564336
mean model process time:  4.055 s
</code></pre><p>再次比较单模型与集成模型的得分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot_model_comp(<span class="string">'Model Performance'</span>, <span class="string">'roc-auc score'</span>, mean_score)</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot2/final_result.png" alt="result"></p>
<pre><code>The highest auc score is 0.926889564336 of model: voting
</code></pre><p>由上可以看到最终通过voting将四个模型进行聚合可以得到得分最高的模型，确定为最终用来预测的模型</p>
<h3 id="综合模型，对测试文件进行最终预测"><a href="#综合模型，对测试文件进行最终预测" class="headerlink" title="综合模型，对测试文件进行最终预测"></a>综合模型，对测试文件进行最终预测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># predict(train_full, test_full, y_train)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(X_train, X_test, y_train, test_ids)</span>:</span></div><div class="line">    predictions = voting_model(X_train, X_test, y_train)</div><div class="line"></div><div class="line">    sub = pd.read_csv(<span class="string">'sampleSubmission.csv'</span>)</div><div class="line">    result = pd.DataFrame()</div><div class="line">    result[<span class="string">'bidder_id'</span>] = test_ids</div><div class="line">    result[<span class="string">'outcome'</span>] = predictions</div><div class="line">    sub = sub.merge(result, on=<span class="string">'bidder_id'</span>, how=<span class="string">'left'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Fill missing values with mean</span></div><div class="line">    mean_pred = np.mean(predictions)</div><div class="line">    sub.fillna(mean_pred, inplace=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    sub.drop(<span class="string">'prediction'</span>, <span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    sub.to_csv(<span class="string">'result.csv'</span>, index=<span class="keyword">False</span>, header=[<span class="string">'bidder_id'</span>, <span class="string">'prediction'</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">submit(train_full, test_full, ytrain, test_ids)</div></pre></td></tr></table></figure>
<p>最终结果提交到kaggle上进行评分，得分如下<br><img src="/materials/img/HumenOrRobot2/point.png" alt="point"></p>
<p>以上就是整个完整的流程，当然还有很多模型可以尝试，很多聚合方法也可以使用，此外，特征工程部分还有很多空间可以挖掘，就留给大家去探索啦~</p>
<p>参考资料</p>
<ul>
<li>Chen, K. T., Pao, H. K. K., &amp; Chang, H. C. (2008, October). Game bot identification based on manifold learning. In Proceedings of the 7th ACM SIGCOMM Workshop on Network and System Support for Games (pp. 21-26). ACM.</li>
<li>Alayed, H., Frangoudes, F., &amp; Neuman, C. (2013, August). Behavioral-based cheating detection in online first person shooters using machine learning techniques. In Computational Intelligence in Games (CIG), 2013 IEEE Conference on (pp. 1-8). IEEE.</li>
<li><a href="https://www.kaggle.com/c/facebook-recruiting-iv-human-or-bot/data" target="_blank" rel="external">https://www.kaggle.com/c/facebook-recruiting-iv-human-or-bot/data</a></li>
<li><a href="http://stats.stackexchange.com/a/132832/152084" target="_blank" rel="external">http://stats.stackexchange.com/a/132832/152084</a></li>
<li><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="external">https://en.wikipedia.org/wiki/Receiver_operating_characteristic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Random_forest" target="_blank" rel="external">https://en.wikipedia.org/wiki/Random_forest</a></li>
<li><a href="https://en.wikipedia.org/wiki/Gradient_boosting" target="_blank" rel="external">https://en.wikipedia.org/wiki/Gradient_boosting</a></li>
<li><a href="https://xgboost.readthedocs.io/en/latest//parameter.html#parameters-for-tree-booster" target="_blank" rel="external">https://xgboost.readthedocs.io/en/latest//parameter.html#parameters-for-tree-booster</a></li>
<li><a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">https://github.com/Microsoft/LightGBM</a></li>
<li><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="external">https://en.wikipedia.org/wiki/Receiver_operating_characteristic</a></li>
<li><a href="http://stackoverflow.com/questions/29530232/python-pandas-check-if-any-value-is-nan-in-dataframe" target="_blank" rel="external">http://stackoverflow.com/questions/29530232/python-pandas-check-if-any-value-is-nan-in-dataframe</a></li>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/missing_data.html" target="_blank" rel="external">http://pandas.pydata.org/pandas-docs/stable/missing_data.html</a></li>
<li><a href="http://stackoverflow.com/a/18272653/6653189" target="_blank" rel="external">http://stackoverflow.com/a/18272653/6653189</a></li>
<li><a href="http://www.cnblogs.com/jasonfreak/p/5720137.html" target="_blank" rel="external">http://www.cnblogs.com/jasonfreak/p/5720137.html</a> </li>
<li><a href="https://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="external">kaggle ensembling guide</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Kaggle </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用机器学习识别出拍卖场中作弊的机器人用户]]></title>
      <url>/2017/05/29/HumenOrRobot/</url>
      <content type="html"><![CDATA[<p><em>原创文章，首发于<a href="https://segmentfault.com/a/1190000009101175" target="_blank" rel="external">SegmentFault</a></em></p>
<p>本项目为kaggle上Facebook举行的一次比赛，地址见数据来源，完整代码见我的<a href="https://github.com/LancelotHolmes/HumanOrRobot" target="_blank" rel="external">github</a>,欢迎来玩~</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>数据探索——Data_Exploration.ipynb</li>
<li>数据预处理&amp;特征工程——Feature_Engineering.ipynb &amp; Feature_Engineering2.ipynb</li>
<li>模型设计及评测——Model_Design.ipynb</li>
</ul>
<a id="more"></a>
<h2 id="项目数据来源"><a href="#项目数据来源" class="headerlink" title="项目数据来源"></a>项目数据来源</h2><ul>
<li><a href="https://www.kaggle.com/c/facebook-recruiting-iv-human-or-bot/data" target="_blank" rel="external">kaggle</a><h2 id="项目所需额外工具包"><a href="#项目所需额外工具包" class="headerlink" title="项目所需额外工具包"></a>项目所需额外工具包</h2></li>
<li><a href="http://www.numpy.org/" target="_blank" rel="external">numpy</a></li>
<li><a href="http://pandas.pydata.org/" target="_blank" rel="external">pandas</a></li>
<li><a href="https://matplotlib.org/index.html" target="_blank" rel="external">matplotlib</a></li>
<li><a href="http://scikit-learn.org/stable/" target="_blank" rel="external">sklearn</a></li>
<li><a href="https://xgboost.readthedocs.io/en/latest//parameter.html#parameters-for-tree-booster" target="_blank" rel="external">xgboost</a></li>
<li><a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">lightgbm</a></li>
<li><a href="https://github.com/rasbt/mlxtend" target="_blank" rel="external">mlxtend</a>: 含有聚和算法Stacking<br>项目整体运行时间预估为60min左右，在Ubuntu系统，8G内存，运行结果见所提交的jupyter notebook文件</li>
</ul>
<hr>
<p>由于文章内容过长，所以分为两篇文章，总共包含四个部分</p>
<ul>
<li>数据探索</li>
<li>数据预处理及特征工程</li>
<li>模型设计</li>
<li>评估及总结</li>
</ul>
<h2 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df_bids = pd.read_csv(<span class="string">'bids.csv'</span>, low_memory=<span class="keyword">False</span>)</div><div class="line">df_train = pd.read_csv(<span class="string">'train.csv'</span>)</div><div class="line">df_test = pd.read_csv(<span class="string">'test.csv'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df_bids.head(<span class="number">3</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>bid_id</th>
<th>bidder_id</th>
<th>auction</th>
<th>merchandise</th>
<th>device</th>
<th>time</th>
<th>country</th>
<th>ip</th>
<th>url</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8dac2b259fd1c6d1120e519fb1ac14fbqvax8</td>
<td>ewmzr</td>
<td>jewelry</td>
<td>phone0</td>
<td>9759243157894736</td>
<td>us</td>
<td>69.166.231.58</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>1</td>
<td>668d393e858e8126275433046bbd35c6tywop</td>
<td>aeqok</td>
<td>furniture</td>
<td>phone1</td>
<td>9759243157894736</td>
<td>in</td>
<td>50.201.125.84</td>
<td>jmqlhflrzwuay9c</td>
</tr>
<tr>
<td>2</td>
<td>aa5f360084278b35d746fa6af3a7a1a5ra3xe</td>
<td>wa00e</td>
<td>home goods</td>
<td>phone2</td>
<td>9759243157894736</td>
<td>py</td>
<td>112.54.208.157</td>
<td>vasstdc27m7nks3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df_train.head(<span class="number">3</span>)</div><div class="line"><span class="comment"># df_train.dtypes</span></div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>bidder_id</th>
<th>payment_account</th>
<th>address</th>
<th>outcome</th>
</tr>
</thead>
<tbody>
<tr>
<td>91a3c57b13234af24875c56fb7e2b2f4rb56a</td>
<td>a3d2de7675556553a5f08e4c88d2c228754av</td>
<td>a3d2de7675556553a5f08e4c88d2c228vt0u4</td>
<td>0.0</td>
</tr>
<tr>
<td>624f258b49e77713fc34034560f93fb3hu3jo</td>
<td>a3d2de7675556553a5f08e4c88d2c228v1sga</td>
<td>ae87054e5a97a8f840a3991d12611fdcrfbq3</td>
<td>0.0</td>
</tr>
<tr>
<td>1c5f4fc669099bfbfac515cd26997bd12ruaj</td>
<td>a3d2de7675556553a5f08e4c88d2c2280cybl</td>
<td>92520288b50f03907041887884ba49c0cl0pd</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<h3 id="异常数据检测"><a href="#异常数据检测" class="headerlink" title="异常数据检测"></a>异常数据检测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看各表格中是否存在空值</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Is there any missing value in bids?'</span>,df_bids.isnull().any().any()</div><div class="line"><span class="keyword">print</span> <span class="string">'Is there any missing value in train?'</span>,df_train.isnull().any().any()</div><div class="line"><span class="keyword">print</span> <span class="string">'Is there any missing value in test?'</span>,df_test.isnull().any().any()</div></pre></td></tr></table></figure>
<pre><code>Is there any missing value in bids? True
Is there any missing value in train? False
Is there any missing value in test? False
</code></pre><p>整个对三个数据集进行空值判断，发现用户数据训练集和测试集均无缺失数据，而在竞标行为数据集中存在缺失值的情况，下面便针对bids数据进一步寻找缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nan_rows = df_bids[df_bids.isnull().T.any().T]</span></div><div class="line"><span class="comment"># print nan_rows</span></div><div class="line">pd.isnull(df_bids).any()</div></pre></td></tr></table></figure>
<pre><code>bid_id         False
bidder_id      False
auction        False
merchandise    False
device         False
time           False
country         True
ip             False
url            False
dtype: bool
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">missing_country = df_bids[<span class="string">'country'</span>].isnull().sum().sum()</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of missing country: '</span>, missing_country</div><div class="line">normal_country = df_bids[<span class="string">'country'</span>].notnull().sum().sum()</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of normal country: '</span>, normal_country</div></pre></td></tr></table></figure>
<pre><code>No. of missing country:  8859
No. of normal country:  7647475
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">labels = [<span class="string">'unknown'</span>, <span class="string">'normal'</span>]</div><div class="line">sizes = [missing_country, normal_country]</div><div class="line">explode = (<span class="number">0.1</span>, <span class="number">0</span>)</div><div class="line">fig1, ax1 = plt.subplots()</div><div class="line">ax1.pie(sizes, explode=explode, labels=labels, autopct=<span class="string">'%1.1f%%'</span>, shadow=<span class="keyword">True</span>, startangle=<span class="number">90</span>)</div><div class="line">ax1.axis(<span class="string">'equal'</span>)</div><div class="line">plt.title(<span class="string">'Distribution of missing countries vs. normal countries'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot/null.png" alt="empty value"></p>
<p>综合上述的分析可以发现，在竞标行为用户的<code>country</code>一栏属性中存在很少一部分用户行为是没有<code>country</code>记录的，在预处理部分可以针对这部分缺失数据进行填充操作，有两种思路：</p>
<ul>
<li>针对原始行为数据按照用户分组后，看看每个对应的用户竞标时经常所位于的国家信息，对缺失值填充常驻国家</li>
<li>针对原始行为数据按照用户分组后，按时间顺序对每组用户中的缺失值前向或后向填充相邻的国家信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看各个数据的记录数</span></div><div class="line"><span class="comment"># 看看数据的id是否是唯一标识</span></div><div class="line"><span class="keyword">print</span> df_bids.shape[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> len(df_bids[<span class="string">'bid_id'</span>].unique())</div><div class="line"><span class="keyword">print</span> df_train.shape[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> len(df_train[<span class="string">'bidder_id'</span>].unique())</div><div class="line"><span class="keyword">print</span> df_test.shape[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> len(df_test[<span class="string">'bidder_id'</span>].unique())</div></pre></td></tr></table></figure>
<pre><code>7656334
7656334
2013
2013
4700
4700
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 简单统计各项基本特征（类别特征）的数目（除去时间）</span></div><div class="line"><span class="keyword">print</span> <span class="string">'total bidder in bids: '</span>, len(df_bids[<span class="string">'bidder_id'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total auction in bids: '</span>, len(df_bids[<span class="string">'auction'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total merchandise in bids: '</span>, len(df_bids[<span class="string">'merchandise'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total device in bids: '</span>, len(df_bids[<span class="string">'device'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total country in bids: '</span>, len(df_bids[<span class="string">'country'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total ip in bids: '</span>, len(df_bids[<span class="string">'ip'</span>].unique())</div><div class="line"><span class="keyword">print</span> <span class="string">'total url in bids: '</span>, len(df_bids[<span class="string">'url'</span>].unique())</div></pre></td></tr></table></figure>
<pre><code>total bidder in bids:  6614
total auction in bids:  15051
total merchandise in bids:  10
total device in bids:  7351
total country in bids:  200
total ip in bids:  2303991
total url in bids:  1786351
</code></pre><p>由上述基本特征可以看到：</p>
<ul>
<li>竞标行为中的用户总数少于训练集+测试集的用户数，也就是说并不是一一对应的，接下来验证下竞标行为数据中的用户是否完全来自训练集和测试集</li>
<li>商品类别和国家的种类相对其他特征较少，可以作为天然的类别特征提取出来进行处理，而其余的特征可能更多的进行计数统计</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lst_all_users = (df_train[<span class="string">'bidder_id'</span>].unique()).tolist() + (df_test[<span class="string">'bidder_id'</span>].unique()).tolist()</div><div class="line"><span class="keyword">print</span> <span class="string">'total bidders of train and test set'</span>,len(lst_all_users)</div><div class="line">lst_bidder = (df_bids[<span class="string">'bidder_id'</span>].unique()).tolist()</div><div class="line"><span class="keyword">print</span> <span class="string">'total bidders in bids set'</span>,len(lst_bidder)</div><div class="line"><span class="keyword">print</span> <span class="string">'Is bidders in bids are all from train+test set? '</span>,set(lst_bidder).issubset(set(lst_all_users))</div></pre></td></tr></table></figure>
<pre><code>total bidders of train and test set 6713
total bidders in bids set 6614
Is bidders in bids are all from train+test set?  True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lst_nobids = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst_all_users <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> lst_bidder]</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of bidders never bid: '</span>,len(lst_nobids)</div><div class="line">lst_nobids_train = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst_nobids <span class="keyword">if</span> i <span class="keyword">in</span> (df_train[<span class="string">'bidder_id'</span>].unique()).tolist()]</div><div class="line">lst_nobids_test = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst_nobids <span class="keyword">if</span> i <span class="keyword">in</span> (df_test[<span class="string">'bidder_id'</span>].unique()).tolist()]</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of bidders never bid in train set: '</span>,len(lst_nobids_train)</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of bidders never bid in test set: '</span>,len(lst_nobids_test)</div></pre></td></tr></table></figure>
<pre><code>No. of bidders never bid:  99
No. of bidders never bid in train set:  29
No. of bidders never bid in test set:  70
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">data_source = [<span class="string">'train'</span>, <span class="string">'test'</span>]</div><div class="line">y_pos = np.arange(len(data_source))</div><div class="line">num_never_bids = [len(lst_nobids_train), len(lst_nobids_test)]</div><div class="line">plt.bar(y_pos, num_never_bids, align=<span class="string">'center'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">plt.xticks(y_pos, data_source)</div><div class="line">plt.ylabel(<span class="string">'bidders no bids'</span>)</div><div class="line">plt.title(<span class="string">'Source of no bids bidders'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot/no_bidders.png" alt="source of no bid bidders"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> df_train[(df_train[<span class="string">'bidder_id'</span>].isin(lst_nobids_train)) &amp; (df_train[<span class="string">'outcome'</span>]==<span class="number">1.0</span>)]</div></pre></td></tr></table></figure>
<pre><code>Empty DataFrame
Columns: [bidder_id, payment_account, address, outcome]
Index: []
</code></pre><p>由上述计算可知存在99个竞标者无竞标记录，其中29位来自训练集，70位来自测试集，而且这29位来自训练集的竞标者未被标记为机器人用户，所以可以针对测试集中的这70位用户后续标记为人类或者取平均值处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># check the partition of bots in train</span></div><div class="line"><span class="keyword">print</span> (df_train[df_train[<span class="string">'outcome'</span>] == <span class="number">1</span>].shape[<span class="number">0</span>]*<span class="number">1.0</span>) / df_train.shape[<span class="number">0</span>] * <span class="number">100</span>,<span class="string">'%'</span></div></pre></td></tr></table></figure>
<pre><code>5.11674118231 %
</code></pre><p>训练集中的标记为机器人的用户占所有用户数目约5%</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df_train.groupby(<span class="string">'outcome'</span>).size().plot(labels=[<span class="string">'Human'</span>, <span class="string">'Robot'</span>], kind=<span class="string">'pie'</span>, autopct=<span class="string">'%.2f'</span>, figsize=(<span class="number">4</span>, <span class="number">4</span>), </div><div class="line">                                        title=<span class="string">'Distribution of Human vs. Robots'</span>, legend=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f477135c5d0&gt;
</code></pre><p><img src="/materials/img/HumenOrRobot/pos_neg.png" alt="正负例比较"></p>
<p>由上述训练集中的正负例分布可以看到本数据集正负例比例失衡，所以后续考虑使用AUC（不受正负例比例影响）作为评价指标，此外尽量采用Gradient Boosting族模型来进行训练</p>
<h2 id="数据预处理与特征工程"><a href="#数据预处理与特征工程" class="headerlink" title="数据预处理与特征工程"></a>数据预处理与特征工程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> pickle</div><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bids = pd.read_csv(<span class="string">'bids.csv'</span>)</div><div class="line">train = pd.read_csv(<span class="string">'train.csv'</span>)</div><div class="line">test = pd.read_csv(<span class="string">'test.csv'</span>)</div></pre></td></tr></table></figure>
<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>针对前面数据探索部分所发现的竞标行为数据中存在的国家属性缺失问题，考虑使用针对原始行为数据按照用户分组后，按时间顺序对每组用户中的缺失值前向或后向填充相邻的国家信息的方法来进行缺失值的填充处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display(bids.head(<span class="number">3</span>))</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>bid_id</th>
<th>bidder_id</th>
<th>auction</th>
<th>merchandise</th>
<th>device</th>
<th>time</th>
<th>country</th>
<th>ip</th>
<th>url</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8dac2b259fd1c6d1120e519fb1ac14fbqvax8</td>
<td>ewmzr</td>
<td>jewelry</td>
<td>phone0</td>
<td>9759243157894736</td>
<td>us</td>
<td>69.166.231.58</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>1</td>
<td>668d393e858e8126275433046bbd35c6tywop</td>
<td>aeqok</td>
<td>furniture</td>
<td>phone1</td>
<td>9759243157894736</td>
<td>in</td>
<td>50.201.125.84</td>
<td>jmqlhflrzwuay9c</td>
</tr>
<tr>
<td>2</td>
<td>aa5f360084278b35d746fa6af3a7a1a5ra3xe</td>
<td>wa00e</td>
<td>home goods</td>
<td>phone2</td>
<td>9759243157894736</td>
<td>py</td>
<td>112.54.208.157</td>
<td>vasstdc27m7nks3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># pd.algos.is_monotonic_int64(bids.time.values, True)[0]</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Is the time monotonically non-decreasing? '</span>, pd.Index(bids[<span class="string">'time'</span>]).is_monotonic</div></pre></td></tr></table></figure>
<pre><code>Is the time monotonically non-decreasing?  False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bidder_group = bids.sort_values(['bidder_id', 'time']).groupby('bidder_id')</span></div><div class="line">bids[<span class="string">'country'</span>] = bids.sort_values([<span class="string">'bidder_id'</span>, <span class="string">'time'</span>]).groupby(<span class="string">'bidder_id'</span>)[<span class="string">'country'</span>].ffill()</div><div class="line">bids[<span class="string">'country'</span>] = bids.sort_values([<span class="string">'bidder_id'</span>, <span class="string">'time'</span>]).groupby(<span class="string">'bidder_id'</span>)[<span class="string">'country'</span>].bfill()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display(bids.head(<span class="number">3</span>))</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>bid_id</th>
<th>bidder_id</th>
<th>auction</th>
<th>merchandise</th>
<th>device</th>
<th>time</th>
<th>country</th>
<th>ip</th>
<th>url</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8dac2b259fd1c6d1120e519fb1ac14fbqvax8</td>
<td>ewmzr</td>
<td>jewelry</td>
<td>phone0</td>
<td>9759243157894736</td>
<td>us</td>
<td>69.166.231.58</td>
<td>vasstdc27m7nks3</td>
</tr>
<tr>
<td>1</td>
<td>668d393e858e8126275433046bbd35c6tywop</td>
<td>aeqok</td>
<td>furniture</td>
<td>phone1</td>
<td>9759243157894736</td>
<td>in</td>
<td>50.201.125.84</td>
<td>jmqlhflrzwuay9c</td>
</tr>
<tr>
<td>2</td>
<td>aa5f360084278b35d746fa6af3a7a1a5ra3xe</td>
<td>wa00e</td>
<td>home goods</td>
<td>phone2</td>
<td>9759243157894736</td>
<td>py</td>
<td>112.54.208.157</td>
<td>vasstdc27m7nks3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Is there any missing value in bids?'</span>,bids.isnull().any().any()</div><div class="line"><span class="comment"># pickle.dump(bids, open('bids.pkl', 'w'))</span></div></pre></td></tr></table></figure>
<pre><code>Is there any missing value in bids? True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">missing_country = bids[<span class="string">'country'</span>].isnull().sum().sum()</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of missing country: '</span>, missing_country</div><div class="line">normal_country = bids[<span class="string">'country'</span>].notnull().sum().sum()</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of normal country: '</span>, normal_country</div></pre></td></tr></table></figure>
<pre><code>No. of missing country:  5
No. of normal country:  7656329
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nan_rows = bids[bids.isnull().T.any().T]</div><div class="line"><span class="keyword">print</span> nan_rows</div></pre></td></tr></table></figure>
<pre><code>          bid_id                              bidder_id auction  \
1351177  1351177  f3ab8c9ecc0d021ebc81e89f20c8267bn812w   jefix   
2754184  2754184  88ef9cfdbec4c9e33f6c2e0b512e7a01dp2p2   cc5fs   
2836631  2836631  29b8af2fea3881ef61911612372dac41vczqv   jqx39   
3125892  3125892  df20f216cbb0b0df5a7b2e94b16a7853iyw9g   jqx39   
5153748  5153748  5e05ec450e2dd64d7996a08bbbca4f126nzzk   jqx39   

              merchandise    device              time country  \
1351177  office equipment   phone84  9767200789473684     NaN   
2754184            mobile  phone150  9633363947368421     NaN   
2836631           jewelry   phone72  9634034894736842     NaN   
3125892   books and music  phone106  9635755105263157     NaN   
5153748            mobile  phone267  9645270210526315     NaN   

                      ip              url  
1351177   80.211.119.111  g9pgdfci3yseml5  
2754184     20.67.240.88  ctivbfq55rktail  
2836631  149.210.107.205  vasstdc27m7nks3  
3125892      26.23.62.59  ac9xlqtfg0cx5c5  
5153748     145.7.194.40  0em0vg1f0zuxonw  
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># print bids[bids['bid_id']==1351177]</span></div><div class="line">nan_bidder = nan_rows[<span class="string">'bidder_id'</span>].values.tolist()</div><div class="line"><span class="comment"># print nan_bidder</span></div><div class="line"><span class="keyword">print</span> bids[bids[<span class="string">'bidder_id'</span>].isin(nan_bidder)]</div></pre></td></tr></table></figure>
<pre><code>          bid_id                              bidder_id auction  \
1351177  1351177  f3ab8c9ecc0d021ebc81e89f20c8267bn812w   jefix   
2754184  2754184  88ef9cfdbec4c9e33f6c2e0b512e7a01dp2p2   cc5fs   
2836631  2836631  29b8af2fea3881ef61911612372dac41vczqv   jqx39   
3125892  3125892  df20f216cbb0b0df5a7b2e94b16a7853iyw9g   jqx39   
5153748  5153748  5e05ec450e2dd64d7996a08bbbca4f126nzzk   jqx39   

              merchandise    device              time country  \
1351177  office equipment   phone84  9767200789473684     NaN   
2754184            mobile  phone150  9633363947368421     NaN   
2836631           jewelry   phone72  9634034894736842     NaN   
3125892   books and music  phone106  9635755105263157     NaN   
5153748            mobile  phone267  9645270210526315     NaN   

                      ip              url  
1351177   80.211.119.111  g9pgdfci3yseml5  
2754184     20.67.240.88  ctivbfq55rktail  
2836631  149.210.107.205  vasstdc27m7nks3  
3125892      26.23.62.59  ac9xlqtfg0cx5c5  
5153748     145.7.194.40  0em0vg1f0zuxonw  
</code></pre><p>在对整体数据的部分用户缺失国家的按照各个用户分组后在时间上前向和后向填充后，仍然存在5个用户缺失了国家信息，结果发现这5个用户是仅有一次竞标行为，下面看看这5个用户还有什么特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lst_nan_train = [i <span class="keyword">for</span> i <span class="keyword">in</span> nan_bidder <span class="keyword">if</span> i <span class="keyword">in</span> (train[<span class="string">'bidder_id'</span>].unique()).tolist()]</div><div class="line">lst_nan_test = [i <span class="keyword">for</span> i <span class="keyword">in</span> nan_bidder <span class="keyword">if</span> i <span class="keyword">in</span> (test[<span class="string">'bidder_id'</span>].unique()).tolist()]</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of bidders 1 bid in train set: '</span>,len(lst_nan_train)</div><div class="line"><span class="keyword">print</span> <span class="string">'No. of bidders 1 bid in test set: '</span>,len(lst_nan_test)</div></pre></td></tr></table></figure>
<pre><code>No. of bidders 1 bid in train set:  1
No. of bidders 1 bid in test set:  4
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> train[train[<span class="string">'bidder_id'</span>]==lst_nan_train[<span class="number">0</span>]][<span class="string">'outcome'</span>]</div></pre></td></tr></table></figure>
<pre><code>546    0.0
Name: outcome, dtype: float64
</code></pre><p>由于这5个用户仅有一次竞标行为，而且其中1个用户来自训练集，4个来自测试集，由训练集用户的标记为人类，加上行为数太少，所以考虑对这5个用户的竞标行为数据予以舍弃，特别对测试集的4个用户后续操作类似之前对无竞标行为的用户，预测值填充最终模型的平均预测值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bid_to_drop = nan_rows.index.values.tolist()</div><div class="line"><span class="comment"># print bid_to_drop</span></div><div class="line">bids.drop(bids.index[bid_to_drop], inplace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Is there any missing value in bids?'</span>,bids.isnull().any().any()</div><div class="line">pickle.dump(bids, open(<span class="string">'bids.pkl'</span>, <span class="string">'w'</span>))</div></pre></td></tr></table></figure>
<pre><code>Is there any missing value in bids? False
</code></pre><h3 id="统计基本的计数特征"><a href="#统计基本的计数特征" class="headerlink" title="统计基本的计数特征"></a>统计基本的计数特征</h3><p>根据前面的数据探索，由于数据集大部分由类别数据或者离散型数据构成，所以首先针对竞标行为数据按照竞标者分组统计其各项属性的数目，比如使用设备种类，参与竞标涉及国家，ip种类等等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># group by bidder to do some statistics</span></div><div class="line">bidders = bids.groupby(<span class="string">'bidder_id'</span>)</div><div class="line"><span class="comment"># pickle.dump(bids, open('bidders.pkl', 'w'))</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># print bidders['device'].count()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_count</span><span class="params">(group)</span>:</span></div><div class="line">    dct_cnt = &#123;&#125;</div><div class="line">    dct_cnt[<span class="string">'devices_c'</span>] = group[<span class="string">'device'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    dct_cnt[<span class="string">'countries_c'</span>] = group[<span class="string">'country'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    dct_cnt[<span class="string">'ip_c'</span>] = group[<span class="string">'ip'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    dct_cnt[<span class="string">'url_c'</span>] = group[<span class="string">'url'</span>].unique().shape[<span class="number">0</span>]    </div><div class="line">    dct_cnt[<span class="string">'auction_c'</span>] = group[<span class="string">'auction'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    dct_cnt[<span class="string">'auc_mean'</span>] = np.mean(group[<span class="string">'auction'</span>].value_counts())    <span class="comment"># bids_c/auction_c</span></div><div class="line"><span class="comment">#     dct_cnt['dev_mean'] = np.mean(group['device'].value_counts())    # bids_c/devices_c</span></div><div class="line">    dct_cnt[<span class="string">'merch_c'</span>] = group[<span class="string">'merchandise'</span>].unique().shape[<span class="number">0</span>]</div><div class="line">    dct_cnt[<span class="string">'bids_c'</span>] = group.shape[<span class="number">0</span>]</div><div class="line">    dct_cnt = pd.Series(dct_cnt)</div><div class="line">    <span class="keyword">return</span> dct_cnt</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnt_bidder = bidders.apply(feature_count)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display(cnt_bidder.describe())</div><div class="line"><span class="comment"># cnt_bidder.to_csv('cnt_bidder.csv')</span></div><div class="line"><span class="comment"># print cnt_bidder[cnt_bidder['merch_c']==2]</span></div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th>auc_mean</th>
<th>auction_c</th>
<th>bids_c</th>
<th>countries_c</th>
<th>devices_c</th>
<th>ip_c</th>
<th>merch_c</th>
<th>url_c</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
<td>6609.000000</td>
</tr>
<tr>
<td>mean</td>
<td>6.593493</td>
<td>57.850810</td>
<td>1158.470117</td>
<td>12.733848</td>
<td>73.492359</td>
<td>544.507187</td>
<td>1.000151</td>
<td>290.964140</td>
</tr>
<tr>
<td>std</td>
<td>30.009242</td>
<td>131.814053</td>
<td>9596.595169</td>
<td>22.556570</td>
<td>172.171106</td>
<td>3370.730666</td>
<td>0.012301</td>
<td>2225.912425</td>
</tr>
<tr>
<td>min</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
</tr>
<tr>
<td>25%</td>
<td>1.000000</td>
<td>2.000000</td>
<td>3.000000</td>
<td>1.000000</td>
<td>2.000000</td>
<td>2.000000</td>
<td>1.000000</td>
<td>1.000000</td>
</tr>
<tr>
<td>50%</td>
<td>1.677419</td>
<td>10.000000</td>
<td>18.000000</td>
<td>3.000000</td>
<td>8.000000</td>
<td>12.000000</td>
<td>1.000000</td>
<td>5.000000</td>
</tr>
<tr>
<td>75%</td>
<td>4.142857</td>
<td>47.000000</td>
<td>187.000000</td>
<td>12.000000</td>
<td>57.000000</td>
<td>111.000000</td>
<td>1.000000</td>
<td>36.000000</td>
</tr>
<tr>
<td>max</td>
<td>1327.366667</td>
<td>1726.000000</td>
<td>515033.000000</td>
<td>178.000000</td>
<td>2618.000000</td>
<td>111918.000000</td>
<td>2.000000</td>
<td>81376.000000</td>
</tr>
</tbody>
</table>
<h3 id="特征相关性"><a href="#特征相关性" class="headerlink" title="特征相关性"></a>特征相关性</h3><p>在对竞标行为数据按照用户分组后，对数据集中的每一个产品特征构建一个散布矩阵（scatter matrix），来看看各特征之间的相关性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 对于数据中的每一对特征构造一个散布矩阵</span></div><div class="line">pd.scatter_matrix(cnt_bidder, alpha = <span class="number">0.3</span>, figsize = (<span class="number">16</span>,<span class="number">10</span>), diagonal = <span class="string">'kde'</span>);</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot/scatter_origin.png" alt="scatter matrix"></p>
<p>在针对竞标行为数据按照竞标用户进行分组基本统计后由上表可以看出，此时并未考虑时间戳的情形下，有以下基本结论：</p>
<ul>
<li>由各项统计的最大值与中位值，75%值的比较可以看到除了商品类别一项，其他的几项多少都存在一些异常数值，或许可以作为异常行为进行观察</li>
<li>各特征的倾斜度很大，考虑对特征进行取对数的操作，并再次输出散布矩阵看看相关性。</li>
<li>商品类别计数这一特征的方差很小，而且从中位数乃至75%的统计来看，大多数用户仅对同一类别商品进行拍卖，而且因为前面数据探索部分发现商品类别本身适合作为类别数据，所以考虑分多个类别进行单独统计，而在计数特征中舍弃该特征。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnt_bidder.drop(<span class="string">'merch_c'</span>, axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnt_bidder = np.log(cnt_bidder)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.scatter_matrix(cnt_bidder, alpha = <span class="number">0.3</span>, figsize = (<span class="number">16</span>,<span class="number">10</span>), diagonal = <span class="string">'kde'</span>);</div></pre></td></tr></table></figure>
<p><img src="/materials/img/HumenOrRobot/scatter_new.png" alt="scatter matrix(log)"></p>
<p>由上面的散布矩阵可以看到，个行为特征之间并没有表现出很强的相关性，虽然其中的ip计数和竞标计数，设备计数在进行对数操作处理之后表现出轻微的正相关性，但是由于是在做了对数操作之后才体现，而且从图中可以看到并非很强的相关性，所以保留这三个特征。</p>
<p>针对前述的异常行为，先从原train数据集中的机器人、人类中分别挑选几个样本进行追踪观察他们在按照bidders分组后的统计结果，对比看看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnt_bidder.to_csv(<span class="string">'cnt_bidder.csv'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># trace samples,first 2 bots, last 2 humen</span></div><div class="line">indices = [<span class="string">'9434778d2268f1fa2a8ede48c0cd05c097zey'</span>,<span class="string">'aabc211b4cf4d29e4ac7e7e361371622pockb'</span>,</div><div class="line">           <span class="string">'d878560888b11447e73324a6e263fbd5iydo1'</span>,<span class="string">'91a3c57b13234af24875c56fb7e2b2f4rb56a'</span>]</div><div class="line"></div><div class="line"><span class="comment"># build a DataFrame for the choosed indices</span></div><div class="line">samples = pd.DataFrame(cnt_bidder.loc[indices], columns = cnt_bidder.keys()).reset_index(drop = <span class="keyword">True</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"Chosen samples of training dataset:(first 2 bots, last 2 humen)"</span></div><div class="line">display(samples)</div></pre></td></tr></table></figure>
<pre><code>Chosen samples of training dataset:(first 2 bots, last 2 humen)
</code></pre><table>
<thead>
<tr>
<th>bidder_type</th>
<th>auc_mean</th>
<th>auction_c</th>
<th>bids_c</th>
<th>countries_c</th>
<th>devices_c</th>
<th>ip_c</th>
<th>url_c</th>
</tr>
</thead>
<tbody>
<tr>
<td>robot1</td>
<td>3.190981</td>
<td>5.594711</td>
<td>8.785692</td>
<td>4.174387</td>
<td>6.011267</td>
<td>8.147578</td>
<td>7.557995</td>
</tr>
<tr>
<td>robot2</td>
<td>2.780432</td>
<td>4.844187</td>
<td>7.624619</td>
<td>2.639057</td>
<td>3.178054</td>
<td>5.880533</td>
<td>1.609438</td>
</tr>
<tr>
<td>human1</td>
<td>0.287682</td>
<td>1.098612</td>
<td>1.386294</td>
<td>1.098612</td>
<td>1.386294</td>
<td>1.386294</td>
<td>0.000000</td>
</tr>
<tr>
<td>human2</td>
<td>0.287682</td>
<td>2.890372</td>
<td>3.178054</td>
<td>1.791759</td>
<td>2.639057</td>
<td>2.995732</td>
<td>0.000000</td>
</tr>
</tbody>
</table>
<p>使用seaborn来对上面四个例子的热力图进行可视化，看看percentile的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"></div><div class="line"><span class="comment"># look at percentile ranks</span></div><div class="line">pcts = <span class="number">100.</span> * cnt_bidder.rank(axis=<span class="number">0</span>, pct=<span class="keyword">True</span>).loc[indices].round(decimals=<span class="number">3</span>)</div><div class="line"><span class="keyword">print</span> pcts</div><div class="line"></div><div class="line"><span class="comment"># visualize percentiles with heatmap</span></div><div class="line">sns.heatmap(pcts, yticklabels=[<span class="string">'robot 1'</span>, <span class="string">'robot 2'</span>, <span class="string">'human 1'</span>, <span class="string">'human 2'</span>], annot=<span class="keyword">True</span>, linewidth=<span class="number">.1</span>, vmax=<span class="number">99</span>, </div><div class="line">            fmt=<span class="string">'.1f'</span>, cmap=<span class="string">'YlGnBu'</span>)</div><div class="line">plt.title(<span class="string">'Percentile ranks of\nsamples\' feature statistics'</span>)</div><div class="line">plt.xticks(rotation=<span class="number">45</span>, ha=<span class="string">'center'</span>);</div></pre></td></tr></table></figure>
<pre><code>                                       auc_mean  auction_c  bids_c  \
bidder_id                                                            
9434778d2268f1fa2a8ede48c0cd05c097zey      94.9       94.6    97.0   
aabc211b4cf4d29e4ac7e7e361371622pockb      92.4       87.2    92.3   
d878560888b11447e73324a6e263fbd5iydo1      39.8       30.4    30.2   
91a3c57b13234af24875c56fb7e2b2f4rb56a      39.8       60.2    53.0   

                                       countries_c  devices_c  ip_c  url_c  
bidder_id                                                                   
9434778d2268f1fa2a8ede48c0cd05c097zey         95.4       95.6  96.7   97.4  
aabc211b4cf4d29e4ac7e7e361371622pockb         77.3       63.8  84.8   50.3  
d878560888b11447e73324a6e263fbd5iydo1         48.8       38.7  34.2   13.4  
91a3c57b13234af24875c56fb7e2b2f4rb56a         63.7       56.8  56.2   13.4  
</code></pre><p><img src="/materials/img/HumenOrRobot/hot_map.png" alt="hot map"></p>
<p>由上面的热力图对比可以看到，机器人的各项统计指标除去商品类别上的统计以外，均比人类用户要高，所以考虑据此设计基于基本统计指标规则的基准模型，其中最显著的特征差异应该是在<code>auc_mean</code>一项即用户在各个拍卖场的平均竞标次数，不妨先按照异常值处理的方法来找出上述基础统计中的异常情况</p>
<h3 id="设计朴素分类器"><a href="#设计朴素分类器" class="headerlink" title="设计朴素分类器"></a>设计朴素分类器</h3><p>由于最终目的是从竞标者中寻找到机器人用户，而根据常识，机器人用户的各项竞标行为的操作应该比人类要频繁许多，所以可以从异常值检验的角度来设计朴素分类器，根据之前针对不同用户统计的基本特征计数情况，可以先针对每一个特征找出其中的疑似异常用户列表，最后整合各个特征生成的用户列表，认为超过多个特征异常的用户为机器人用户。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># find the outliers for each feature</span></div><div class="line">lst_outlier = []</div><div class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> cnt_bidder.keys():</div><div class="line">    <span class="comment"># percentile  25th</span></div><div class="line">    Q1 = np.percentile(cnt_bidder[feature], <span class="number">25</span>)</div><div class="line">    <span class="comment"># percentile  75th</span></div><div class="line">    Q3 = np.percentile(cnt_bidder[feature], <span class="number">75</span>)</div><div class="line">    step = <span class="number">1.5</span> * (Q3 - Q1)    </div><div class="line">    <span class="comment"># show outliers</span></div><div class="line">    <span class="comment"># print "Data points considered outliers for the feature '&#123;&#125;':".format(feature)</span></div><div class="line">    display(cnt_bidder[~((cnt_bidder[feature] &gt;= Q1 - step) &amp; (cnt_bidder[feature] &lt;= Q3 + step))])</div><div class="line">    lst_outlier += cnt_bidder[~((cnt_bidder[feature] &gt;= Q1 - step) &amp; (cnt_bidder[feature] &lt;= Q3 + step))].index.values.tolist()</div></pre></td></tr></table></figure>
<p>再找到各种特征的所有可能作为‘异常值’的用户id之后，可以对其做一个基本统计，进一步找出其中超过某几个特征值均异常的用户，经过测试，考虑到原始train集合里bots用户不到5%，所以最终确定以至少存在1个特征值异常的用户作为异常用户的一个假设，由此与test集合里的用户进行判断，可以得到一个用户子集，将这部分用户判定为朴素分类器的作弊用户判定结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># print len(lst_outlier)</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line">freq_outlier = dict(Counter(lst_outlier))</div><div class="line">perhaps_outlier = [i <span class="keyword">for</span> i <span class="keyword">in</span> freq_outlier <span class="keyword">if</span> freq_outlier[i] &gt;= <span class="number">1</span>]</div><div class="line"><span class="keyword">print</span> len(perhaps_outlier)</div></pre></td></tr></table></figure>
<pre><code>214
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># basic_pred = test[test['bidder_id'].isin(perhaps_outlier)]['bidder_id'].tolist()</span></div><div class="line">train_pred = train[train[<span class="string">'bidder_id'</span>].isin(perhaps_outlier)][<span class="string">'bidder_id'</span>].tolist()</div><div class="line"><span class="keyword">print</span> len(train_pred)</div></pre></td></tr></table></figure>
<pre><code>76
</code></pre><h3 id="设计评价指标"><a href="#设计评价指标" class="headerlink" title="设计评价指标"></a>设计评价指标</h3><p>根据前面数据探索知本实验中的数据集的正负例比例约为19:1，有些失衡，所以考虑使用auc这种不受正负例比例影响的评价指标作为衡量标准，现针对所涉及的朴素分类器在原始训练集上的表现得到一个基准得分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line">y_true = train[<span class="string">'outcome'</span>]</div><div class="line">naive_pred = pd.DataFrame(columns=[<span class="string">'bidder_id'</span>, <span class="string">'prediction'</span>])</div><div class="line">naive_pred[<span class="string">'bidder_id'</span>] = train[<span class="string">'bidder_id'</span>]</div><div class="line">naive_pred[<span class="string">'prediction'</span>] = np.where(naive_pred[<span class="string">'bidder_id'</span>].isin(train_pred), <span class="number">1.0</span>, <span class="number">0.0</span>)</div><div class="line">basic_pred = naive_pred[<span class="string">'prediction'</span>]</div><div class="line"><span class="keyword">print</span> roc_auc_score(y_true, basic_pred)</div></pre></td></tr></table></figure>
<pre><code>0.54661464952
</code></pre><p>在经过上述对基本计数特征的统计之后，目前尚未针对非类别特征：时间戳进行处理，而在之前的数据探索过程中，针对商品类别和国家这两个类别属性，可以将原始的单一特征转换为多个特征分别统计，此外，在上述分析过程中，我们发现针对用户分组可以进一步对于拍卖场进行分组统计。</p>
<ul>
<li>对时间戳进行处理</li>
<li>针对商品类别、国家转换为多个类别分别进行统计</li>
<li>按照用户-拍卖场进行分组进一步统计</li>
</ul>
<h3 id="对时间戳进行处理"><a href="#对时间戳进行处理" class="headerlink" title="对时间戳进行处理"></a>对时间戳进行处理</h3><p>主要是分析各个竞标行为的时间间隔，即统计竞标行为表中在同一拍卖场的各个用户之间的竞标行为间隔</p>
<p>然后针对每个用户对其他用户的时间间隔计算</p>
<ul>
<li>时间间隔均值</li>
<li>时间间隔最大值</li>
<li>时间间隔最小值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_timediff</span><span class="params">()</span>:</span>    </div><div class="line">    bids_grouped = bids.groupby(<span class="string">'auction'</span>)</div><div class="line">    bds = defaultdict(list)</div><div class="line">    last_row = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> bids_auc <span class="keyword">in</span> bids_grouped:</div><div class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> bids_auc[<span class="number">1</span>].iterrows():</div><div class="line">            <span class="keyword">if</span> last_row <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                last_row = row</div><div class="line">                <span class="keyword">continue</span></div><div class="line"></div><div class="line">            time_difference = row[<span class="string">'time'</span>] - last_row[<span class="string">'time'</span>]</div><div class="line">            bds[row[<span class="string">'bidder_id'</span>]].append(time_difference)</div><div class="line">            last_row = row</div><div class="line"></div><div class="line">    df = []</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> bds.keys():</div><div class="line">        df.append(&#123;<span class="string">'bidder_id'</span>: key, <span class="string">'mean'</span>: np.mean(bds[key]),</div><div class="line">                   <span class="string">'min'</span>: np.min(bds[key]), <span class="string">'max'</span>: np.max(bds[key])&#125;)</div><div class="line"></div><div class="line">    pd.DataFrame(df).to_csv(<span class="string">'tdiff.csv'</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">generate_timediff()</div></pre></td></tr></table></figure>
<!-- 由于内容长度超过限制，后续内容请移步[使用机器学习识别出拍卖场中作弊的机器人用户(二)](../HumenOrRobot2) -->
<p>后续内容请移步<a href="/2017/05/29/HumenOrRobot2/" title="使用机器学习识别出拍卖场中作弊的机器人用户(二)">使用机器学习识别出拍卖场中作弊的机器人用户(二)</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ML </tag>
            
            <tag> Kaggle </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平坦世界]]></title>
      <url>/2017/05/29/%E4%B8%96%E7%95%8C%E6%98%AF%E5%B9%B3%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>这次给大家推荐一本书——“The world is flat”（《世界是平的》），刚刚看完了一遍，感觉这本书的视角很广阔，让我看到自己受限于地理或者意识因素所看不到的一些其实就实实在在发生在身边的变化，私以为，作为即将毕业的大学生而言，是很有必要一读的。</p>
<p>【这本书面世其实快10年了，但是书中所述的一些变化我们或经历过，或忽略掉了，所以即使放在现在读，也是很有前瞻性的。特别由于作者本身是记者，写作风格还是颇为轻松地，所以，读起来感觉像是跟着作者开着上帝视角实现了所谓“世界那么大，我想去看看”的成就一般。】</p>
<p>此书整体大概是由世界变平坦的种种例证、现象到作者所认为使世界变平坦的一些因素再到各个“成员”大至国家公司、小至每一个个体在这平坦世界里的角色和相互影响，最后是平坦世界所带来的或即将造成的可能负面影响和威胁来逐层叙述的。我想先就宏观角度简单记叙下书中的一些观点，然后谈一下书中所说而我也感觉到的身边的一些变化，最后就自己而言随意谈一下想法。</p>
<a id="more"></a>
<p>就宏观而言，书中让我印象最深的是全球化的重中体现，首先是全球合作的一些案例，这个曾经在《互联网时代》里也看到过，比如现在的波音飞机的组装以及各零件的制造是分散到世界各个国家各个地区去做的，然后又井然有序的由各个地方汇聚到一个点组装成型，书中还举得一个例子是沃尔玛的生产线，和前者类似，也是一种像分布式的结构，这种做法极大地提高了效率并降低了成本，而其中最让我目眩神迷的是这么个巨大的整体居然能够这么一致的展开协同工作；另外一点是关于离岸外包，这里就不得不提到一个国家是印度，或者说印度的城市班加罗尔，看了这本书我感觉像亲身去看一下，所谓外包，就是将本国家的一些相对而言中低端而要耗费大量人力的基础工作交给其他国家去做，这里你也许会想到所谓的”Made in China”，诚然，中国也是外包的一个很好的例子，换做以前我会觉得嗤之以鼻，感觉我们国家就老是像给美国之类的国家打工一样，其实，分析一下，就目前而言，这个是双赢的，美国那边自不用说，花一分美国工人的钱在中国或者印度雇佣到6~8个同样水平的技术工人，极大地降低了成本，而且这里面不得不说有个很有意思的东西是——时差，因为有些工作在美国的白天又美国人做，晚上就交给印度人（印度正在白天）做，极大地提升了效率，这个我在电影《贫民窟的百万富翁》里看到过的一个场景就是印度人通过远程监控摄像头替美国人监控停车场让我印象深刻，那么对于印度和中国这些国家呢，好处在哪？其一就是增多了工作岗位，就印度而言的话，由于现在印度培养了大量的理工学生，而毕业后以前只能去国外谋出路，否则在国内一般只能成为出租车司机，而经过外包，他们可以在本土就进行软件开发的工作，虽然工资不如美国人，但是相对于自己本身而言，他们的生活已经得到不小的提升了，另外，通过这种形式，印度和中国还可以学习一些国外的技术，甚至是抢占国外的市场，书中后面有个例子是中国生产的埃及传统的灯几乎快要垄断埃及的市场，因为在技术上有所突破，而且价格也低廉。</p>
<p>当然，以上只是从书中看到的知识，也许我以后还需要实地考察一番看看实际情况是否真如作者所述，不过，对于我们国家，我还是希望抱有乐观的态度去看他的发展，相信他会越变越好。</p>
<p>就身边的所见所闻而言，我印象比较深的是一个 距离 的问题，和书中作者一次下飞机乘出租车的经历一般，在乘车那段时间里，司机一直在通过蓝牙耳机聊天，车上开着导航，播放着电影，而作者在自己的笔记本上整理文章以及收发e-mail，用作者的话说，在那一个小时里他们同时做了很多事，却几乎没有交流，作者甚至猜想，也许司机正和远在另一个国度的父母通话呢。这大概就是目前发生在我们身边的一个尴尬境地了，一方面，技术的发展拉近了我们的距离，而另一面却又使我们的距离变得遥远，它拉近了我们和处在不同空间的亲人之间的距离，却又在此时此地的就在你眼前的我面前树起了一道屏障。我想起了高中语文老师发的一篇文章里对动车、高铁上的年轻人乘客们的描述，确确实实的感受到这一真切的现象，大家一上车就戴上耳机，或插入ipad，或插入iphone，而彼此之间却没有交流，这和绿皮火车上的情景完全不同，也是值得我们反思的一件事。</p>
<p>最后我想简单谈一下自己的一些想法。首先关于教育和竞争方面，这里还得扯下印度，书中说道，班加罗尔的接线员晚上为美国（白天）的乘客们进行咨询和失物找回工作，晚上还会自己学习一些知识，攻读一些学位什么的，顿时感到一种压迫感。从前经常听到政治老师说美国家长告诫自己的孩子说快吃饭，不然中国和印度的孩子就把你的饭给吃了或者快努力学习，中国或印度的孩子快把你的饭碗抢走了之类的。而现在是大家都站在几乎同一个平台上竞争，前面我们需要追赶美国，而同时，印度的青年们却也在旁虎视眈眈。而身处计算机专业这一日新月异，竞争更加残酷的环境下，我一面感到威胁，一面感到兴奋，兴奋的是，试想一下你即将站在一个大舞台上，和来自不同城市乃至不同国家的人角逐，而威胁在于，你们本身的水平是不一样的，就我而言，在我将要踏上这个舞台的那一天，我不仅会和同班同学竞争，稍远一点还有来自全国各大高校的强者，再远一点还有世界其他角落的高手出没，而要想不被碾成炮灰，或者说不被这一变平的趋势所冲倒的话，我就得不断地去吸收和学习新的技术、新的知识，还要进一步强化自己的全局意识，做到让自己所做的事无可替代，也就不会被”外包”掉。另外一点就是之前实习时听到负责人说现在的联系方式太多了，又是电话、又是微信、QQ的，反而造成了联系上的障碍，以前我们只有电话时一般就通过电话联系，而现在常常是不同人有不同的习惯，你得把这些一股脑全开着，否则搞不好会错过重要讯息，我常常在想，世界是多元化的，但本意是方便我们交流的工具最后却慢慢成了束缚我们的枷锁，从这个角度来看，人类到底是进步了，还是退化了？</p>
]]></content>
      
        
        <tags>
            
            <tag> Reading </tag>
            
            <tag> Economy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面壁者，我是你的破壁人]]></title>
      <url>/2017/05/29/%E4%B8%89%E4%BD%93/</url>
      <content type="html"><![CDATA[<p>对一个人的评判若不结合他所处的时代都是不公允的。</p>
<p>终于看完了《三体》全集，这部科幻小说给人的感觉真像作者自己命名的“地球往事”，像一本历史书，以宇宙为坐标，以光年为刻度，读罢，借用一句话“科幻小说虽然尽是对于未来的想象，但我们探索的一直是人的内心”。</p>
<p>情节上我就不剧透太多了，我想谈谈《三体》里的几个角色。</p>
<a id="more"></a>
<p>首先是罗辑，面壁者、执剑人、守墓人是他不同时期的身份，他是一个充满传奇色彩的人，用他自己的话是一个及时行乐的人，对其他的人、其他的事都不怎么上心的人。但是我看到的是他受人胁迫而终于接受面壁者身份时的无奈和挣扎；在冬眠复苏时被人当做笑话时的淡然、洒脱，再一次被推上历史转折点时的坚韧以及作为执剑人半个多世纪面壁时的狠厉。我得承认全书给我印象最深的是《黑暗森林》最高潮的部分，当罗辑站在自己挖掘的坟墓边对着虚空中的智子亮出最后底牌的那一刻；我真的有一种作为人类终于得救了、终于又有了希望的感觉。命运喜欢捉弄罗辑，在他吊儿郎当、无所事事时对他施以面壁者的诅咒，在他拯救了全人类时却让人类对他报以敌视；但罗辑不在乎这些，他只在乎自己所爱的那个女孩的幸福。</p>
<p>然后是《死神永生》里的女主角程心。之前有看一个《x分钟读完三体》的短片，当时发现弹幕上对于程心大多数是一片骂声，随处可见诸如“程圣母毁灭世界”的字眼。不得不说在看《死神永生》的中后段我也一直对于程心是恨得咬牙切齿的，实话说，我讨厌她的不作为和自以为是爱与善的化身所做的所有决定，讨厌她毁灭了地球、害人类灭亡，但后来一想，我其实是开了上帝视角在看这个角色，其实回过头来看，程心是当前普通人类的典型，甚至，是大众中向善的群体的典型，她一直秉持着自己的责任，逆来顺受；她是勇敢的，敢于牺牲自己，但是，她的能力是不够的。整部小说看下来程心大部分时间处于冬眠状态，而经常是其他人帮她做足了准备，然后突然一下把她推到全人类命运决策的位置，可是却没有想过她准备好了没有，结果她只能依据自己当前的认识做出最佳选择，然后成了公众的替罪羊，其实换位思考，我们估计在那个节点做的更差；不信你把程心放到不同的时间段看公众对于她作为执剑人的那几分钟的态度的不停反复就可以看出来了，大众只是需要一个为自己顶包的人，然后好像自己就可以置身事外了。</p>
<p>如果说程心更多的依靠感性来做判断，那么就不得不提到维德了，这个极端理性到冷酷的男人。最开始他对于程心的捉弄确实让我很不爽，从发射云天明的大脑一直到后面他不择手段的想要暗杀程心竞争执剑人。但读到后面你会发现维德其实是个表里如一的人，对于自己认定的事他能坚持到底，不择手段的坚持到底。</p>
<p>所以不存在这么一个人，把他放到任何一个时空他的判断都是对的，或者说大众对于个体的判断其实也不能代表什么，一个人只需坚持自己所相信的，在乎自己所爱的，到最后一刻，就够了。</p>
<p>各位面壁者们，准备好做自己的破壁人了么？</p>
]]></content>
      
        
        <tags>
            
            <tag> Reading </tag>
            
            <tag> Novel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平凡的世界，不平凡的凡人]]></title>
      <url>/2017/05/29/%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>一直想读这套书，在临近毕业时还专门从朋友那收藏了一套，借着在MEB的机会终于是忙里偷闲的看完了，虽意犹未尽，却也感到一种平和和满足。</p>
<p><strong>如果要用一句话概括，《平凡的世界》写的是爱情和面包。</strong></p>
<a id="more"></a>
<p>书中描述的爱情种类比较多，我就简单挑给我印象最深的三个来说说吧。首先是润叶和少安的爱情，那句诗里写的“郎骑竹马来，绕床弄青梅”大抵描述的就是这么一种爱情。少安和润叶是两小无猜的一对童年玩伴，随着两家各自发展出的家庭背景的差异却也慢慢在双方之间产生了巨大的鸿沟，一个留校任教成了城里人，另一个却回家务农，给家里分担压力。诚然，你可以说是少安主观上的懦弱导致了最终两人的分离和三个家庭的阴影和痛苦，但是个人认为，在那么一种背景下，就一个男人而言是不得不考虑这些东西的。书中虽说如果两人身份对调也许就没什么问题，但我觉得即使两人身份对调而彼此相爱也还是要考虑双方的家庭背景，这里我倒不是在推崇门当户对的老观念，只是客观的分析一下，毕竟，我一直认为，爱情是建立在一定的物质基础之上，不是简单的彼此相爱，毕竟，爱情可能产生在一瞬间，但是维系这份感情却需要长期的努力，也就需要一定的物质作为基础，而若双方各自条件不对等，时间长了或多或少会产生并积累一些问题。由此看来，古人所推崇的门当户对确有一定道理。</p>
<p>当然，我不否认灰姑娘和王子的童话故事，但是即使在灰姑娘的故事里，灰姑娘也是有仙子为她做后盾的而且她本身有相对应的素质作为支撑。</p>
<p>扯远了，其实书中倒也有这么一对，就是少平和晓霞。我对这一对的定义是充满理想和浪漫主义色彩的情侣，两人由最初的共同爱好或说理想发展出深厚的友谊，继而在不同的人生道路上产生的共鸣引导出爱情，说实话，看到这里我已经觉得有点过于理想化了，到后来晓霞拒绝高富帅依然坚定地爱着少平时，我也深深被打动，从心理上我是希望看到这一对能有美好的结局的，我原希望会是少平从煤炭场最后走出来完成逆袭然后迎娶白富美的励志故事（原谅程序员的屌丝气息），不过感觉依作者的套路势必会再给这对有情人制作一些波折，可是，万万没想到，情节发展居然是晓霞的牺牲，当时感觉很难接受这一事实，毕竟这朴实的书中的一朵充满浪漫主义色彩的绚丽花朵竟以这种方式枯萎。</p>
<p>最后一对就是润叶和向前，很难用爱情定义这一对，因为故事前段一直是向前的单恋，即使两人的结合也是润叶的自我牺牲和自我放逐，结果是长期的互相折磨到最后，然后转折点在向前的事故所带来的残疾，润叶因为内疚而突然回头，两人复合（个人觉得此处作者不够深入），然后两人开始真正的婚姻生活，不过也很难说是爱情，连文中也提及此时的润叶更像是一个虔诚的修女，给予向前的除了妻子的责任另外确是一种变相的母性关怀，姑且称之为——怜悯或者同情吧，其实我是很喜欢润叶这么个姑娘的，敢爱敢恨，在和少安的爱情中表现出勇敢，却又太懂事，这样矛盾的性格造成她最终的屈服，与其说她是嫁给了一个自己不爱的男人，倒不如说她是嫁给了生活。但我又不能怪罪向前，爱情这东西说不清道不明的，很多时候其实就是，我喜欢你然而我并不能理解你为何不喜欢我，其结果至少有一人受伤。</p>
<p>以上是对书中描述的几种爱情的粗浅理解，当然，作为一个纯理论家，请相信，我说的每一句话都是谎话。</p>
<p>还是来谈谈另一条线——面包吧。</p>
<p>全书主要描述了双水村这么个平凡的小天地里一个又一个像你像他像那路边野花的平凡人的平凡而又不平凡的生活。总体来说，大的背景是变化莫测的，从文革末的动乱年代到改革开放的小康生活，立足在这么一个大环境下，每个人的命运都不能孤立的来看，刚开始看这本书的时候我常常随着故事的情节发展给故事中的人下定义是好是坏是对是错，后来随着作者时不时的客观分析才发现自己的浅薄，其实就像我们所生活中的生活，它不像我们做的卷子上的题目，没有什么绝对的对错，每个人只是在给他演出的那么一段镜头里或优雅谢幕或落荒而逃，导演却是生活。也许我仍不能从简单的评判一个人是好人坏人，他做的一件事是对的还是错的这么一种观念里走出来，但是从这本书里我看到了生活这辆无缰马车上的形形色色人物的身不由己，同时，我也看到他们的奋斗，一次一次被生活喊cut却又一次一次带着微笑或者含着泪水伤痕累累的跑龙套，在这场戏里，没有主角，或者说每个人都是主角，轮番上场。</p>
<p>每一个人物都有其鲜明特色又有其局限性，之前有一朋友说他觉得书中把任务刻画得太脸谱化了，我觉得是有这么一点，但是大体而言路遥对人物的刻画还是很鲜明，很丰满而有血有肉的。我欣赏少安在物质生活追求上的不屈不挠精神，却又为他有时的偏执扼腕，对于他在爱情上的胆怯以及一意孤行而叹息；我喜欢少平这么一个脚踏实地的为生活战斗，为自己为他人着想的‘精神贵族’。他太可爱了，看这本书真的就是看着这个少年的成长，看着他咀嚼生活，消化生活，不过我希望他能更勇敢，有时能多为自己考虑一点，勇敢的追逐自己的幸福；至于晓霞，自不用说，感觉书中几乎刻画成女神一般的存在了，可惜也由于她的冒险精神和舍己为人的精神而香消玉殒；润叶，真是一个让人忍不住心疼却又忍不住尊敬的女性，她是那么为大家着想，甚至于可以牺牲自己；还有孙玉厚，这个伟大的老父亲，虽然书中没太多专门的笔墨，但是仍可以看见少安、少平甚至兰花从他身上传承的坚韧的基因，也许从早期发狠供玉亭念书也能窥见一二，另外，这位老人在儿子追求自己目标时默默支持，在孩子们遭受不幸时却总是挺身而出，实在令人感动；其他还有用情专一的向前，逛鬼王满银，懂事的兰香等等，像你我身边的每一个人一样在这个平凡的世界里献上了这精彩的演出，然后帷幕缓缓落下，他们又消失在人群中，从此你我看到的身边的每一个人都似曾相识。</p>
<p>以上大概就是这粗略的第一次阅读《平凡的世界》的一点不吐不快的想法，虽然书有一点点小瑕疵比如各个主角的结局实在难以让我这么一个习惯了happy ending的人满意，比如中间外星人的情节有点乱入的感觉，不过还是强力推荐这本书，怎么说呢，在看这本书的过程中，我常常有一种踏实感，活着的踏实感，在我合上书页，回想起书中一些情节时情不自禁的感受到生活，从某种程度上，它减轻了我若有若无的虚无感。</p>
]]></content>
      
        
        <tags>
            
            <tag> Reading </tag>
            
            <tag> Novel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[韶华倾负，难舍皮囊]]></title>
      <url>/2017/05/29/%E9%9F%B6%E5%8D%8E%E5%80%BE%E8%B4%9F%EF%BC%8C%E9%9A%BE%E8%88%8D%E7%9A%AE%E5%9B%8A/</url>
      <content type="html"><![CDATA[<p>利用在动车上的四个小时看完了《皮囊》（除去中间15分钟和邻座美女搭讪的时间），感觉是很不错的一本书，不同的章节写的不同的故事，如果你有时间不妨通篇阅读一下，如果没有时间不妨听我说一说。</p>
<p>个人觉得，前五章的主题关于生离，关于死别。</p>
<p>第一章和书同名是为《皮囊》，讲述的是99岁的阿太。</p>
<p><em>我们的生命本来多轻盈，都是被这肉体和各种欲望的污浊给拖住。阿太，我记住了。“肉体是拿来用的，不是拿来伺候的。”</em></p>
<a id="more"></a>
<p>没文化的神婆阿太穷极一生都在利用自己的那副皮囊，甚至要求周围的人也学会去利用好这幅皮囊，所以她把年幼的孩子扔进海里让他学游泳，所以她即使白发人送黑发人也保持一副让人不解的嘲弄表情，或许在她看来，失掉这皮囊，灵魂最终的归宿反而是自由吧。</p>
<p>但这并不意味着阿太是那种不在乎生死的人，相反，我觉得她是站在更高的角度看待生死这个问题的人，而这也许隐隐约约影响着身边的人。所以作者后来写下这么一句话：</p>
<p><em>从小我就喜欢闻泥土的味道，也因此其实从小我不怕死，一直觉得死是回家，是入土。我反而觉得生才是问题，人学会站立，是任性地想脱离这土地，因此不断向上攀爬，不断抓取任何理由——欲望、理想、追求。然而，我们终究需要脚踏着黄土。在我看来，生是更激烈的索取，或许太激烈的生活本身就是一种任性。</em></p>
<p>然后是第二章——《母亲的房子》写的是母亲，房子还有爱情。</p>
<p>每个人都会有自己的执着，而那种执着最后就物化成某种具体的事物，然后进一步，有的化成妥协后的一道疤痕，有的成为穷极一生的执念。而文中的母亲显然是后者，而她所执着的是那所房子，是年轻时的父亲曾允诺的房子，以一种执着的近乎任性的方式。从最开始的一修再修，这所母亲执意要修建的房子联系着一家人的生活和命运，从拮据的生活到后来周围人的不解最后甚至家人的埋怨，母亲一度支撑不下去却又不甘心，最难过的日子里甚至一家人想要一起求死，直到后来身为“不合格的一家之主”的我终于理解了母亲：</p>
<p><em>事实上，知道母亲坚持要建好这房子的那一刻。我才明白过来，前两次建房，为的不是她或者我的脸面，而是父亲的脸面——她想让父亲发起的这个家庭看上去是那么健全和完整。</em></p>
<p><em>这是母亲从老没表达过，也不可能说出口的爱情。</em></p>
<p>另外，关于母亲的故事在《我的神明朋友》里会继续讲述，你会看到更多母亲身上的坚韧。</p>
<p>然后《残疾》讲述的是父亲中风后的家里的种种艰辛和一家人和生活的抗争。</p>
<p>不同于以前语文课本里父亲那种高大、沉默的形象，《皮囊》里的父亲首先是一个中风而偏瘫了的父亲，而后是一个曾经混黑社会呼风唤雨的混混头子，中风前后的心理落差造成了父亲接下来的一系列变化，他从假装坚强，希望靠对时间的严苛要求和每天的活动恢复到以前的健壮身体，于是一家人默契的相互演着戏，却也过了一段幸福的时间，直到被一场意料之中的台风摧毁。</p>
<p><em>虽然知道根本不是台风的错。那结局是注定的，生活中很多事情，该来的会来，不以这个形式，就会以那样的形式。但把事情简单归咎于我们无能为力的某个点，会让我们的内心可以稍微自我安慰一下，所以，我至今仍愿意诅咒那次台风。</em></p>
<p>那场台风刮倒的不仅仅是父亲，更打碎了父亲伪装的坚强和一家人匆忙写就的生活的剧本。自此，父亲进入了第二个状态，先是放弃了坚强，呈现出一副自暴自弃的样子期盼着死亡。而后又进入下一阶段，甚至于舍弃了父亲的身份，像个不懂事的孩子一样撒娇、任性，却不再期盼死亡。</p>
<p>但是父亲的故事并没有完，在《重症病房里的圣诞节》，作者以在重症病房里的看护家属的视角半写实半轻描淡写地描述了退去浮华身份后的种种生离死别。</p>
<p><em>疾病在不同的地方找到了他们，即使他们当时身处不同的生活，但疾病一眼看出他们共同的地方，统一把他们赶到这么一个地方圈养。</em></p>
<p>在这一章里，作者刻画了几个不同的人物，有乐观的病人，有刻意显得刻薄的医护人员，有早熟的同龄孩子。在医院这么一个特殊的小世界里，赤裸的生长着。有几个事件的刻画让我印象深刻，比如‘我’对于医院里电梯的描写，对于走过一间间病房核查之前的病人是否还在；比如和同龄的孩子交流，发现相同点，大家拥有相同的眼睛，那是经历过生命消逝后才看得到的眼睛，所以会被一眼看透，而无法交到同龄的朋友，因为他们只有一次也只能有一次痛彻心扉的谈话；比如乐观的病友最后还是被夺走生命后‘我’心态上的变化，印象最深的是那个为父亲在圣诞节违禁燃放烟花的年轻人，只因他父亲要进行手术了，然后他被三个保安团团围住……</p>
<p><em>比如，在帮父亲换输液瓶时，会发觉他手上密密麻麻的针孔，找不到哪一寸可以用来插针；比如医生会时常拿着两种药让我选择，这个是进口的贵点的，这个是国产的便宜的，你要哪种？我问了问进口的价钱，想了很久。“国产的会有副作用吗？”“会，吃完后会有疼痛，进口的就不会。”我算了算剩下的钱和可能要住院的时间，“还是国产的吧。” 然后看着父亲疼痛了一个晚上，怎么都睡不着。</em></p>
<p><em>在这里，你一不小心留出空当，就会被悲伤占领——这是疾病最廉价、最恼人的雇佣兵。</em></p>
<p>这种笔触没在重症病房待过的人是写不出来的，那种切实的压抑感和空闲下来被对未来的恐惧和迷茫逼到绝路的走投无路感。</p>
<p>接下来的几章个人觉得是关于青春和梦想的。</p>
<p>首先《张美丽》这一章从这么一个略显俗气的名字开始，从迷信的桃色传说开始记叙了传说中自杀的殉情张美丽，而后记叙了现实中被夹在理想和世俗之间压垮的张美丽，同样是一副让荷尔蒙萌动的青春期少年燥起来的皮囊，演绎了不同的故事。这故事一面让我想起了《搜索》这部电影里舆论的可怕，人们对于未知的事物的不理解演化成的嫉妒和驱逐和以讹传讹造成的悲剧上演。另一面看到的是被遗忘的先驱们，为了自己的理想而头破血流，然后若干年后在残次不齐的字里行间被遗忘或变成谈资。只是人们一同忘掉的，是现在所呈现在眼前的似曾相识。</p>
<p>接下来《阿小和阿小》、《天才文展》记叙的算是童年和成长吧。</p>
<p>关于城市，那是不在城市长大的孩子们小时候的天堂，是他们在电视屏幕上看到的模样，而两个阿小，一个土生土长在小城镇；另一个为即将开始的大城市生活过度而寄居在小城镇。同样的名字，也沉浸在同样的幻想里，只是他们误读了城市，他们以为的城市就真的是电视屏幕上的那样，数不过来的高楼，四六分的香港发饰，衬衫，洁白的牙齿……于是，他们开始注重外表上的模仿和行为上的接近，在我看来，这正是一种青春期的迷茫，对于寻找自我定位时的种种探索，追求那些很酷很与众不同的感觉。但是结局却不尽如意：</p>
<p><em>大部分人都困倦到睡着了——他们都是一早七点准时在家门口等着这车到市区，他们出发前各自化妆、精心穿着，等着到这城市的各个角落，扮演起维修工、洗碗工、电器行销售、美发店小弟……时间一到，又仓皇地一路小跑赶这趟车，搭一两个小时回所谓的家，准备第二天的演出。</em></p>
<p><em>他们都是这城市的组成部分。而这城市，曾经是我们在小镇以为的，最美的天堂。他们是我们曾经认为的，活在天堂里的人。</em></p>
<p>而《天才文展》里的文展则代表着一种有远大抱负却囿于家庭环境的早熟的年轻人，也许我们都碰到过像这样的人，以一种居高临下的姿态看着你，对于自我有着严苛的要求，希望通过一项项计划通来向别人证明自己，来狠狠地扇曾经看不起自己的人一耳光。</p>
<p><em>我才明白，那封信里，我向文展说的“小时候的玩伴真该一起聚聚了”，真是个天真的提议。每个人都已经过上不同的生活，不同的生活让许多人在这个时空里没法相处在共同的状态中，除非等彼此都老了，年迈再次抹去其他，构成我们每个人最重要的标志，或许那时候的聚会才能成真。</em></p>
<p>然而结局却是悲剧的，‘我’最终过上了文展所希冀的生活而遭到文展的嫉妒和排斥，令人吃惊的是‘我’却也产生了一些负罪感。就像电视剧里经常碰到的桥段，“如果不是因为当初XXX，你现在所有的一切本该是我的。”其实这何尝不是自我欺骗呢，就算自我假设的前提条件不成立，结局却不见得会不一样，失败者把失败原因归结到自己以外的事物上注定还是会重蹈覆辙。</p>
<p>然后是《厚朴》描述的这么一个可爱的男生，英文名又是hope，伴着激情和叛逆的形象出场，不得不说让我想起身边一些充满朝气和正能量的人，平时还是很羡慕他们的，不过厚朴是不同的，开始我也很希望看看他所谓的“务虚”能走出一片天地来，俗话说就是理想主义者，因为我感觉自己更类似于作者。不过可惜的是最后结局让人痛心，像作者所形容的</p>
<p><em>不清楚真实的标准时，越用力就越让人觉得可笑。</em></p>
<p><em>不合时宜的东西，如果自己虚弱，终究会成为人们嘲笑的对象，但有力量了，或坚持久了，或许反而能成为众人追捧的魅力和个性——让我修正自己想法，产生这个判断的，是厚朴。</em></p>
<p><em>他以为自己做着摧毁一切规矩的事情，但其实一直活在规矩里。我以为自己战战兢兢地以活在规矩里为生活方式，但其实却对规矩有着将其彻底摧毁的欲望。</em></p>
<p>所以厚朴所表现出来的其实是一种沉浸在自己构造的幻想世界里而最终难以回到现实，他不愿接受自己失败了的现实，只是表现的叛逆。但话说回来我是希望能看到一种理想主义者最终实现理想的故事，我相信如果有那么一定会是精彩的。</p>
<p>说到这里我甚至有一种奇怪的感觉，是否厚朴其实就是作者的另一面，只是最终发现自己其实是在规则里画着圈而随着屈服而死掉的那部分。</p>
<p>最后几章主要简单谈了些关于城市、理想之类的话题，印象较之之前的几章倒是没那么深了，截取一段如下</p>
<p><em>只是我觉得城市不好。特别是中国的城市不好。厦门和中国大部分城市的建设都有个基础——人家国外的城市是怎么样的，以及人们该怎么被组织的，然后再依据这样的标准建设。中国近代的城市不是长出来的，不是培植出来的，不是催生出来的，而是一种安排。因为初期必然要混乱，所以中国的城市也表现出强大的秩序意识，人要干吗，路要怎么样。生长在这样环境里的人，除了维护秩序或者反抗秩序，似乎也难接受第二层次的思维了。</em></p>
<p>回头来看，几篇文章倒确实很契合《皮囊》这么一个主题，就像开头所述的，灵魂离不开皮囊，无论你如何讨厌自己的这幅皮囊，你的灵魂也得附庸其下。皮囊往小的说就是阿太所谓的驱壳和父亲半瘫的残疾，往大了说是一个人所处的位置，他背后的故事，就像母亲的那所房子，阿小的香港梦，厚朴的架子鼓。过去我常常看不懂电视剧里有些人的无可奈何，一厢情愿的认为这么容易的事换做是我直接三下五除二就解决了，实际情况却是不要以好坏善恶对错来划分人群，你看到的只是他当前展现给你的，你看不到的是他这一举动后面的挣扎，人是不能孤立和剥离来看的，当他站在你面前时，你得看到他的背景。</p>
<p><em>我常对朋友说，理解是对他人最大的善举。当你坐在一个人面前，听他开口说话，看得到各种复杂、精密的境况和命运，如何最终雕刻出这样的性格、思想、做法、长相，这才是理解。而有了这样的眼睛，你才算真正“看见”那个人，也才会发觉，这世界最美的风景，是一个个活出各自模样和体系的人。</em></p>
<p>如果每个人都是一段程序的话，那么我们在和不同的人交往的过程中就有意无意的修改了他们的代码，从此也许他们身上就带着你的痕迹；而身边亲近的人，更像是写进你基因里的代码段，在某个特定的时间里被激活，让你似曾相识，让你视线模糊。</p>
<p>无论如何，请带着这副皮囊好好生活。</p>
]]></content>
      
        
        <tags>
            
            <tag> Reading </tag>
            
            <tag> Novel </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
